{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst HasOne = require('./has-one');\n\nconst HasMany = require('./has-many');\n\nconst BelongsToMany = require('./belongs-to-many');\n\nconst BelongsTo = require('./belongs-to');\n\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options = Object.assign(options, _.omit(source.options, ['hooks']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', {\n        source,\n        target,\n        type: HasMany\n      }, options);\n    } // the id is in the foreign table or in a connecting table\n\n\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', {\n        source,\n        target,\n        type: HasMany,\n        association\n      }, options);\n    }\n\n    return association;\n  },\n\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    options = Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', {\n        source,\n        target,\n        type: BelongsToMany\n      }, options);\n    } // the id is in the foreign table or in a connecting table\n\n\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', {\n        source,\n        target,\n        type: BelongsToMany,\n        association\n      }, options);\n    }\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return _.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n\n}; // The logic for hasOne and belongsTo is exactly the same\n\nfunction singleLinked(Type) {\n  return function (target, options = {}) {\n    // eslint-disable-next-line no-invalid-this\n    const source = this;\n\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    } // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks('beforeAssociate', {\n        source,\n        target,\n        type: Type\n      }, options);\n    } // the id is in the foreign table\n\n\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks('afterAssociate', {\n        source,\n        target,\n        type: Type,\n        association\n      }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/associations/mixin.js"],"names":["_","require","HasOne","HasMany","BelongsToMany","BelongsTo","isModel","model","sequelize","prototype","Sequelize","Model","Mixin","hasMany","target","options","Error","name","source","hooks","undefined","Boolean","useHooks","Object","assign","omit","runHooks","type","association","associations","associationAccessor","_injectAttributes","mixin","belongsToMany","timestamps","getAssociations","values","filter","getAssociationForAlias","alias","find","verifyAssociationAlias","singleLinked","Type","lowerFirst","hasOne","belongsTo","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst HasOne = require('./has-one');\nconst HasMany = require('./has-many');\nconst BelongsToMany = require('./belongs-to-many');\nconst BelongsTo = require('./belongs-to');\n\nfunction isModel(model, sequelize) {\n  return model\n    && model.prototype\n    && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    options = Object.assign(options, _.omit(source.options, ['hooks']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: HasMany }, options);\n    }\n\n    // the id is in the foreign table or in a connecting table\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: HasMany, association }, options);\n    }\n\n    return association;\n  },\n\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    options = Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: BelongsToMany }, options);\n    }\n    // the id is in the foreign table or in a connecting table\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: BelongsToMany, association }, options);\n    }\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return _.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n};\n\n// The logic for hasOne and belongsTo is exactly the same\nfunction singleLinked(Type) {\n  return function(target, options = {}) {\n    // eslint-disable-next-line no-invalid-this\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks('beforeAssociate', { source, target, type: Type }, options);\n    }\n    // the id is in the foreign table\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks('afterAssociate', { source, target, type: Type, association }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\n\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;\n"]},"metadata":{},"sourceType":"script"}