{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safer-buffer').Buffer; // == UTF32-LE/BE codec. ==========================================================\n\n\nexports._utf32 = Utf32Codec;\n\nfunction Utf32Codec(codecOptions, iconv) {\n  this.iconv = iconv;\n  this.bomAware = true;\n  this.isLE = codecOptions.isLE;\n}\n\nexports.utf32le = {\n  type: '_utf32',\n  isLE: true\n};\nexports.utf32be = {\n  type: '_utf32',\n  isLE: false\n}; // Aliases\n\nexports.ucs4le = 'utf32le';\nexports.ucs4be = 'utf32be';\nUtf32Codec.prototype.encoder = Utf32Encoder;\nUtf32Codec.prototype.decoder = Utf32Decoder; // -- Encoding\n\nfunction Utf32Encoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.highSurrogate = 0;\n}\n\nUtf32Encoder.prototype.write = function (str) {\n  var src = Buffer.from(str, 'ucs2');\n  var dst = Buffer.alloc(src.length * 2);\n  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;\n  var offset = 0;\n\n  for (var i = 0; i < src.length; i += 2) {\n    var code = src.readUInt16LE(i);\n    var isHighSurrogate = 0xD800 <= code && code < 0xDC00;\n    var isLowSurrogate = 0xDC00 <= code && code < 0xE000;\n\n    if (this.highSurrogate) {\n      if (isHighSurrogate || !isLowSurrogate) {\n        // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low\n        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character\n        // (technically wrong, but expected by some applications, like Windows file names).\n        write32.call(dst, this.highSurrogate, offset);\n        offset += 4;\n      } else {\n        // Create 32-bit value from high and low surrogates;\n        var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;\n        write32.call(dst, codepoint, offset);\n        offset += 4;\n        this.highSurrogate = 0;\n        continue;\n      }\n    }\n\n    if (isHighSurrogate) this.highSurrogate = code;else {\n      // Even if the current character is a low surrogate, with no previous high surrogate, we'll\n      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for\n      // unpaired high surrogates.\n      write32.call(dst, code, offset);\n      offset += 4;\n      this.highSurrogate = 0;\n    }\n  }\n\n  if (offset < dst.length) dst = dst.slice(0, offset);\n  return dst;\n};\n\nUtf32Encoder.prototype.end = function () {\n  // Treat any leftover high surrogate as a semi-valid independent character.\n  if (!this.highSurrogate) return;\n  var buf = Buffer.alloc(4);\n  if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);\n  this.highSurrogate = 0;\n  return buf;\n}; // -- Decoding\n\n\nfunction Utf32Decoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);\n  this.overflow = null;\n}\n\nUtf32Decoder.prototype.write = function (src) {\n  if (src.length === 0) return '';\n  if (this.overflow) src = Buffer.concat([this.overflow, src]);\n  var goodLength = src.length - src.length % 4;\n\n  if (src.length !== goodLength) {\n    this.overflow = src.slice(goodLength);\n    src = src.slice(0, goodLength);\n  } else this.overflow = null;\n\n  var dst = Buffer.alloc(goodLength);\n  var offset = 0;\n\n  for (var i = 0; i < goodLength; i += 4) {\n    var codepoint = this.isLE ? src.readUInt32LE(i) : src.readUInt32BE(i);\n\n    if (codepoint < 0x10000) {\n      // Simple 16-bit character\n      dst.writeUInt16LE(codepoint, offset);\n      offset += 2;\n    } else {\n      if (codepoint > 0x10FFFF) {\n        // Not a valid Unicode codepoint\n        dst.writeUInt16LE(this.badChar, offset);\n        offset += 2;\n      } else {\n        // Create high and low surrogates.\n        codepoint -= 0x10000;\n        var high = 0xD800 | codepoint >> 10;\n        var low = 0xDC00 + (codepoint & 0x3FF);\n        dst.writeUInt16LE(high, offset);\n        offset += 2;\n        dst.writeUInt16LE(low, offset);\n        offset += 2;\n      }\n    }\n  }\n\n  return dst.slice(0, offset).toString('ucs2');\n};\n\nUtf32Decoder.prototype.end = function () {\n  this.overflow = null;\n}; // == UTF-32 Auto codec =============================================================\n// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.\n// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32\n// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});\n// Encoder prepends BOM (which can be overridden with (addBOM: false}).\n\n\nexports.utf32 = Utf32AutoCodec;\nexports.ucs4 = Utf32AutoCodec;\n\nfunction Utf32AutoCodec(options, iconv) {\n  this.iconv = iconv;\n}\n\nUtf32AutoCodec.prototype.encoder = Utf32AutoEncoder;\nUtf32AutoCodec.prototype.decoder = Utf32AutoDecoder; // -- Encoding\n\nfunction Utf32AutoEncoder(options, codec) {\n  options = options || {};\n  if (options.addBOM === undefined) options.addBOM = true;\n  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);\n}\n\nUtf32AutoEncoder.prototype.write = function (str) {\n  return this.encoder.write(str);\n};\n\nUtf32AutoEncoder.prototype.end = function () {\n  return this.encoder.end();\n}; // -- Decoding\n\n\nfunction Utf32AutoDecoder(options, codec) {\n  this.decoder = null;\n  this.initialBytes = [];\n  this.initialBytesLen = 0;\n  this.options = options || {};\n  this.iconv = codec.iconv;\n}\n\nUtf32AutoDecoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBytes.push(buf);\n    this.initialBytesLen += buf.length;\n    if (this.initialBytesLen < 32) // We need more bytes to use space heuristic (see below)\n      return ''; // We have enough bytes -> detect endianness.\n\n    var buf2 = Buffer.concat(this.initialBytes),\n        encoding = detectEncoding(buf2, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    this.initialBytes.length = this.initialBytesLen = 0;\n  }\n\n  return this.decoder.write(buf);\n};\n\nUtf32AutoDecoder.prototype.end = function () {\n  if (!this.decoder) {\n    var buf = Buffer.concat(this.initialBytes),\n        encoding = detectEncoding(buf, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var res = this.decoder.write(buf),\n        trail = this.decoder.end();\n    return trail ? res + trail : res;\n  }\n\n  return this.decoder.end();\n};\n\nfunction detectEncoding(buf, defaultEncoding) {\n  var enc = defaultEncoding || 'utf-32le';\n\n  if (buf.length >= 4) {\n    // Check BOM.\n    if (buf.readUInt32BE(0) === 0xFEFF) // UTF-32LE BOM\n      enc = 'utf-32be';else if (buf.readUInt32LE(0) === 0xFEFF) // UTF-32LE BOM\n      enc = 'utf-32le';else {\n      // No BOM found. Try to deduce encoding from initial content.\n      // Using the wrong endian-ism for UTF-32 will very often result in codepoints that are beyond\n      // the valid Unicode limit of 0x10FFFF. That will be used as the primary determinant.\n      //\n      // Further, we can suppose the content is mostly plain ASCII chars (U+00**).\n      // So, we count ASCII as if it was LE or BE, and decide from that.\n      var invalidLE = 0,\n          invalidBE = 0;\n\n      var asciiCharsLE = 0,\n          asciiCharsBE = 0,\n          // Counts of chars in both positions\n      _len = Math.min(buf.length - buf.length % 4, 128); // Len is always even.\n\n\n      for (var i = 0; i < _len; i += 4) {\n        var b0 = buf[i],\n            b1 = buf[i + 1],\n            b2 = buf[i + 2],\n            b3 = buf[i + 3];\n        if (b0 !== 0 || b1 > 0x10) ++invalidBE;\n        if (b3 !== 0 || b2 > 0x10) ++invalidLE;\n        if (b0 === 0 && b1 === 0 && b2 === 0 && b3 !== 0) asciiCharsBE++;\n        if (b0 !== 0 && b1 === 0 && b2 === 0 && b3 === 0) asciiCharsLE++;\n      }\n\n      if (invalidBE < invalidLE) enc = 'utf-32be';else if (invalidLE < invalidBE) enc = 'utf-32le';\n      if (asciiCharsBE > asciiCharsLE) enc = 'utf-32be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-32le';\n    }\n  }\n\n  return enc;\n}","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/mysql2/node_modules/iconv-lite/encodings/utf32.js"],"names":["Buffer","require","exports","_utf32","Utf32Codec","codecOptions","iconv","bomAware","isLE","utf32le","type","utf32be","ucs4le","ucs4be","prototype","encoder","Utf32Encoder","decoder","Utf32Decoder","options","codec","highSurrogate","write","str","src","from","dst","alloc","length","write32","writeUInt32LE","writeUInt32BE","offset","i","code","readUInt16LE","isHighSurrogate","isLowSurrogate","call","codepoint","slice","end","buf","badChar","defaultCharUnicode","charCodeAt","overflow","concat","goodLength","readUInt32LE","readUInt32BE","writeUInt16LE","high","low","toString","utf32","Utf32AutoCodec","ucs4","Utf32AutoEncoder","Utf32AutoDecoder","addBOM","undefined","getEncoder","defaultEncoding","initialBytes","initialBytesLen","push","buf2","encoding","detectEncoding","getDecoder","res","trail","enc","invalidLE","invalidBE","asciiCharsLE","asciiCharsBE","_len","Math","min","b0","b1","b2","b3"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Buffer = require('safer-buffer').Buffer;\n\n// == UTF32-LE/BE codec. ==========================================================\n\nexports._utf32 = Utf32Codec;\n\nfunction Utf32Codec(codecOptions, iconv) {\n    this.iconv = iconv;\n    this.bomAware = true;\n    this.isLE = codecOptions.isLE;\n}\n\nexports.utf32le = { type: '_utf32', isLE: true };\nexports.utf32be = { type: '_utf32', isLE: false };\n\n// Aliases\nexports.ucs4le = 'utf32le';\nexports.ucs4be = 'utf32be';\n\nUtf32Codec.prototype.encoder = Utf32Encoder;\nUtf32Codec.prototype.decoder = Utf32Decoder;\n\n// -- Encoding\n\nfunction Utf32Encoder(options, codec) {\n    this.isLE = codec.isLE;\n    this.highSurrogate = 0;\n}\n\nUtf32Encoder.prototype.write = function(str) {\n    var src = Buffer.from(str, 'ucs2');\n    var dst = Buffer.alloc(src.length * 2);\n    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;\n    var offset = 0;\n\n    for (var i = 0; i < src.length; i += 2) {\n        var code = src.readUInt16LE(i);\n        var isHighSurrogate = (0xD800 <= code && code < 0xDC00);\n        var isLowSurrogate = (0xDC00 <= code && code < 0xE000);\n\n        if (this.highSurrogate) {\n            if (isHighSurrogate || !isLowSurrogate) {\n                // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low\n                // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character\n                // (technically wrong, but expected by some applications, like Windows file names).\n                write32.call(dst, this.highSurrogate, offset);\n                offset += 4;\n            }\n            else {\n                // Create 32-bit value from high and low surrogates;\n                var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000;\n\n                write32.call(dst, codepoint, offset);\n                offset += 4;\n                this.highSurrogate = 0;\n\n                continue;\n            }\n        }\n\n        if (isHighSurrogate)\n            this.highSurrogate = code;\n        else {\n            // Even if the current character is a low surrogate, with no previous high surrogate, we'll\n            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for\n            // unpaired high surrogates.\n            write32.call(dst, code, offset);\n            offset += 4;\n            this.highSurrogate = 0;\n        }\n    }\n\n    if (offset < dst.length)\n        dst = dst.slice(0, offset);\n\n    return dst;\n};\n\nUtf32Encoder.prototype.end = function() {\n    // Treat any leftover high surrogate as a semi-valid independent character.\n    if (!this.highSurrogate)\n        return;\n\n    var buf = Buffer.alloc(4);\n\n    if (this.isLE)\n        buf.writeUInt32LE(this.highSurrogate, 0);\n    else\n        buf.writeUInt32BE(this.highSurrogate, 0);\n\n    this.highSurrogate = 0;\n\n    return buf;\n};\n\n// -- Decoding\n\nfunction Utf32Decoder(options, codec) {\n    this.isLE = codec.isLE;\n    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);\n    this.overflow = null;\n}\n\nUtf32Decoder.prototype.write = function(src) {\n    if (src.length === 0)\n        return '';\n\n    if (this.overflow)\n        src = Buffer.concat([this.overflow, src]);\n\n    var goodLength = src.length - src.length % 4;\n\n    if (src.length !== goodLength) {\n        this.overflow = src.slice(goodLength);\n        src = src.slice(0, goodLength);\n    }\n    else\n        this.overflow = null;\n\n    var dst = Buffer.alloc(goodLength);\n    var offset = 0;\n\n    for (var i = 0; i < goodLength; i += 4) {\n        var codepoint = this.isLE ? src.readUInt32LE(i) : src.readUInt32BE(i);\n\n        if (codepoint < 0x10000) {\n            // Simple 16-bit character\n            dst.writeUInt16LE(codepoint, offset);\n            offset += 2;\n        }\n        else {\n            if (codepoint > 0x10FFFF) {\n                // Not a valid Unicode codepoint\n                dst.writeUInt16LE(this.badChar, offset);\n                offset += 2;\n            }\n            else {\n                // Create high and low surrogates.\n                codepoint -= 0x10000;\n                var high = 0xD800 | (codepoint >> 10);\n                var low = 0xDC00 + (codepoint & 0x3FF);\n                dst.writeUInt16LE(high, offset);\n                offset += 2;\n                dst.writeUInt16LE(low, offset);\n                offset += 2;\n            }\n        }\n    }\n\n    return dst.slice(0, offset).toString('ucs2');\n};\n\nUtf32Decoder.prototype.end = function() {\n    this.overflow = null;\n};\n\n// == UTF-32 Auto codec =============================================================\n// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.\n// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32\n// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});\n\n// Encoder prepends BOM (which can be overridden with (addBOM: false}).\n\nexports.utf32 = Utf32AutoCodec;\nexports.ucs4 = Utf32AutoCodec;\n\nfunction Utf32AutoCodec(options, iconv) {\n    this.iconv = iconv;\n}\n\nUtf32AutoCodec.prototype.encoder = Utf32AutoEncoder;\nUtf32AutoCodec.prototype.decoder = Utf32AutoDecoder;\n\n// -- Encoding\n\nfunction Utf32AutoEncoder(options, codec) {\n    options = options || {};\n\n    if (options.addBOM === undefined)\n        options.addBOM = true;\n\n    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);\n}\n\nUtf32AutoEncoder.prototype.write = function(str) {\n    return this.encoder.write(str);\n};\n\nUtf32AutoEncoder.prototype.end = function() {\n    return this.encoder.end();\n};\n\n// -- Decoding\n\nfunction Utf32AutoDecoder(options, codec) {\n    this.decoder = null;\n    this.initialBytes = [];\n    this.initialBytesLen = 0;\n    this.options = options || {};\n    this.iconv = codec.iconv;\n}\n\nUtf32AutoDecoder.prototype.write = function(buf) {\n    if (!this.decoder) {\n        // Codec is not chosen yet. Accumulate initial bytes.\n        this.initialBytes.push(buf);\n        this.initialBytesLen += buf.length;\n\n        if (this.initialBytesLen < 32) // We need more bytes to use space heuristic (see below)\n            return '';\n\n        // We have enough bytes -> detect endianness.\n        var buf2 = Buffer.concat(this.initialBytes),\n            encoding = detectEncoding(buf2, this.options.defaultEncoding);\n        this.decoder = this.iconv.getDecoder(encoding, this.options);\n        this.initialBytes.length = this.initialBytesLen = 0;\n    }\n\n    return this.decoder.write(buf);\n};\n\nUtf32AutoDecoder.prototype.end = function() {\n    if (!this.decoder) {\n        var buf = Buffer.concat(this.initialBytes),\n            encoding = detectEncoding(buf, this.options.defaultEncoding);\n        this.decoder = this.iconv.getDecoder(encoding, this.options);\n\n        var res = this.decoder.write(buf),\n            trail = this.decoder.end();\n\n        return trail ? (res + trail) : res;\n    }\n\n    return this.decoder.end();\n};\n\nfunction detectEncoding(buf, defaultEncoding) {\n    var enc = defaultEncoding || 'utf-32le';\n\n    if (buf.length >= 4) {\n        // Check BOM.\n        if (buf.readUInt32BE(0) === 0xFEFF) // UTF-32LE BOM\n            enc = 'utf-32be';\n        else if (buf.readUInt32LE(0) === 0xFEFF) // UTF-32LE BOM\n            enc = 'utf-32le';\n        else {\n            // No BOM found. Try to deduce encoding from initial content.\n            // Using the wrong endian-ism for UTF-32 will very often result in codepoints that are beyond\n            // the valid Unicode limit of 0x10FFFF. That will be used as the primary determinant.\n            //\n            // Further, we can suppose the content is mostly plain ASCII chars (U+00**).\n            // So, we count ASCII as if it was LE or BE, and decide from that.\n            var invalidLE = 0, invalidBE = 0;\n            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions\n                _len = Math.min(buf.length - (buf.length % 4), 128); // Len is always even.\n\n            for (var i = 0; i < _len; i += 4) {\n                var b0 = buf[i], b1  = buf[i + 1], b2 = buf[i + 2], b3 = buf[i + 3];\n\n                if (b0 !== 0 || b1 > 0x10) ++invalidBE;\n                if (b3 !== 0 || b2 > 0x10) ++invalidLE;\n\n                if (b0 === 0 && b1 === 0 && b2 === 0 && b3 !== 0) asciiCharsBE++;\n                if (b0 !== 0 && b1 === 0 && b2 === 0 && b3 === 0) asciiCharsLE++;\n            }\n\n            if (invalidBE < invalidLE)\n                enc = 'utf-32be';\n            else if (invalidLE < invalidBE)\n                enc = 'utf-32le';\n            if (asciiCharsBE > asciiCharsLE)\n                enc = 'utf-32be';\n            else if (asciiCharsBE < asciiCharsLE)\n                enc = 'utf-32le';\n        }\n    }\n\n    return enc;\n}\n"]},"metadata":{},"sourceType":"script"}