{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connector = exports.SequentialConnectionStrategy = exports.ParallelConnectionStrategy = void 0;\n\nvar _net = _interopRequireDefault(require(\"net\"));\n\nvar _dns = _interopRequireDefault(require(\"dns\"));\n\nvar punycode = _interopRequireWildcard(require(\"punycode\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n\n  if (obj != null) {\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nclass ParallelConnectionStrategy {\n  constructor(addresses, options) {\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  connect(callback) {\n    const addresses = this.addresses;\n    const sockets = new Array(addresses.length);\n    let errorCount = 0;\n\n    function onError(_err) {\n      errorCount += 1;\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n\n      if (errorCount === addresses.length) {\n        callback(new Error('Could not connect (parallel)'));\n      }\n    }\n\n    function onConnect() {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        if (this === socket) {\n          continue;\n        }\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      callback(null, this);\n    }\n\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = _net.default.connect(Object.create(this.options, {\n        host: {\n          value: addresses[i].address\n        }\n      }));\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n  }\n\n}\n\nexports.ParallelConnectionStrategy = ParallelConnectionStrategy;\n\nclass SequentialConnectionStrategy {\n  constructor(addresses, options) {\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  connect(callback) {\n    const next = this.addresses.shift();\n\n    if (!next) {\n      return callback(new Error('Could not connect (sequence)'));\n    }\n\n    const socket = _net.default.connect(Object.create(this.options, {\n      host: {\n        value: next.address\n      }\n    }));\n\n    const onError = _err => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      this.connect(callback);\n    };\n\n    const onConnect = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      callback(null, socket);\n    };\n\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n}\n\nexports.SequentialConnectionStrategy = SequentialConnectionStrategy;\n\nclass Connector {\n  constructor(options, multiSubnetFailover) {\n    this.options = options;\n    this.multiSubnetFailover = multiSubnetFailover;\n  }\n\n  execute(cb) {\n    if (_net.default.isIP(this.options.host)) {\n      this.executeForIP(cb);\n    } else {\n      this.executeForHostname(cb);\n    }\n  }\n\n  executeForIP(cb) {\n    const socket = _net.default.connect(this.options);\n\n    const onError = err => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      cb(err);\n    };\n\n    const onConnect = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      cb(null, socket);\n    };\n\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n  executeForHostname(cb) {\n    _dns.default.lookup(punycode.toASCII(this.options.host), {\n      all: true\n    }, (err, addresses) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (this.multiSubnetFailover) {\n        new ParallelConnectionStrategy(addresses, this.options).connect(cb);\n      } else {\n        new SequentialConnectionStrategy(addresses, this.options).connect(cb);\n      }\n    });\n  }\n\n}\n\nexports.Connector = Connector;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/tedious/lib/connector.js"],"names":["Object","defineProperty","exports","value","Connector","SequentialConnectionStrategy","ParallelConnectionStrategy","_net","_interopRequireDefault","require","_dns","punycode","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","default","constructor","addresses","options","connect","callback","sockets","Array","length","errorCount","onError","_err","removeListener","onConnect","Error","j","socket","destroy","i","len","create","host","address","on","next","shift","multiSubnetFailover","execute","cb","isIP","executeForIP","executeForHostname","err","lookup","toASCII","all"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,SAAR,GAAoBF,OAAO,CAACG,4BAAR,GAAuCH,OAAO,CAACI,0BAAR,GAAqC,KAAK,CAArG;;AAEA,IAAIC,IAAI,GAAGC,sBAAsB,CAACC,OAAO,CAAC,KAAD,CAAR,CAAjC;;AAEA,IAAIC,IAAI,GAAGF,sBAAsB,CAACC,OAAO,CAAC,KAAD,CAAR,CAAjC;;AAEA,IAAIE,QAAQ,GAAGC,uBAAuB,CAACH,OAAO,CAAC,UAAD,CAAR,CAAtC;;AAEA,SAASI,wBAAT,GAAoC;AAAE,MAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;AAAa,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AAA2BD,EAAAA,wBAAwB,GAAG,SAASA,wBAAT,GAAoC;AAAE,WAAOE,KAAP;AAAe,GAAhF;;AAAkF,SAAOA,KAAP;AAAe;;AAElN,SAASH,uBAAT,CAAiCI,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AAAE,WAAOD,GAAP;AAAa;;AAAC,MAAID,KAAK,GAAGF,wBAAwB,EAApC;;AAAwC,MAAIE,KAAK,IAAIA,KAAK,CAACG,GAAN,CAAUF,GAAV,CAAb,EAA6B;AAAE,WAAOD,KAAK,CAACI,GAAN,CAAUH,GAAV,CAAP;AAAwB;;AAAC,MAAII,MAAM,GAAG,EAAb;;AAAiB,MAAIJ,GAAG,IAAI,IAAX,EAAiB;AAAE,QAAIK,qBAAqB,GAAGrB,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACsB,wBAA5D;;AAAsF,SAAK,IAAIC,GAAT,IAAgBP,GAAhB,EAAqB;AAAE,UAAIhB,MAAM,CAACwB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCV,GAArC,EAA0CO,GAA1C,CAAJ,EAAoD;AAAE,YAAII,IAAI,GAAGN,qBAAqB,GAAGrB,MAAM,CAACsB,wBAAP,CAAgCN,GAAhC,EAAqCO,GAArC,CAAH,GAA+C,IAA/E;;AAAqF,YAAII,IAAI,KAAKA,IAAI,CAACR,GAAL,IAAYQ,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAAE5B,UAAAA,MAAM,CAACC,cAAP,CAAsBmB,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;AAA2C,SAAjF,MAAuF;AAAEP,UAAAA,MAAM,CAACG,GAAD,CAAN,GAAcP,GAAG,CAACO,GAAD,CAAjB;AAAyB;AAAE;AAAE;AAAE;;AAACH,EAAAA,MAAM,CAACS,OAAP,GAAiBb,GAAjB;;AAAsB,MAAID,KAAJ,EAAW;AAAEA,IAAAA,KAAK,CAACa,GAAN,CAAUZ,GAAV,EAAeI,MAAf;AAAyB;;AAAC,SAAOA,MAAP;AAAgB;;AAErpB,SAASZ,sBAAT,CAAgCQ,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEa,IAAAA,OAAO,EAAEb;AAAX,GAArC;AAAwD;;AAE/F,MAAMV,0BAAN,CAAiC;AAC/BwB,EAAAA,WAAW,CAACC,SAAD,EAAYC,OAAZ,EAAqB;AAC9B,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAEDC,EAAAA,OAAO,CAACC,QAAD,EAAW;AAChB,UAAMH,SAAS,GAAG,KAAKA,SAAvB;AACA,UAAMI,OAAO,GAAG,IAAIC,KAAJ,CAAUL,SAAS,CAACM,MAApB,CAAhB;AACA,QAAIC,UAAU,GAAG,CAAjB;;AAEA,aAASC,OAAT,CAAiBC,IAAjB,EAAuB;AACrBF,MAAAA,UAAU,IAAI,CAAd;AACA,WAAKG,cAAL,CAAoB,OAApB,EAA6BF,OAA7B;AACA,WAAKE,cAAL,CAAoB,SAApB,EAA+BC,SAA/B;;AAEA,UAAIJ,UAAU,KAAKP,SAAS,CAACM,MAA7B,EAAqC;AACnCH,QAAAA,QAAQ,CAAC,IAAIS,KAAJ,CAAU,8BAAV,CAAD,CAAR;AACD;AACF;;AAED,aAASD,SAAT,GAAqB;AACnB,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,OAAO,CAACE,MAA5B,EAAoCO,CAAC,EAArC,EAAyC;AACvC,cAAMC,MAAM,GAAGV,OAAO,CAACS,CAAD,CAAtB;;AAEA,YAAI,SAASC,MAAb,EAAqB;AACnB;AACD;;AAEDA,QAAAA,MAAM,CAACJ,cAAP,CAAsB,OAAtB,EAA+BF,OAA/B;AACAM,QAAAA,MAAM,CAACJ,cAAP,CAAsB,SAAtB,EAAiCC,SAAjC;AACAG,QAAAA,MAAM,CAACC,OAAP;AACD;;AAEDZ,MAAAA,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;AACD;;AAED,SAAK,IAAIa,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGjB,SAAS,CAACM,MAAhC,EAAwCU,CAAC,GAAGC,GAA5C,EAAiDD,CAAC,EAAlD,EAAsD;AACpD,YAAMF,MAAM,GAAGV,OAAO,CAACY,CAAD,CAAP,GAAaxC,IAAI,CAACsB,OAAL,CAAaI,OAAb,CAAqBjC,MAAM,CAACiD,MAAP,CAAc,KAAKjB,OAAnB,EAA4B;AAC3EkB,QAAAA,IAAI,EAAE;AACJ/C,UAAAA,KAAK,EAAE4B,SAAS,CAACgB,CAAD,CAAT,CAAaI;AADhB;AADqE,OAA5B,CAArB,CAA5B;;AAMAN,MAAAA,MAAM,CAACO,EAAP,CAAU,OAAV,EAAmBb,OAAnB;AACAM,MAAAA,MAAM,CAACO,EAAP,CAAU,SAAV,EAAqBV,SAArB;AACD;AACF;;AA/C8B;;AAmDjCxC,OAAO,CAACI,0BAAR,GAAqCA,0BAArC;;AAEA,MAAMD,4BAAN,CAAmC;AACjCyB,EAAAA,WAAW,CAACC,SAAD,EAAYC,OAAZ,EAAqB;AAC9B,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAEDC,EAAAA,OAAO,CAACC,QAAD,EAAW;AAChB,UAAMmB,IAAI,GAAG,KAAKtB,SAAL,CAAeuB,KAAf,EAAb;;AAEA,QAAI,CAACD,IAAL,EAAW;AACT,aAAOnB,QAAQ,CAAC,IAAIS,KAAJ,CAAU,8BAAV,CAAD,CAAf;AACD;;AAED,UAAME,MAAM,GAAGtC,IAAI,CAACsB,OAAL,CAAaI,OAAb,CAAqBjC,MAAM,CAACiD,MAAP,CAAc,KAAKjB,OAAnB,EAA4B;AAC9DkB,MAAAA,IAAI,EAAE;AACJ/C,QAAAA,KAAK,EAAEkD,IAAI,CAACF;AADR;AADwD,KAA5B,CAArB,CAAf;;AAMA,UAAMZ,OAAO,GAAGC,IAAI,IAAI;AACtBK,MAAAA,MAAM,CAACJ,cAAP,CAAsB,OAAtB,EAA+BF,OAA/B;AACAM,MAAAA,MAAM,CAACJ,cAAP,CAAsB,SAAtB,EAAiCC,SAAjC;AACAG,MAAAA,MAAM,CAACC,OAAP;AACA,WAAKb,OAAL,CAAaC,QAAb;AACD,KALD;;AAOA,UAAMQ,SAAS,GAAG,MAAM;AACtBG,MAAAA,MAAM,CAACJ,cAAP,CAAsB,OAAtB,EAA+BF,OAA/B;AACAM,MAAAA,MAAM,CAACJ,cAAP,CAAsB,SAAtB,EAAiCC,SAAjC;AACAR,MAAAA,QAAQ,CAAC,IAAD,EAAOW,MAAP,CAAR;AACD,KAJD;;AAMAA,IAAAA,MAAM,CAACO,EAAP,CAAU,OAAV,EAAmBb,OAAnB;AACAM,IAAAA,MAAM,CAACO,EAAP,CAAU,SAAV,EAAqBV,SAArB;AACD;;AAlCgC;;AAsCnCxC,OAAO,CAACG,4BAAR,GAAuCA,4BAAvC;;AAEA,MAAMD,SAAN,CAAgB;AACd0B,EAAAA,WAAW,CAACE,OAAD,EAAUuB,mBAAV,EAA+B;AACxC,SAAKvB,OAAL,GAAeA,OAAf;AACA,SAAKuB,mBAAL,GAA2BA,mBAA3B;AACD;;AAEDC,EAAAA,OAAO,CAACC,EAAD,EAAK;AACV,QAAIlD,IAAI,CAACsB,OAAL,CAAa6B,IAAb,CAAkB,KAAK1B,OAAL,CAAakB,IAA/B,CAAJ,EAA0C;AACxC,WAAKS,YAAL,CAAkBF,EAAlB;AACD,KAFD,MAEO;AACL,WAAKG,kBAAL,CAAwBH,EAAxB;AACD;AACF;;AAEDE,EAAAA,YAAY,CAACF,EAAD,EAAK;AACf,UAAMZ,MAAM,GAAGtC,IAAI,CAACsB,OAAL,CAAaI,OAAb,CAAqB,KAAKD,OAA1B,CAAf;;AAEA,UAAMO,OAAO,GAAGsB,GAAG,IAAI;AACrBhB,MAAAA,MAAM,CAACJ,cAAP,CAAsB,OAAtB,EAA+BF,OAA/B;AACAM,MAAAA,MAAM,CAACJ,cAAP,CAAsB,SAAtB,EAAiCC,SAAjC;AACAG,MAAAA,MAAM,CAACC,OAAP;AACAW,MAAAA,EAAE,CAACI,GAAD,CAAF;AACD,KALD;;AAOA,UAAMnB,SAAS,GAAG,MAAM;AACtBG,MAAAA,MAAM,CAACJ,cAAP,CAAsB,OAAtB,EAA+BF,OAA/B;AACAM,MAAAA,MAAM,CAACJ,cAAP,CAAsB,SAAtB,EAAiCC,SAAjC;AACAe,MAAAA,EAAE,CAAC,IAAD,EAAOZ,MAAP,CAAF;AACD,KAJD;;AAMAA,IAAAA,MAAM,CAACO,EAAP,CAAU,OAAV,EAAmBb,OAAnB;AACAM,IAAAA,MAAM,CAACO,EAAP,CAAU,SAAV,EAAqBV,SAArB;AACD;;AAEDkB,EAAAA,kBAAkB,CAACH,EAAD,EAAK;AACrB/C,IAAAA,IAAI,CAACmB,OAAL,CAAaiC,MAAb,CAAoBnD,QAAQ,CAACoD,OAAT,CAAiB,KAAK/B,OAAL,CAAakB,IAA9B,CAApB,EAAyD;AACvDc,MAAAA,GAAG,EAAE;AADkD,KAAzD,EAEG,CAACH,GAAD,EAAM9B,SAAN,KAAoB;AACrB,UAAI8B,GAAJ,EAAS;AACP,eAAOJ,EAAE,CAACI,GAAD,CAAT;AACD;;AAED,UAAI,KAAKN,mBAAT,EAA8B;AAC5B,YAAIjD,0BAAJ,CAA+ByB,SAA/B,EAA0C,KAAKC,OAA/C,EAAwDC,OAAxD,CAAgEwB,EAAhE;AACD,OAFD,MAEO;AACL,YAAIpD,4BAAJ,CAAiC0B,SAAjC,EAA4C,KAAKC,OAAjD,EAA0DC,OAA1D,CAAkEwB,EAAlE;AACD;AACF,KAZD;AAaD;;AAhDa;;AAoDhBvD,OAAO,CAACE,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connector = exports.SequentialConnectionStrategy = exports.ParallelConnectionStrategy = void 0;\n\nvar _net = _interopRequireDefault(require(\"net\"));\n\nvar _dns = _interopRequireDefault(require(\"dns\"));\n\nvar punycode = _interopRequireWildcard(require(\"punycode\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass ParallelConnectionStrategy {\n  constructor(addresses, options) {\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  connect(callback) {\n    const addresses = this.addresses;\n    const sockets = new Array(addresses.length);\n    let errorCount = 0;\n\n    function onError(_err) {\n      errorCount += 1;\n      this.removeListener('error', onError);\n      this.removeListener('connect', onConnect);\n\n      if (errorCount === addresses.length) {\n        callback(new Error('Could not connect (parallel)'));\n      }\n    }\n\n    function onConnect() {\n      for (let j = 0; j < sockets.length; j++) {\n        const socket = sockets[j];\n\n        if (this === socket) {\n          continue;\n        }\n\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n      }\n\n      callback(null, this);\n    }\n\n    for (let i = 0, len = addresses.length; i < len; i++) {\n      const socket = sockets[i] = _net.default.connect(Object.create(this.options, {\n        host: {\n          value: addresses[i].address\n        }\n      }));\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n  }\n\n}\n\nexports.ParallelConnectionStrategy = ParallelConnectionStrategy;\n\nclass SequentialConnectionStrategy {\n  constructor(addresses, options) {\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  connect(callback) {\n    const next = this.addresses.shift();\n\n    if (!next) {\n      return callback(new Error('Could not connect (sequence)'));\n    }\n\n    const socket = _net.default.connect(Object.create(this.options, {\n      host: {\n        value: next.address\n      }\n    }));\n\n    const onError = _err => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      this.connect(callback);\n    };\n\n    const onConnect = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      callback(null, socket);\n    };\n\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n}\n\nexports.SequentialConnectionStrategy = SequentialConnectionStrategy;\n\nclass Connector {\n  constructor(options, multiSubnetFailover) {\n    this.options = options;\n    this.multiSubnetFailover = multiSubnetFailover;\n  }\n\n  execute(cb) {\n    if (_net.default.isIP(this.options.host)) {\n      this.executeForIP(cb);\n    } else {\n      this.executeForHostname(cb);\n    }\n  }\n\n  executeForIP(cb) {\n    const socket = _net.default.connect(this.options);\n\n    const onError = err => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      socket.destroy();\n      cb(err);\n    };\n\n    const onConnect = () => {\n      socket.removeListener('error', onError);\n      socket.removeListener('connect', onConnect);\n      cb(null, socket);\n    };\n\n    socket.on('error', onError);\n    socket.on('connect', onConnect);\n  }\n\n  executeForHostname(cb) {\n    _dns.default.lookup(punycode.toASCII(this.options.host), {\n      all: true\n    }, (err, addresses) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (this.multiSubnetFailover) {\n        new ParallelConnectionStrategy(addresses, this.options).connect(cb);\n      } else {\n        new SequentialConnectionStrategy(addresses, this.options).connect(cb);\n      }\n    });\n  }\n\n}\n\nexports.Connector = Connector;"]},"metadata":{},"sourceType":"script"}