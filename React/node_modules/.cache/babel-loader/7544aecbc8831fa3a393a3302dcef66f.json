{"ast":null,"code":"'use strict';\n\nconst CursorType = require('../constants/cursor');\n\nconst CommandCodes = require('../constants/commands');\n\nconst Types = require('../constants/types');\n\nconst Packet = require('../packets/packet');\n\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nfunction isJSON(value) {\n  return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === 'function' && !Buffer.isBuffer(value);\n}\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\n\n\nfunction toParameter(value, encoding, timezone) {\n  let type = Types.VAR_STRING;\n  let length;\n\n  let writer = function (value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n\n          writer = function (value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n\n        break;\n\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n\n  return {\n    value,\n    type,\n    length,\n    writer\n  };\n}\n\nclass Execute {\n  constructor(id, parameters, charsetNumber, timezone) {\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n\n  toPacket() {\n    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n    // and copy + reallocate if not enough\n    // 0 + 4 - length, seqId\n    // 4 + 1 - COM_EXECUTE\n    // 5 + 4 - stmtId\n    // 9 + 1 - flags\n    // 10 + 4 - iteration-count (always 1)\n    let length = 14;\n    let parameters;\n\n    if (this.parameters && this.parameters.length > 0) {\n      length += Math.floor((this.parameters.length + 7) / 8);\n      length += 1; // new-params-bound-flag\n\n      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n\n      parameters = this.parameters.map(value => toParameter(value, this.encoding, this.timezone));\n      length += parameters.reduce((accumulator, parameter) => accumulator + parameter.length, 0);\n    }\n\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(CommandCodes.STMT_EXECUTE);\n    packet.writeInt32(this.id);\n    packet.writeInt8(CursorType.NO_CURSOR); // flags\n\n    packet.writeInt32(1); // iteration-count, always 1\n\n    if (parameters) {\n      let bitmap = 0;\n      let bitValue = 1;\n      parameters.forEach(parameter => {\n        if (parameter.type === Types.NULL) {\n          bitmap += bitValue;\n        }\n\n        bitValue *= 2;\n\n        if (bitValue === 256) {\n          packet.writeInt8(bitmap);\n          bitmap = 0;\n          bitValue = 1;\n        }\n      });\n\n      if (bitValue !== 1) {\n        packet.writeInt8(bitmap);\n      } // TODO: explain meaning of the flag\n      // afaik, if set n*2 bytes with type of parameter are sent before parameters\n      // if not, previous execution types are used (TODO prooflink)\n\n\n      packet.writeInt8(1); // new-params-bound-flag\n      // Write parameter types\n\n      parameters.forEach(parameter => {\n        packet.writeInt8(parameter.type); // field type\n\n        packet.writeInt8(0); // parameter flag\n      }); // Write parameter values\n\n      parameters.forEach(parameter => {\n        if (parameter.type !== Types.NULL) {\n          parameter.writer.call(packet, parameter.value);\n        }\n      });\n    }\n\n    return packet;\n  }\n\n}\n\nmodule.exports = Execute;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/mysql2/lib/packets/execute.js"],"names":["CursorType","require","CommandCodes","Types","Packet","CharsetToEncoding","isJSON","value","Array","isArray","constructor","Object","toJSON","Buffer","isBuffer","toParameter","encoding","timezone","type","VAR_STRING","length","writer","prototype","writeLengthCodedString","call","TypeError","DOUBLE","writeDouble","TINY","writeInt8","toString","DATETIME","writeDate","JSON","stringify","lengthCodedNumberLength","writeLengthCodedBuffer","NULL","lengthCodedStringLength","Execute","id","parameters","charsetNumber","toPacket","Math","floor","map","reduce","accumulator","parameter","buffer","allocUnsafe","packet","offset","STMT_EXECUTE","writeInt32","NO_CURSOR","bitmap","bitValue","forEach","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst CursorType = require('../constants/cursor');\nconst CommandCodes = require('../constants/commands');\nconst Types = require('../constants/types');\nconst Packet = require('../packets/packet');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nfunction isJSON(value) {\n  return (\n    Array.isArray(value) ||\n    value.constructor === Object ||\n    (typeof value.toJSON === 'function' && !Buffer.isBuffer(value))\n  );\n}\n\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\nfunction toParameter(value, encoding, timezone) {\n  let type = Types.VAR_STRING;\n  let length;\n  let writer = function(value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n          writer = function(value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n        break;\n\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n  return { value, type, length, writer };\n}\n\nclass Execute {\n  constructor(id, parameters, charsetNumber, timezone) {\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n\n  toPacket() {\n    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n    // and copy + reallocate if not enough\n    // 0 + 4 - length, seqId\n    // 4 + 1 - COM_EXECUTE\n    // 5 + 4 - stmtId\n    // 9 + 1 - flags\n    // 10 + 4 - iteration-count (always 1)\n    let length = 14;\n    let parameters;\n    if (this.parameters && this.parameters.length > 0) {\n      length += Math.floor((this.parameters.length + 7) / 8);\n      length += 1; // new-params-bound-flag\n      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n      parameters = this.parameters.map(value =>\n        toParameter(value, this.encoding, this.timezone)\n      );\n      length += parameters.reduce(\n        (accumulator, parameter) => accumulator + parameter.length,\n        0\n      );\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(CommandCodes.STMT_EXECUTE);\n    packet.writeInt32(this.id);\n    packet.writeInt8(CursorType.NO_CURSOR); // flags\n    packet.writeInt32(1); // iteration-count, always 1\n    if (parameters) {\n      let bitmap = 0;\n      let bitValue = 1;\n      parameters.forEach(parameter => {\n        if (parameter.type === Types.NULL) {\n          bitmap += bitValue;\n        }\n        bitValue *= 2;\n        if (bitValue === 256) {\n          packet.writeInt8(bitmap);\n          bitmap = 0;\n          bitValue = 1;\n        }\n      });\n      if (bitValue !== 1) {\n        packet.writeInt8(bitmap);\n      }\n      // TODO: explain meaning of the flag\n      // afaik, if set n*2 bytes with type of parameter are sent before parameters\n      // if not, previous execution types are used (TODO prooflink)\n      packet.writeInt8(1); // new-params-bound-flag\n      // Write parameter types\n      parameters.forEach(parameter => {\n        packet.writeInt8(parameter.type); // field type\n        packet.writeInt8(0); // parameter flag\n      });\n      // Write parameter values\n      parameters.forEach(parameter => {\n        if (parameter.type !== Types.NULL) {\n          parameter.writer.call(packet, parameter.value);\n        }\n      });\n    }\n    return packet;\n  }\n}\n\nmodule.exports = Execute;\n"]},"metadata":{},"sourceType":"script"}