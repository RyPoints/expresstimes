{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstanceLookup = void 0;\n\nvar _sender = require(\"./sender\");\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3; // There are three bytes at the start of the response, whose purpose is unknown.\n\nconst MYSTERY_HEADER_LENGTH = 3; // Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\n\nclass InstanceLookup {\n  // Wrapper allows for stubbing Sender when unit testing instance-lookup.\n  createSender(host, port, request) {\n    return new _sender.Sender(host, port, request);\n  }\n\n  instanceLookup(options, callback) {\n    const server = options.server;\n\n    if (typeof server !== 'string') {\n      throw new TypeError('Invalid arguments: \"server\" must be a string');\n    }\n\n    const instanceName = options.instanceName;\n\n    if (typeof instanceName !== 'string') {\n      throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n    }\n\n    const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n\n    if (typeof timeout !== 'number') {\n      throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n    }\n\n    const retries = options.retries === undefined ? RETRIES : options.retries;\n\n    if (typeof retries !== 'number') {\n      throw new TypeError('Invalid arguments: \"retries\" must be a number');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Invalid arguments: \"callback\" must be a function');\n    }\n\n    let sender;\n    let timer;\n    let retriesLeft = retries;\n\n    const onTimeout = () => {\n      sender.cancel();\n      makeAttempt();\n    };\n\n    const makeAttempt = () => {\n      if (retriesLeft > 0) {\n        retriesLeft--;\n        const request = Buffer.from([0x02]);\n        sender = this.createSender(options.server, SQL_SERVER_BROWSER_PORT, request);\n        sender.execute((err, response) => {\n          clearTimeout(timer);\n\n          if (err) {\n            callback('Failed to lookup instance on ' + server + ' - ' + err.message);\n          } else {\n            const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n            const port = this.parseBrowserResponse(message, instanceName);\n\n            if (port) {\n              callback(undefined, port);\n            } else {\n              callback('Port for ' + instanceName + ' not found in ' + options.server);\n            }\n          }\n        });\n        timer = setTimeout(onTimeout, timeout);\n      } else {\n        callback('Failed to get response from SQL Server Browser on ' + server);\n      }\n    };\n\n    makeAttempt();\n  }\n\n  parseBrowserResponse(response, instanceName) {\n    let getPort;\n    const instances = response.split(';;');\n\n    for (let i = 0, len = instances.length; i < len; i++) {\n      const instance = instances[i];\n      const parts = instance.split(';');\n\n      for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n        const name = parts[p];\n        const value = parts[p + 1];\n\n        if (name === 'tcp' && getPort) {\n          const port = parseInt(value, 10);\n          return port;\n        }\n\n        if (name === 'InstanceName') {\n          if (value.toUpperCase() === instanceName.toUpperCase()) {\n            getPort = true;\n          } else {\n            getPort = false;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexports.InstanceLookup = InstanceLookup;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/tedious/lib/instance-lookup.js"],"names":["Object","defineProperty","exports","value","InstanceLookup","_sender","require","SQL_SERVER_BROWSER_PORT","TIMEOUT","RETRIES","MYSTERY_HEADER_LENGTH","createSender","host","port","request","Sender","instanceLookup","options","callback","server","TypeError","instanceName","timeout","undefined","retries","sender","timer","retriesLeft","onTimeout","cancel","makeAttempt","Buffer","from","execute","err","response","clearTimeout","message","toString","parseBrowserResponse","setTimeout","getPort","instances","split","i","len","length","instance","parts","p","partsLen","name","parseInt","toUpperCase"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstanceLookup = void 0;\n\nvar _sender = require(\"./sender\");\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3; // There are three bytes at the start of the response, whose purpose is unknown.\n\nconst MYSTERY_HEADER_LENGTH = 3; // Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\n\nclass InstanceLookup {\n  // Wrapper allows for stubbing Sender when unit testing instance-lookup.\n  createSender(host, port, request) {\n    return new _sender.Sender(host, port, request);\n  }\n\n  instanceLookup(options, callback) {\n    const server = options.server;\n\n    if (typeof server !== 'string') {\n      throw new TypeError('Invalid arguments: \"server\" must be a string');\n    }\n\n    const instanceName = options.instanceName;\n\n    if (typeof instanceName !== 'string') {\n      throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n    }\n\n    const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n\n    if (typeof timeout !== 'number') {\n      throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n    }\n\n    const retries = options.retries === undefined ? RETRIES : options.retries;\n\n    if (typeof retries !== 'number') {\n      throw new TypeError('Invalid arguments: \"retries\" must be a number');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Invalid arguments: \"callback\" must be a function');\n    }\n\n    let sender;\n    let timer;\n    let retriesLeft = retries;\n\n    const onTimeout = () => {\n      sender.cancel();\n      makeAttempt();\n    };\n\n    const makeAttempt = () => {\n      if (retriesLeft > 0) {\n        retriesLeft--;\n        const request = Buffer.from([0x02]);\n        sender = this.createSender(options.server, SQL_SERVER_BROWSER_PORT, request);\n        sender.execute((err, response) => {\n          clearTimeout(timer);\n\n          if (err) {\n            callback('Failed to lookup instance on ' + server + ' - ' + err.message);\n          } else {\n            const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n            const port = this.parseBrowserResponse(message, instanceName);\n\n            if (port) {\n              callback(undefined, port);\n            } else {\n              callback('Port for ' + instanceName + ' not found in ' + options.server);\n            }\n          }\n        });\n        timer = setTimeout(onTimeout, timeout);\n      } else {\n        callback('Failed to get response from SQL Server Browser on ' + server);\n      }\n    };\n\n    makeAttempt();\n  }\n\n  parseBrowserResponse(response, instanceName) {\n    let getPort;\n    const instances = response.split(';;');\n\n    for (let i = 0, len = instances.length; i < len; i++) {\n      const instance = instances[i];\n      const parts = instance.split(';');\n\n      for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n        const name = parts[p];\n        const value = parts[p + 1];\n\n        if (name === 'tcp' && getPort) {\n          const port = parseInt(value, 10);\n          return port;\n        }\n\n        if (name === 'InstanceName') {\n          if (value.toUpperCase() === instanceName.toUpperCase()) {\n            getPort = true;\n          } else {\n            getPort = false;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexports.InstanceLookup = InstanceLookup;"]},"metadata":{},"sourceType":"script"}