{"ast":null,"code":"(function (root, factory) {\n  // Node.\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    exports = module.exports = factory();\n  } // Browser Global.\n\n\n  if (typeof window === \"object\") {\n    root.Terraformer = factory();\n  }\n})(this, function () {\n  var exports = {},\n      EarthRadius = 6378137,\n      DegreesPerRadian = 57.295779513082320,\n      RadiansPerDegree = 0.017453292519943,\n      MercatorCRS = {\n    \"type\": \"link\",\n    \"properties\": {\n      \"href\": \"http://spatialreference.org/ref/sr-org/6928/ogcwkt/\",\n      \"type\": \"ogcwkt\"\n    }\n  },\n      GeographicCRS = {\n    \"type\": \"link\",\n    \"properties\": {\n      \"href\": \"http://spatialreference.org/ref/epsg/4326/ogcwkt/\",\n      \"type\": \"ogcwkt\"\n    }\n  };\n  /*\n  Internal: isArray function\n  */\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  }\n  /*\n  Internal: safe warning\n  */\n\n\n  function warn() {\n    var args = Array.prototype.slice.apply(arguments);\n\n    if (typeof console !== undefined && console.warn) {\n      console.warn.apply(console, args);\n    }\n  }\n  /*\n  Internal: Extend one object with another.\n  */\n\n\n  function extend(destination, source) {\n    for (var k in source) {\n      if (source.hasOwnProperty(k)) {\n        destination[k] = source[k];\n      }\n    }\n\n    return destination;\n  }\n  /*\n  Public: Calculate an bounding box for a geojson object\n  */\n\n\n  function calculateBounds(geojson) {\n    if (geojson.type) {\n      switch (geojson.type) {\n        case 'Point':\n          return [geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n        case 'MultiPoint':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'LineString':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'MultiLineString':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'Polygon':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'MultiPolygon':\n          return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n        case 'Feature':\n          return geojson.geometry ? calculateBounds(geojson.geometry) : null;\n\n        case 'FeatureCollection':\n          return calculateBoundsForFeatureCollection(geojson);\n\n        case 'GeometryCollection':\n          return calculateBoundsForGeometryCollection(geojson);\n\n        default:\n          throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n\n    return null;\n  }\n  /*\n  Internal: Calculate an bounding box from an nested array of positions\n  [\n    [\n      [ [lng, lat],[lng, lat],[lng, lat] ]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n  ]\n  */\n\n\n  function calculateBoundsFromNestedArrays(array) {\n    var x1 = null,\n        x2 = null,\n        y1 = null,\n        y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var lonlat = inner[j];\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n  /*\n  Internal: Calculate a bounding box from an array of arrays of arrays\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  */\n\n\n  function calculateBoundsFromNestedArrayOfArrays(array) {\n    var x1 = null,\n        x2 = null,\n        y1 = null,\n        y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var innerinner = inner[j];\n\n        for (var k = 0; k < innerinner.length; k++) {\n          var lonlat = innerinner[k];\n          var lon = lonlat[0];\n          var lat = lonlat[1];\n\n          if (x1 === null) {\n            x1 = lon;\n          } else if (lon < x1) {\n            x1 = lon;\n          }\n\n          if (x2 === null) {\n            x2 = lon;\n          } else if (lon > x2) {\n            x2 = lon;\n          }\n\n          if (y1 === null) {\n            y1 = lat;\n          } else if (lat < y1) {\n            y1 = lat;\n          }\n\n          if (y2 === null) {\n            y2 = lat;\n          } else if (lat > y2) {\n            y2 = lat;\n          }\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n  /*\n  Internal: Calculate a bounding box from an array of positions\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  */\n\n\n  function calculateBoundsFromArray(array) {\n    var x1 = null,\n        x2 = null,\n        y1 = null,\n        y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var lonlat = array[i];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n  /*\n  Internal: Calculate an bounding box for a feature collection\n  */\n\n\n  function calculateBoundsForFeatureCollection(featureCollection) {\n    var extents = [],\n        extent;\n\n    for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n      extent = calculateBounds(featureCollection.features[i].geometry);\n      extents.push([extent[0], extent[1]]);\n      extents.push([extent[2], extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n  /*\n  Internal: Calculate an bounding box for a geometry collection\n  */\n\n\n  function calculateBoundsForGeometryCollection(geometryCollection) {\n    var extents = [],\n        extent;\n\n    for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n      extent = calculateBounds(geometryCollection.geometries[i]);\n      extents.push([extent[0], extent[1]]);\n      extents.push([extent[2], extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  function calculateEnvelope(geojson) {\n    var bounds = calculateBounds(geojson);\n    return {\n      x: bounds[0],\n      y: bounds[1],\n      w: Math.abs(bounds[0] - bounds[2]),\n      h: Math.abs(bounds[1] - bounds[3])\n    };\n  }\n  /*\n  Internal: Convert radians to degrees. Used by spatial reference converters.\n  */\n\n\n  function radToDeg(rad) {\n    return rad * DegreesPerRadian;\n  }\n  /*\n  Internal: Convert degrees to radians. Used by spatial reference converters.\n  */\n\n\n  function degToRad(deg) {\n    return deg * RadiansPerDegree;\n  }\n  /*\n  Internal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n  */\n\n\n  function eachPosition(coordinates, func) {\n    for (var i = 0; i < coordinates.length; i++) {\n      // we found a number so lets convert this pair\n      if (typeof coordinates[i][0] === \"number\") {\n        coordinates[i] = func(coordinates[i]);\n      } // we found an coordinates array it again and run THIS function against it\n\n\n      if (typeof coordinates[i] === \"object\") {\n        coordinates[i] = eachPosition(coordinates[i], func);\n      }\n    }\n\n    return coordinates;\n  }\n  /*\n  Public: Convert a GeoJSON Position object to Geographic (4326)\n  */\n\n\n  function positionToGeographic(position) {\n    var x = position[0];\n    var y = position[1];\n    return [radToDeg(x / EarthRadius) - Math.floor((radToDeg(x / EarthRadius) + 180) / 360) * 360, radToDeg(Math.PI / 2 - 2 * Math.atan(Math.exp(-1.0 * y / EarthRadius)))];\n  }\n  /*\n  Public: Convert a GeoJSON Position object to Web Mercator (102100)\n  */\n\n\n  function positionToMercator(position) {\n    var lng = position[0];\n    var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n    return [degToRad(lng) * EarthRadius, EarthRadius / 2.0 * Math.log((1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))))];\n  }\n  /*\n  Public: Apply a function agaist all positions in a geojson object. Used by spatial reference converters.\n  */\n\n\n  function applyConverter(geojson, converter, noCrs) {\n    if (geojson.type === \"Point\") {\n      geojson.coordinates = converter(geojson.coordinates);\n    } else if (geojson.type === \"Feature\") {\n      geojson.geometry = applyConverter(geojson.geometry, converter, true);\n    } else if (geojson.type === \"FeatureCollection\") {\n      for (var f = 0; f < geojson.features.length; f++) {\n        geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n      }\n    } else if (geojson.type === \"GeometryCollection\") {\n      for (var g = 0; g < geojson.geometries.length; g++) {\n        geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n      }\n    } else {\n      geojson.coordinates = eachPosition(geojson.coordinates, converter);\n    }\n\n    if (!noCrs) {\n      if (converter === positionToMercator) {\n        geojson.crs = MercatorCRS;\n      }\n    }\n\n    if (converter === positionToGeographic) {\n      delete geojson.crs;\n    }\n\n    return geojson;\n  }\n  /*\n  Public: Convert a GeoJSON object to ESRI Web Mercator (102100)\n  */\n\n\n  function toMercator(geojson) {\n    return applyConverter(geojson, positionToMercator);\n  }\n  /*\n  Convert a GeoJSON object to Geographic coordinates (WSG84, 4326)\n  */\n\n\n  function toGeographic(geojson) {\n    return applyConverter(geojson, positionToGeographic);\n  }\n  /*\n  Internal: -1,0,1 comparison function\n  */\n\n\n  function cmp(a, b) {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /*\n  Internal: used for sorting\n  */\n\n\n  function compSort(p1, p2) {\n    if (p1[0] > p2[0]) {\n      return -1;\n    } else if (p1[0] < p2[0]) {\n      return 1;\n    } else if (p1[1] > p2[1]) {\n      return -1;\n    } else if (p1[1] < p2[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /*\n  Internal: used to determine turn\n  */\n\n\n  function turn(p, q, r) {\n    // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n    return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n  }\n  /*\n  Internal: used to determine euclidean distance between two points\n  */\n\n\n  function euclideanDistance(p, q) {\n    // Returns the squared Euclidean distance between p and q.\n    var dx = q[0] - p[0];\n    var dy = q[1] - p[1];\n    return dx * dx + dy * dy;\n  }\n\n  function nextHullPoint(points, p) {\n    // Returns the next point on the convex hull in CCW from p.\n    var q = p;\n\n    for (var r in points) {\n      var t = turn(p, q, points[r]);\n\n      if (t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n        q = points[r];\n      }\n    }\n\n    return q;\n  }\n\n  function convexHull(points) {\n    // implementation of the Jarvis March algorithm\n    // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n    if (points.length === 0) {\n      return [];\n    } else if (points.length === 1) {\n      return points;\n    } // Returns the points on the convex hull of points in CCW order.\n\n\n    var hull = [points.sort(compSort)[0]];\n\n    for (var p = 0; p < hull.length; p++) {\n      var q = nextHullPoint(points, hull[p]);\n\n      if (q !== hull[0]) {\n        hull.push(q);\n      }\n    }\n\n    return hull;\n  }\n\n  function isConvex(points) {\n    var ltz;\n\n    for (var i = 0; i < points.length - 3; i++) {\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n      var v = [p2[0] - p1[0], p2[1] - p1[1]]; // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n\n      var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n      if (i === 0) {\n        if (res < 0) {\n          ltz = true;\n        } else {\n          ltz = false;\n        }\n      } else {\n        if (ltz && res > 0 || !ltz && res < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesContainPoint(coordinates, point) {\n    var contains = false;\n\n    for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n      if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n        contains = !contains;\n      }\n    }\n\n    return contains;\n  }\n\n  function polygonContainsPoint(polygon, point) {\n    if (polygon && polygon.length) {\n      if (polygon.length === 1) {\n        // polygon with no holes\n        return coordinatesContainPoint(polygon[0], point);\n      } else {\n        // polygon with holes\n        if (coordinatesContainPoint(polygon[0], point)) {\n          for (var i = 1; i < polygon.length; i++) {\n            if (coordinatesContainPoint(polygon[i], point)) {\n              return false; // found in hole\n            }\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function edgeIntersectsEdge(a1, a2, b1, b2) {\n    var ua_t = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n    var ub_t = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n    var u_b = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n\n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function arraysIntersectArrays(a, b) {\n    if (isNumber(a[0][0])) {\n      if (isNumber(b[0][0])) {\n        for (var i = 0; i < a.length - 1; i++) {\n          for (var j = 0; j < b.length - 1; j++) {\n            if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n              return true;\n            }\n          }\n        }\n      } else {\n        for (var k = 0; k < b.length; k++) {\n          if (arraysIntersectArrays(a, b[k])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var l = 0; l < a.length; l++) {\n        if (arraysIntersectArrays(a[l], b)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /*\n  Internal: Returns a copy of coordinates for s closed polygon\n  */\n\n\n  function closedPolygon(coordinates) {\n    var outer = [];\n\n    for (var i = 0; i < coordinates.length; i++) {\n      var inner = coordinates[i].slice();\n\n      if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n        inner.push(inner[0]);\n      }\n\n      outer.push(inner);\n    }\n\n    return outer;\n  }\n\n  function pointsEqual(a, b) {\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    var na = a.slice().sort(compSort);\n    var nb = b.slice().sort(compSort);\n\n    for (var i = 0; i < na.length; i++) {\n      if (na[i].length !== nb[i].length) {\n        return false;\n      }\n\n      for (var j = 0; j < na.length; j++) {\n        if (na[i][j] !== nb[i][j]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /*\n  Internal: An array of variables that will be excluded form JSON objects.\n  */\n\n\n  var excludeFromJSON = [\"length\"];\n  /*\n  Internal: Base GeoJSON Primitive\n  */\n\n  function Primitive(geojson) {\n    if (geojson) {\n      switch (geojson.type) {\n        case 'Point':\n          return new Point(geojson);\n\n        case 'MultiPoint':\n          return new MultiPoint(geojson);\n\n        case 'LineString':\n          return new LineString(geojson);\n\n        case 'MultiLineString':\n          return new MultiLineString(geojson);\n\n        case 'Polygon':\n          return new Polygon(geojson);\n\n        case 'MultiPolygon':\n          return new MultiPolygon(geojson);\n\n        case 'Feature':\n          return new Feature(geojson);\n\n        case 'FeatureCollection':\n          return new FeatureCollection(geojson);\n\n        case 'GeometryCollection':\n          return new GeometryCollection(geojson);\n\n        default:\n          throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n  }\n\n  Primitive.prototype.toMercator = function () {\n    return toMercator(this);\n  };\n\n  Primitive.prototype.toGeographic = function () {\n    return toGeographic(this);\n  };\n\n  Primitive.prototype.envelope = function () {\n    return calculateEnvelope(this);\n  };\n\n  Primitive.prototype.bbox = function () {\n    return calculateBounds(this);\n  };\n\n  Primitive.prototype.convexHull = function () {\n    var coordinates = [],\n        i,\n        j;\n\n    if (this.type === 'Point') {\n      return null;\n    } else if (this.type === 'LineString' || this.type === 'MultiPoint') {\n      if (this.coordinates && this.coordinates.length >= 3) {\n        coordinates = this.coordinates;\n      } else {\n        return null;\n      }\n    } else if (this.type === 'Polygon' || this.type === 'MultiLineString') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          coordinates = coordinates.concat(this.coordinates[i]);\n        }\n\n        if (coordinates.length < 3) {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if (this.type === 'MultiPolygon') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          for (j = 0; j < this.coordinates[i].length; j++) {\n            coordinates = coordinates.concat(this.coordinates[i][j]);\n          }\n        }\n\n        if (coordinates.length < 3) {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if (this.type === \"Feature\") {\n      var primitive = new Primitive(this.geometry);\n      return primitive.convexHull();\n    }\n\n    return new Polygon({\n      type: 'Polygon',\n      coordinates: closedPolygon([convexHull(coordinates)])\n    });\n  };\n\n  Primitive.prototype.toJSON = function () {\n    var obj = {};\n\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && excludeFromJSON.indexOf(key) === -1) {\n        obj[key] = this[key];\n      }\n    }\n\n    obj.bbox = calculateBounds(this);\n    return obj;\n  };\n\n  Primitive.prototype.contains = function (primitive) {\n    return new Primitive(primitive).within(this);\n  };\n\n  Primitive.prototype.within = function (primitive) {\n    var coordinates, i, contains; // if we are passed a feature, use the polygon inside instead\n\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    } // point.within(point) :: equality\n\n\n    if (primitive.type === \"Point\") {\n      if (this.type === \"Point\") {\n        return pointsEqual(this.coordinates, primitive.coordinates);\n      }\n    } // point.within(multilinestring)\n\n\n    if (primitive.type === \"MultiLineString\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var linestring = {\n            type: \"LineString\",\n            coordinates: primitive.coordinates[i]\n          };\n\n          if (this.within(linestring)) {\n            return true;\n          }\n        }\n      }\n    } // point.within(linestring), point.within(multipoint)\n\n\n    if (primitive.type === \"LineString\" || primitive.type === \"MultiPoint\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          if (this.coordinates.length !== primitive.coordinates[i].length) {\n            return false;\n          }\n\n          if (pointsEqual(this.coordinates, primitive.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (primitive.type === \"Polygon\") {\n      // polygon.within(polygon)\n      if (this.type === \"Polygon\") {\n        // check for equal polygons\n        if (primitive.coordinates.length === this.coordinates.length) {\n          for (i = 0; i < this.coordinates.length; i++) {\n            if (coordinatesEqual(this.coordinates[i], primitive.coordinates[i])) {\n              return true;\n            }\n          }\n        }\n\n        if (this.coordinates.length && polygonContainsPoint(primitive.coordinates, this.coordinates[0][0])) {\n          return !arraysIntersectArrays(closedPolygon(this.coordinates), closedPolygon(primitive.coordinates));\n        } else {\n          return false;\n        } // point.within(polygon)\n\n      } else if (this.type === \"Point\") {\n        return polygonContainsPoint(primitive.coordinates, this.coordinates); // linestring/multipoint withing polygon\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        if (!this.coordinates || this.coordinates.length === 0) {\n          return false;\n        }\n\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (polygonContainsPoint(primitive.coordinates, this.coordinates[i]) === false) {\n            return false;\n          }\n        }\n\n        return true; // multilinestring.within(polygon)\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var ls = new LineString(this.coordinates[i]);\n\n          if (ls.within(primitive) === false) {\n            contains++;\n            return false;\n          }\n        }\n\n        return true; // multipolygon.within(polygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var p1 = new Primitive({\n            type: \"Polygon\",\n            coordinates: this.coordinates[i]\n          });\n\n          if (p1.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    if (primitive.type === \"MultiPolygon\") {\n      // point.within(multipolygon)\n      if (this.type === \"Point\") {\n        if (primitive.coordinates.length) {\n          for (i = 0; i < primitive.coordinates.length; i++) {\n            coordinates = primitive.coordinates[i];\n\n            if (polygonContainsPoint(coordinates, this.coordinates) && arraysIntersectArrays([this.coordinates], primitive.coordinates) === false) {\n              return true;\n            }\n          }\n        }\n\n        return false; // polygon.within(multipolygon)\n      } else if (this.type === \"Polygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (primitive.coordinates[i].length === this.coordinates.length) {\n            for (j = 0; j < this.coordinates.length; j++) {\n              if (coordinatesEqual(this.coordinates[j], primitive.coordinates[i][j])) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (arraysIntersectArrays(this.coordinates, primitive.coordinates) === false) {\n          if (primitive.coordinates.length) {\n            for (i = 0; i < primitive.coordinates.length; i++) {\n              coordinates = primitive.coordinates[i];\n\n              if (polygonContainsPoint(coordinates, this.coordinates[0][0]) === false) {\n                contains = false;\n              } else {\n                contains = true;\n              }\n            }\n\n            return contains;\n          }\n        } // linestring.within(multipolygon), multipoint.within(multipolygon)\n\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var p = {\n            type: \"Polygon\",\n            coordinates: primitive.coordinates[i]\n          };\n\n          if (this.within(p)) {\n            return true;\n          }\n\n          return false;\n        } // multilinestring.within(multipolygon)\n\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var lines = new LineString(this.coordinates[i]);\n\n          if (lines.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true; // multipolygon.within(multipolygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var mpoly = {\n            type: \"Polygon\",\n            coordinates: primitive.coordinates[i]\n          };\n\n          if (this.within(mpoly) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    } // default to false\n\n\n    return false;\n  };\n\n  Primitive.prototype.intersects = function (primitive) {\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    }\n\n    var p = new Primitive(primitive);\n\n    if (this.within(primitive) || p.within(this)) {\n      return true;\n    }\n\n    if (this.type !== 'Point' && this.type !== 'MultiPoint' && primitive.type !== 'Point' && primitive.type !== 'MultiPoint') {\n      return arraysIntersectArrays(this.coordinates, primitive.coordinates);\n    } else if (this.type === 'Feature') {\n      // in the case of a Feature, use the internal primitive for intersection\n      var inner = new Primitive(this.geometry);\n      return inner.intersects(primitive);\n    }\n\n    warn(\"Type \" + this.type + \" to \" + primitive.type + \" intersection is not supported by intersects\");\n    return false;\n  };\n  /*\n  GeoJSON Point Class\n    new Point();\n    new Point(x,y,z,wtf);\n    new Point([x,y,z,wtf]);\n    new Point([x,y]);\n    new Point({\n      type: \"Point\",\n      coordinates: [x,y]\n    });\n  */\n\n\n  function Point(input) {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (input && input.type === \"Point\" && input.coordinates) {\n      extend(this, input);\n    } else if (input && isArray(input)) {\n      this.coordinates = input;\n    } else if (args.length >= 2) {\n      this.coordinates = args;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Point\";\n    }\n\n    this.type = \"Point\";\n  }\n\n  Point.prototype = new Primitive();\n  Point.prototype.constructor = Point;\n  /*\n  GeoJSON MultiPoint Class\n      new MultiPoint();\n      new MultiPoint([[x,y], [x1,y1]]);\n      new MultiPoint({\n        type: \"MultiPoint\",\n        coordinates: [x,y]\n      });\n  */\n\n  function MultiPoint(input) {\n    if (input && input.type === \"MultiPoint\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPoint\";\n    }\n\n    this.type = \"MultiPoint\";\n  }\n\n  MultiPoint.prototype = new Primitive();\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  MultiPoint.prototype.forEach = function (func) {\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n\n    return this;\n  };\n\n  MultiPoint.prototype.addPoint = function (point) {\n    this.coordinates.push(point);\n    return this;\n  };\n\n  MultiPoint.prototype.insertPoint = function (point, index) {\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n\n  MultiPoint.prototype.removePoint = function (remove) {\n    if (typeof remove === \"number\") {\n      this.coordinates.splice(remove, 1);\n    } else {\n      this.coordinates.splice(this.coordinates.indexOf(remove), 1);\n    }\n\n    return this;\n  };\n\n  MultiPoint.prototype.get = function (i) {\n    return new Point(this.coordinates[i]);\n  };\n  /*\n  GeoJSON LineString Class\n      new LineString();\n      new LineString([[x,y], [x1,y1]]);\n      new LineString({\n        type: \"LineString\",\n        coordinates: [x,y]\n      });\n  */\n\n\n  function LineString(input) {\n    if (input && input.type === \"LineString\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.LineString\";\n    }\n\n    this.type = \"LineString\";\n  }\n\n  LineString.prototype = new Primitive();\n  LineString.prototype.constructor = LineString;\n\n  LineString.prototype.addVertex = function (point) {\n    this.coordinates.push(point);\n    return this;\n  };\n\n  LineString.prototype.insertVertex = function (point, index) {\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n\n  LineString.prototype.removeVertex = function (remove) {\n    this.coordinates.splice(remove, 1);\n    return this;\n  };\n  /*\n  GeoJSON MultiLineString Class\n      new MultiLineString();\n      new MultiLineString([ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]);\n      new MultiLineString({\n        type: \"MultiLineString\",\n        coordinates: [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]\n      });\n  */\n\n\n  function MultiLineString(input) {\n    if (input && input.type === \"MultiLineString\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiLineString\";\n    }\n\n    this.type = \"MultiLineString\";\n  }\n\n  MultiLineString.prototype = new Primitive();\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  MultiLineString.prototype.forEach = function (func) {\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n  };\n\n  MultiLineString.prototype.get = function (i) {\n    return new LineString(this.coordinates[i]);\n  };\n  /*\n  GeoJSON Polygon Class\n      new Polygon();\n      new Polygon([ [[x,y], [x1,y1], [x2,y2]] ]);\n      new Polygon({\n        type: \"Polygon\",\n        coordinates: [ [[x,y], [x1,y1], [x2,y2]] ]\n      });\n  */\n\n\n  function Polygon(input) {\n    if (input && input.type === \"Polygon\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Polygon\";\n    }\n\n    this.type = \"Polygon\";\n  }\n\n  Polygon.prototype = new Primitive();\n  Polygon.prototype.constructor = Polygon;\n\n  Polygon.prototype.addVertex = function (point) {\n    this.insertVertex(point, this.coordinates[0].length - 1);\n    return this;\n  };\n\n  Polygon.prototype.insertVertex = function (point, index) {\n    this.coordinates[0].splice(index, 0, point);\n    return this;\n  };\n\n  Polygon.prototype.removeVertex = function (remove) {\n    this.coordinates[0].splice(remove, 1);\n    return this;\n  };\n\n  Polygon.prototype.close = function () {\n    this.coordinates = closedPolygon(this.coordinates);\n  };\n\n  Polygon.prototype.hasHoles = function () {\n    return this.coordinates.length > 1;\n  };\n\n  Polygon.prototype.holes = function () {\n    holes = [];\n\n    if (this.hasHoles()) {\n      for (var i = 1; i < this.coordinates.length; i++) {\n        holes.push(new Polygon([this.coordinates[i]]));\n      }\n    }\n\n    return holes;\n  };\n  /*\n  GeoJSON MultiPolygon Class\n      new MultiPolygon();\n      new MultiPolygon([ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]);\n      new MultiPolygon({\n        type: \"MultiPolygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n\n\n  function MultiPolygon(input) {\n    if (input && input.type === \"MultiPolygon\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPolygon\";\n    }\n\n    this.type = \"MultiPolygon\";\n  }\n\n  MultiPolygon.prototype = new Primitive();\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  MultiPolygon.prototype.forEach = function (func) {\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n  };\n\n  MultiPolygon.prototype.get = function (i) {\n    return new Polygon(this.coordinates[i]);\n  };\n\n  MultiPolygon.prototype.close = function () {\n    var outer = [];\n    this.forEach(function (polygon) {\n      outer.push(closedPolygon(polygon));\n    });\n    this.coordinates = outer;\n    return this;\n  };\n  /*\n  GeoJSON Feature Class\n      new Feature();\n      new Feature({\n        type: \"Feature\",\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n        }\n      });\n      new Feature({\n        type: \"Polygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n\n\n  function Feature(input) {\n    if (input && input.type === \"Feature\") {\n      extend(this, input);\n    } else if (input && input.type && input.coordinates) {\n      this.geometry = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Feature\";\n    }\n\n    this.type = \"Feature\";\n  }\n\n  Feature.prototype = new Primitive();\n  Feature.prototype.constructor = Feature;\n  /*\n  GeoJSON FeatureCollection Class\n      new FeatureCollection();\n      new FeatureCollection([feature, feature1]);\n      new FeatureCollection({\n        type: \"FeatureCollection\",\n        coordinates: [feature, feature1]\n      });\n  */\n\n  function FeatureCollection(input) {\n    if (input && input.type === \"FeatureCollection\" && input.features) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.features = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.FeatureCollection\";\n    }\n\n    this.type = \"FeatureCollection\";\n  }\n\n  FeatureCollection.prototype = new Primitive();\n  FeatureCollection.prototype.constructor = FeatureCollection;\n\n  FeatureCollection.prototype.forEach = function (func) {\n    for (var i = 0; i < this.features.length; i++) {\n      func.apply(this, [this.features[i], i, this.features]);\n    }\n  };\n\n  FeatureCollection.prototype.get = function (id) {\n    var found;\n    this.forEach(function (feature) {\n      if (feature.id === id) {\n        found = feature;\n      }\n    });\n    return new Feature(found);\n  };\n  /*\n  GeoJSON GeometryCollection Class\n      new GeometryCollection();\n      new GeometryCollection([geometry, geometry1]);\n      new GeometryCollection({\n        type: \"GeometryCollection\",\n        coordinates: [geometry, geometry1]\n      });\n  */\n\n\n  function GeometryCollection(input) {\n    if (input && input.type === \"GeometryCollection\" && input.geometries) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.geometries = input;\n    } else if (input.coordinates && input.type) {\n      this.type = \"GeometryCollection\";\n      this.geometries = [input];\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.GeometryCollection\";\n    }\n\n    this.type = \"GeometryCollection\";\n  }\n\n  GeometryCollection.prototype = new Primitive();\n  GeometryCollection.prototype.constructor = GeometryCollection;\n\n  GeometryCollection.prototype.forEach = function (func) {\n    for (var i = 0; i < this.geometries.length; i++) {\n      func.apply(this, [this.geometries[i], i, this.geometries]);\n    }\n  };\n\n  GeometryCollection.prototype.get = function (i) {\n    return new Primitive(this.geometries[i]);\n  };\n\n  function createCircle(center, radius, interpolate) {\n    var mercatorPosition = positionToMercator(center);\n    var steps = interpolate || 64;\n    var polygon = {\n      type: \"Polygon\",\n      coordinates: [[]]\n    };\n\n    for (var i = 1; i <= steps; i++) {\n      var radians = i * (360 / steps) * Math.PI / 180;\n      polygon.coordinates[0].push([mercatorPosition[0] + radius * Math.cos(radians), mercatorPosition[1] + radius * Math.sin(radians)]);\n    }\n\n    polygon.coordinates = closedPolygon(polygon.coordinates);\n    return toGeographic(polygon);\n  }\n\n  function Circle(center, radius, interpolate) {\n    var steps = interpolate || 64;\n    var rad = radius || 250;\n\n    if (!center || center.length < 2 || !rad || !steps) {\n      throw new Error(\"Terraformer: missing parameter for Terraformer.Circle\");\n    }\n\n    extend(this, new Feature({\n      type: \"Feature\",\n      geometry: createCircle(center, rad, steps),\n      properties: {\n        radius: rad,\n        center: center,\n        steps: steps\n      }\n    }));\n  }\n\n  Circle.prototype = new Primitive();\n  Circle.prototype.constructor = Circle;\n\n  Circle.prototype.recalculate = function () {\n    this.geometry = createCircle(this.properties.center, this.properties.radius, this.properties.steps);\n    return this;\n  };\n\n  Circle.prototype.center = function (coordinates) {\n    if (coordinates) {\n      this.properties.center = coordinates;\n      this.recalculate();\n    }\n\n    return this.properties.center;\n  };\n\n  Circle.prototype.radius = function (radius) {\n    if (radius) {\n      this.properties.radius = radius;\n      this.recalculate();\n    }\n\n    return this.properties.radius;\n  };\n\n  Circle.prototype.steps = function (steps) {\n    if (steps) {\n      this.properties.steps = steps;\n      this.recalculate();\n    }\n\n    return this.properties.steps;\n  };\n\n  Circle.prototype.toJSON = function () {\n    var output = Primitive.prototype.toJSON.call(this);\n    return output;\n  };\n\n  exports.Primitive = Primitive;\n  exports.Point = Point;\n  exports.MultiPoint = MultiPoint;\n  exports.LineString = LineString;\n  exports.MultiLineString = MultiLineString;\n  exports.Polygon = Polygon;\n  exports.MultiPolygon = MultiPolygon;\n  exports.Feature = Feature;\n  exports.FeatureCollection = FeatureCollection;\n  exports.GeometryCollection = GeometryCollection;\n  exports.Circle = Circle;\n  exports.toMercator = toMercator;\n  exports.toGeographic = toGeographic;\n  exports.Tools = {};\n  exports.Tools.positionToMercator = positionToMercator;\n  exports.Tools.positionToGeographic = positionToGeographic;\n  exports.Tools.applyConverter = applyConverter;\n  exports.Tools.toMercator = toMercator;\n  exports.Tools.toGeographic = toGeographic;\n  exports.Tools.createCircle = createCircle;\n  exports.Tools.calculateBounds = calculateBounds;\n  exports.Tools.calculateEnvelope = calculateEnvelope;\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.polygonContainsPoint = polygonContainsPoint;\n  exports.Tools.arraysIntersectArrays = arraysIntersectArrays;\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.coordinatesEqual = coordinatesEqual;\n  exports.Tools.convexHull = convexHull;\n  exports.Tools.isConvex = isConvex;\n  exports.MercatorCRS = MercatorCRS;\n  exports.GeographicCRS = GeographicCRS;\n  return exports;\n});","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/terraformer/terraformer.js"],"names":["root","factory","module","exports","window","Terraformer","EarthRadius","DegreesPerRadian","RadiansPerDegree","MercatorCRS","GeographicCRS","isArray","obj","Object","prototype","toString","call","warn","args","Array","slice","apply","arguments","console","undefined","extend","destination","source","k","hasOwnProperty","calculateBounds","geojson","type","coordinates","calculateBoundsFromArray","calculateBoundsFromNestedArrays","calculateBoundsFromNestedArrayOfArrays","geometry","calculateBoundsForFeatureCollection","calculateBoundsForGeometryCollection","Error","array","x1","x2","y1","y2","i","length","inner","j","lonlat","lon","lat","innerinner","featureCollection","extents","extent","features","push","geometryCollection","geometries","calculateEnvelope","bounds","x","y","w","Math","abs","h","radToDeg","rad","degToRad","deg","eachPosition","func","positionToGeographic","position","floor","PI","atan","exp","positionToMercator","lng","max","min","log","sin","applyConverter","converter","noCrs","f","g","crs","toMercator","toGeographic","cmp","a","b","compSort","p1","p2","turn","p","q","r","euclideanDistance","dx","dy","nextHullPoint","points","t","convexHull","hull","sort","isConvex","ltz","p3","v","res","coordinatesContainPoint","point","contains","l","polygonContainsPoint","polygon","edgeIntersectsEdge","a1","a2","b1","b2","ua_t","ub_t","u_b","ua","ub","isNumber","n","isNaN","parseFloat","isFinite","arraysIntersectArrays","closedPolygon","outer","pointsEqual","coordinatesEqual","na","nb","excludeFromJSON","Primitive","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","Feature","FeatureCollection","GeometryCollection","envelope","bbox","concat","primitive","toJSON","key","indexOf","within","linestring","ls","lines","mpoly","intersects","input","constructor","forEach","addPoint","insertPoint","index","splice","removePoint","remove","get","addVertex","insertVertex","removeVertex","close","hasHoles","holes","id","found","feature","createCircle","center","radius","interpolate","mercatorPosition","steps","radians","cos","Circle","properties","recalculate","output","Tools"],"mappings":"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","sourcesContent":["(function (root, factory) {\n\n  // Node.\n  if(typeof module === 'object' && typeof module.exports === 'object') {\n    exports = module.exports = factory();\n  }\n\n  // Browser Global.\n  if(typeof window === \"object\") {\n    root.Terraformer = factory();\n  }\n\n}(this, function(){\n  var exports = {},\n      EarthRadius = 6378137,\n      DegreesPerRadian = 57.295779513082320,\n      RadiansPerDegree =  0.017453292519943,\n      MercatorCRS = {\n        \"type\": \"link\",\n        \"properties\": {\n          \"href\": \"http://spatialreference.org/ref/sr-org/6928/ogcwkt/\",\n          \"type\": \"ogcwkt\"\n        }\n      },\n      GeographicCRS = {\n        \"type\": \"link\",\n        \"properties\": {\n          \"href\": \"http://spatialreference.org/ref/epsg/4326/ogcwkt/\",\n          \"type\": \"ogcwkt\"\n        }\n      };\n\n  /*\n  Internal: isArray function\n  */\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  }\n\n  /*\n  Internal: safe warning\n  */\n  function warn() {\n    var args = Array.prototype.slice.apply(arguments);\n\n    if (typeof console !== undefined && console.warn) {\n      console.warn.apply(console, args);\n    }\n  }\n\n  /*\n  Internal: Extend one object with another.\n  */\n  function extend(destination, source) {\n    for (var k in source) {\n      if (source.hasOwnProperty(k)) {\n        destination[k] = source[k];\n      }\n    }\n    return destination;\n  }\n\n  /*\n  Public: Calculate an bounding box for a geojson object\n  */\n  function calculateBounds (geojson) {\n    if(geojson.type){\n      switch (geojson.type) {\n        case 'Point':\n          return [ geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n        case 'MultiPoint':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'LineString':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'MultiLineString':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'Polygon':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'MultiPolygon':\n          return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n        case 'Feature':\n          return geojson.geometry? calculateBounds(geojson.geometry) : null;\n\n        case 'FeatureCollection':\n          return calculateBoundsForFeatureCollection(geojson);\n\n        case 'GeometryCollection':\n          return calculateBoundsForGeometryCollection(geojson);\n\n        default:\n          throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n    return null;\n  }\n\n  /*\n  Internal: Calculate an bounding box from an nested array of positions\n  [\n    [\n      [ [lng, lat],[lng, lat],[lng, lat] ]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n  ]\n  */\n  function calculateBoundsFromNestedArrays (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var lonlat = inner[j];\n\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2 ];\n  }\n\n  /*\n  Internal: Calculate a bounding box from an array of arrays of arrays\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  */\n  function calculateBoundsFromNestedArrayOfArrays (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var innerinner = inner[j];\n        for (var k = 0; k < innerinner.length; k++) {\n          var lonlat = innerinner[k];\n\n          var lon = lonlat[0];\n          var lat = lonlat[1];\n\n          if (x1 === null) {\n            x1 = lon;\n          } else if (lon < x1) {\n            x1 = lon;\n          }\n\n          if (x2 === null) {\n            x2 = lon;\n          } else if (lon > x2) {\n            x2 = lon;\n          }\n\n          if (y1 === null) {\n            y1 = lat;\n          } else if (lat < y1) {\n            y1 = lat;\n          }\n\n          if (y2 === null) {\n            y2 = lat;\n          } else if (lat > y2) {\n            y2 = lat;\n          }\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n\n  /*\n  Internal: Calculate a bounding box from an array of positions\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  */\n  function calculateBoundsFromArray (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var lonlat = array[i];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n\n    return [x1, y1, x2, y2 ];\n  }\n\n  /*\n  Internal: Calculate an bounding box for a feature collection\n  */\n  function calculateBoundsForFeatureCollection(featureCollection){\n    var extents = [], extent;\n    for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n      extent = calculateBounds(featureCollection.features[i].geometry);\n      extents.push([extent[0],extent[1]]);\n      extents.push([extent[2],extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  /*\n  Internal: Calculate an bounding box for a geometry collection\n  */\n  function calculateBoundsForGeometryCollection(geometryCollection){\n    var extents = [], extent;\n\n    for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n      extent = calculateBounds(geometryCollection.geometries[i]);\n      extents.push([extent[0],extent[1]]);\n      extents.push([extent[2],extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  function calculateEnvelope(geojson){\n    var bounds = calculateBounds(geojson);\n    return {\n      x: bounds[0],\n      y: bounds[1],\n      w: Math.abs(bounds[0] - bounds[2]),\n      h: Math.abs(bounds[1] - bounds[3])\n    };\n  }\n\n  /*\n  Internal: Convert radians to degrees. Used by spatial reference converters.\n  */\n  function radToDeg(rad) {\n    return rad * DegreesPerRadian;\n  }\n\n  /*\n  Internal: Convert degrees to radians. Used by spatial reference converters.\n  */\n  function degToRad(deg) {\n    return deg * RadiansPerDegree;\n  }\n\n  /*\n  Internal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n  */\n  function eachPosition(coordinates, func) {\n    for (var i = 0; i < coordinates.length; i++) {\n      // we found a number so lets convert this pair\n      if(typeof coordinates[i][0] === \"number\"){\n        coordinates[i] = func(coordinates[i]);\n      }\n      // we found an coordinates array it again and run THIS function against it\n      if(typeof coordinates[i] === \"object\"){\n        coordinates[i] = eachPosition(coordinates[i], func);\n      }\n    }\n    return coordinates;\n  }\n\n  /*\n  Public: Convert a GeoJSON Position object to Geographic (4326)\n  */\n  function positionToGeographic(position) {\n    var x = position[0];\n    var y = position[1];\n    return [radToDeg(x / EarthRadius) - (Math.floor((radToDeg(x / EarthRadius) + 180) / 360) * 360), radToDeg((Math.PI / 2) - (2 * Math.atan(Math.exp(-1.0 * y / EarthRadius))))];\n  }\n\n  /*\n  Public: Convert a GeoJSON Position object to Web Mercator (102100)\n  */\n  function positionToMercator(position) {\n    var lng = position[0];\n    var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n    return [degToRad(lng) * EarthRadius, EarthRadius/2.0 * Math.log( (1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))) )];\n  }\n\n  /*\n  Public: Apply a function agaist all positions in a geojson object. Used by spatial reference converters.\n  */\n  function applyConverter(geojson, converter, noCrs){\n    if(geojson.type === \"Point\") {\n      geojson.coordinates = converter(geojson.coordinates);\n    } else if(geojson.type === \"Feature\") {\n      geojson.geometry = applyConverter(geojson.geometry, converter, true);\n    } else if(geojson.type === \"FeatureCollection\") {\n      for (var f = 0; f < geojson.features.length; f++) {\n        geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n      }\n    } else if(geojson.type === \"GeometryCollection\") {\n      for (var g = 0; g < geojson.geometries.length; g++) {\n        geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n      }\n    } else {\n      geojson.coordinates = eachPosition(geojson.coordinates, converter);\n    }\n\n    if(!noCrs){\n      if(converter === positionToMercator){\n        geojson.crs = MercatorCRS;\n      }\n    }\n\n    if(converter === positionToGeographic){\n      delete geojson.crs;\n    }\n\n    return geojson;\n  }\n\n  /*\n  Public: Convert a GeoJSON object to ESRI Web Mercator (102100)\n  */\n  function toMercator(geojson) {\n    return applyConverter(geojson, positionToMercator);\n  }\n\n  /*\n  Convert a GeoJSON object to Geographic coordinates (WSG84, 4326)\n  */\n  function toGeographic(geojson) {\n    return applyConverter(geojson, positionToGeographic);\n  }\n\n\n  /*\n  Internal: -1,0,1 comparison function\n  */\n  function cmp(a, b) {\n    if(a < b) {\n      return -1;\n    } else if(a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n  Internal: used for sorting\n  */\n  function compSort(p1, p2) {\n    if (p1[0] > p2[0]) {\n      return -1;\n    } else if (p1[0] < p2[0]) {\n      return 1;\n    } else if (p1[1] > p2[1]) {\n      return -1;\n    } else if (p1[1] < p2[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n\n  /*\n  Internal: used to determine turn\n  */\n  function turn(p, q, r) {\n    // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n    return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n  }\n\n  /*\n  Internal: used to determine euclidean distance between two points\n  */\n  function euclideanDistance(p, q) {\n    // Returns the squared Euclidean distance between p and q.\n    var dx = q[0] - p[0];\n    var dy = q[1] - p[1];\n\n    return dx * dx + dy * dy;\n  }\n\n  function nextHullPoint(points, p) {\n    // Returns the next point on the convex hull in CCW from p.\n    var q = p;\n    for(var r in points) {\n      var t = turn(p, q, points[r]);\n      if(t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n        q = points[r];\n      }\n    }\n    return q;\n  }\n\n  function convexHull(points) {\n    // implementation of the Jarvis March algorithm\n    // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n\n    if(points.length === 0) {\n      return [];\n    } else if(points.length === 1) {\n      return points;\n    }\n\n    // Returns the points on the convex hull of points in CCW order.\n    var hull = [points.sort(compSort)[0]];\n\n    for(var p = 0; p < hull.length; p++) {\n      var q = nextHullPoint(points, hull[p]);\n\n      if(q !== hull[0]) {\n        hull.push(q);\n      }\n    }\n\n    return hull;\n  }\n\n  function isConvex(points) {\n    var ltz;\n\n    for (var i = 0; i < points.length - 3; i++) {\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n      var v = [p2[0] - p1[0], p2[1] - p1[1]];\n\n      // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n      var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n      if (i === 0) {\n        if (res < 0) {\n          ltz = true;\n        } else {\n          ltz = false;\n        }\n      } else {\n        if (ltz && (res > 0) || !ltz && (res < 0)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesContainPoint(coordinates, point) {\n    var contains = false;\n    for(var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n      if (((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1]) ||\n           (coordinates[j][1] <= point[1] && point[1] < coordinates[i][1])) &&\n          (point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0])) {\n        contains = !contains;\n      }\n    }\n    return contains;\n  }\n\n  function polygonContainsPoint(polygon, point) {\n    if (polygon && polygon.length) {\n      if (polygon.length === 1) { // polygon with no holes\n        return coordinatesContainPoint(polygon[0], point);\n      } else { // polygon with holes\n        if (coordinatesContainPoint(polygon[0], point)) {\n          for (var i = 1; i < polygon.length; i++) {\n            if (coordinatesContainPoint(polygon[i], point)) {\n              return false; // found in hole\n            }\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function edgeIntersectsEdge(a1, a2, b1, b2) {\n    var ua_t = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n    var ub_t = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n    var u_b  = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n    if ( u_b !== 0 ) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n\n      if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function arraysIntersectArrays(a, b) {\n    if (isNumber(a[0][0])) {\n      if (isNumber(b[0][0])) {\n        for (var i = 0; i < a.length - 1; i++) {\n          for (var j = 0; j < b.length - 1; j++) {\n            if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n              return true;\n            }\n          }\n        }\n      } else {\n        for (var k = 0; k < b.length; k++) {\n          if (arraysIntersectArrays(a, b[k])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var l = 0; l < a.length; l++) {\n        if (arraysIntersectArrays(a[l], b)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /*\n  Internal: Returns a copy of coordinates for s closed polygon\n  */\n  function closedPolygon(coordinates) {\n    var outer = [ ];\n\n    for (var i = 0; i < coordinates.length; i++) {\n      var inner = coordinates[i].slice();\n      if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n        inner.push(inner[0]);\n      }\n\n      outer.push(inner);\n    }\n\n    return outer;\n  }\n\n  function pointsEqual(a, b) {\n    for (var i = 0; i < a.length; i++) {\n\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    var na = a.slice().sort(compSort);\n    var nb = b.slice().sort(compSort);\n\n    for (var i = 0; i < na.length; i++) {\n      if (na[i].length !== nb[i].length) {\n        return false;\n      }\n      for (var j = 0; j < na.length; j++) {\n        if (na[i][j] !== nb[i][j]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /*\n  Internal: An array of variables that will be excluded form JSON objects.\n  */\n  var excludeFromJSON = [\"length\"];\n\n  /*\n  Internal: Base GeoJSON Primitive\n  */\n  function Primitive(geojson){\n    if(geojson){\n      switch (geojson.type) {\n      case 'Point':\n        return new Point(geojson);\n\n      case 'MultiPoint':\n        return new MultiPoint(geojson);\n\n      case 'LineString':\n        return new LineString(geojson);\n\n      case 'MultiLineString':\n        return new MultiLineString(geojson);\n\n      case 'Polygon':\n        return new Polygon(geojson);\n\n      case 'MultiPolygon':\n        return new MultiPolygon(geojson);\n\n      case 'Feature':\n        return new Feature(geojson);\n\n      case 'FeatureCollection':\n        return new FeatureCollection(geojson);\n\n      case 'GeometryCollection':\n        return new GeometryCollection(geojson);\n\n      default:\n        throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n  }\n\n  Primitive.prototype.toMercator = function(){\n    return toMercator(this);\n  };\n\n  Primitive.prototype.toGeographic = function(){\n    return toGeographic(this);\n  };\n\n  Primitive.prototype.envelope = function(){\n    return calculateEnvelope(this);\n  };\n\n  Primitive.prototype.bbox = function(){\n    return calculateBounds(this);\n  };\n\n  Primitive.prototype.convexHull = function(){\n    var coordinates = [ ], i, j;\n    if (this.type === 'Point') {\n      return null;\n    } else if (this.type === 'LineString' || this.type === 'MultiPoint') {\n      if (this.coordinates && this.coordinates.length >= 3) {\n        coordinates = this.coordinates;\n      } else {\n        return null;\n      }\n    } else if (this.type === 'Polygon' || this.type === 'MultiLineString') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          coordinates = coordinates.concat(this.coordinates[i]);\n        }\n        if(coordinates.length < 3){\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if (this.type === 'MultiPolygon') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          for (j = 0; j < this.coordinates[i].length; j++) {\n            coordinates = coordinates.concat(this.coordinates[i][j]);\n          }\n        }\n        if(coordinates.length < 3){\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if(this.type === \"Feature\"){\n      var primitive = new Primitive(this.geometry);\n      return primitive.convexHull();\n    }\n\n    return new Polygon({\n      type: 'Polygon',\n      coordinates: closedPolygon([convexHull(coordinates)])\n    });\n  };\n\n  Primitive.prototype.toJSON = function(){\n    var obj = {};\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && excludeFromJSON.indexOf(key) === -1) {\n        obj[key] = this[key];\n      }\n    }\n    obj.bbox = calculateBounds(this);\n    return obj;\n  };\n\n  Primitive.prototype.contains = function(primitive){\n    return new Primitive(primitive).within(this);\n  };\n\n  Primitive.prototype.within = function(primitive) {\n    var coordinates, i, contains;\n\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    }\n\n    // point.within(point) :: equality\n    if (primitive.type === \"Point\") {\n      if (this.type === \"Point\") {\n        return pointsEqual(this.coordinates, primitive.coordinates);\n\n      }\n    }\n\n    // point.within(multilinestring)\n    if (primitive.type === \"MultiLineString\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var linestring = { type: \"LineString\", coordinates: primitive.coordinates[i] };\n\n          if (this.within(linestring)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    // point.within(linestring), point.within(multipoint)\n    if (primitive.type === \"LineString\" || primitive.type === \"MultiPoint\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          if (this.coordinates.length !== primitive.coordinates[i].length) {\n            return false;\n          }\n\n          if (pointsEqual(this.coordinates, primitive.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (primitive.type === \"Polygon\") {\n      // polygon.within(polygon)\n      if (this.type === \"Polygon\") {\n        // check for equal polygons\n        if (primitive.coordinates.length === this.coordinates.length) {\n          for (i = 0; i < this.coordinates.length; i++) {\n            if (coordinatesEqual(this.coordinates[i], primitive.coordinates[i])) {\n              return true;\n            }\n          }\n        }\n\n        if (this.coordinates.length && polygonContainsPoint(primitive.coordinates, this.coordinates[0][0])) {\n          return !arraysIntersectArrays(closedPolygon(this.coordinates), closedPolygon(primitive.coordinates));\n        } else {\n          return false;\n        }\n\n      // point.within(polygon)\n      } else if (this.type === \"Point\") {\n        return polygonContainsPoint(primitive.coordinates, this.coordinates);\n\n      // linestring/multipoint withing polygon\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        if (!this.coordinates || this.coordinates.length === 0) {\n          return false;\n        }\n\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (polygonContainsPoint(primitive.coordinates, this.coordinates[i]) === false) {\n            return false;\n          }\n        }\n\n        return true;\n\n      // multilinestring.within(polygon)\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var ls = new LineString(this.coordinates[i]);\n\n          if (ls.within(primitive) === false) {\n            contains++;\n            return false;\n          }\n        }\n\n        return true;\n\n      // multipolygon.within(polygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var p1 = new Primitive({ type: \"Polygon\", coordinates: this.coordinates[i] });\n\n          if (p1.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n    }\n\n    if (primitive.type === \"MultiPolygon\") {\n      // point.within(multipolygon)\n      if (this.type === \"Point\") {\n        if (primitive.coordinates.length) {\n          for (i = 0; i < primitive.coordinates.length; i++) {\n            coordinates = primitive.coordinates[i];\n            if (polygonContainsPoint(coordinates, this.coordinates) && arraysIntersectArrays([this.coordinates], primitive.coordinates) === false) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      // polygon.within(multipolygon)\n      } else if (this.type === \"Polygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (primitive.coordinates[i].length === this.coordinates.length) {\n            for (j = 0; j < this.coordinates.length; j++) {\n              if (coordinatesEqual(this.coordinates[j], primitive.coordinates[i][j])) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (arraysIntersectArrays(this.coordinates, primitive.coordinates) === false) {\n          if (primitive.coordinates.length) {\n            for (i = 0; i < primitive.coordinates.length; i++) {\n              coordinates = primitive.coordinates[i];\n              if (polygonContainsPoint(coordinates, this.coordinates[0][0]) === false) {\n                contains = false;\n              } else {\n                contains = true;\n              }\n            }\n\n            return contains;\n          }\n        }\n\n      // linestring.within(multipolygon), multipoint.within(multipolygon)\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var p = { type: \"Polygon\", coordinates: primitive.coordinates[i] };\n\n          if (this.within(p)) {\n            return true;\n          }\n\n          return false;\n        }\n\n      // multilinestring.within(multipolygon)\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var lines = new LineString(this.coordinates[i]);\n\n          if (lines.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n\n      // multipolygon.within(multipolygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var mpoly = { type: \"Polygon\", coordinates: primitive.coordinates[i] };\n\n          if (this.within(mpoly) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    // default to false\n    return false;\n  };\n\n  Primitive.prototype.intersects = function(primitive) {\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    }\n\n    var p = new Primitive(primitive);\n    if (this.within(primitive) || p.within(this)) {\n      return true;\n    }\n\n\n    if (this.type !== 'Point' && this.type !== 'MultiPoint' &&\n        primitive.type !== 'Point' && primitive.type !== 'MultiPoint') {\n      return arraysIntersectArrays(this.coordinates, primitive.coordinates);\n    } else if (this.type === 'Feature') {\n      // in the case of a Feature, use the internal primitive for intersection\n      var inner = new Primitive(this.geometry);\n      return inner.intersects(primitive);\n    }\n\n    warn(\"Type \" + this.type + \" to \" + primitive.type + \" intersection is not supported by intersects\");\n    return false;\n  };\n\n\n  /*\n  GeoJSON Point Class\n    new Point();\n    new Point(x,y,z,wtf);\n    new Point([x,y,z,wtf]);\n    new Point([x,y]);\n    new Point({\n      type: \"Point\",\n      coordinates: [x,y]\n    });\n  */\n  function Point(input){\n    var args = Array.prototype.slice.call(arguments);\n\n    if(input && input.type === \"Point\" && input.coordinates){\n      extend(this, input);\n    } else if(input && isArray(input)) {\n      this.coordinates = input;\n    } else if(args.length >= 2) {\n      this.coordinates = args;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Point\";\n    }\n\n    this.type = \"Point\";\n  }\n\n  Point.prototype = new Primitive();\n  Point.prototype.constructor = Point;\n\n  /*\n  GeoJSON MultiPoint Class\n      new MultiPoint();\n      new MultiPoint([[x,y], [x1,y1]]);\n      new MultiPoint({\n        type: \"MultiPoint\",\n        coordinates: [x,y]\n      });\n  */\n  function MultiPoint(input){\n    if(input && input.type === \"MultiPoint\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPoint\";\n    }\n\n    this.type = \"MultiPoint\";\n  }\n\n  MultiPoint.prototype = new Primitive();\n  MultiPoint.prototype.constructor = MultiPoint;\n  MultiPoint.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n    return this;\n  };\n  MultiPoint.prototype.addPoint = function(point){\n    this.coordinates.push(point);\n    return this;\n  };\n  MultiPoint.prototype.insertPoint = function(point, index){\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n  MultiPoint.prototype.removePoint = function(remove){\n    if(typeof remove === \"number\"){\n      this.coordinates.splice(remove, 1);\n    } else {\n      this.coordinates.splice(this.coordinates.indexOf(remove), 1);\n    }\n    return this;\n  };\n  MultiPoint.prototype.get = function(i){\n    return new Point(this.coordinates[i]);\n  };\n\n  /*\n  GeoJSON LineString Class\n      new LineString();\n      new LineString([[x,y], [x1,y1]]);\n      new LineString({\n        type: \"LineString\",\n        coordinates: [x,y]\n      });\n  */\n  function LineString(input){\n    if(input && input.type === \"LineString\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.LineString\";\n    }\n\n    this.type = \"LineString\";\n  }\n\n  LineString.prototype = new Primitive();\n  LineString.prototype.constructor = LineString;\n  LineString.prototype.addVertex = function(point){\n    this.coordinates.push(point);\n    return this;\n  };\n  LineString.prototype.insertVertex = function(point, index){\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n  LineString.prototype.removeVertex = function(remove){\n    this.coordinates.splice(remove, 1);\n    return this;\n  };\n\n  /*\n  GeoJSON MultiLineString Class\n      new MultiLineString();\n      new MultiLineString([ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]);\n      new MultiLineString({\n        type: \"MultiLineString\",\n        coordinates: [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]\n      });\n  */\n  function MultiLineString(input){\n    if(input && input.type === \"MultiLineString\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiLineString\";\n    }\n\n    this.type = \"MultiLineString\";\n  }\n\n  MultiLineString.prototype = new Primitive();\n  MultiLineString.prototype.constructor = MultiLineString;\n  MultiLineString.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates ]);\n    }\n  };\n  MultiLineString.prototype.get = function(i){\n    return new LineString(this.coordinates[i]);\n  };\n\n  /*\n  GeoJSON Polygon Class\n      new Polygon();\n      new Polygon([ [[x,y], [x1,y1], [x2,y2]] ]);\n      new Polygon({\n        type: \"Polygon\",\n        coordinates: [ [[x,y], [x1,y1], [x2,y2]] ]\n      });\n  */\n  function Polygon(input){\n    if(input && input.type === \"Polygon\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Polygon\";\n    }\n\n    this.type = \"Polygon\";\n  }\n\n  Polygon.prototype = new Primitive();\n  Polygon.prototype.constructor = Polygon;\n  Polygon.prototype.addVertex = function(point){\n    this.insertVertex(point, this.coordinates[0].length - 1);\n    return this;\n  };\n  Polygon.prototype.insertVertex = function(point, index){\n    this.coordinates[0].splice(index, 0, point);\n    return this;\n  };\n  Polygon.prototype.removeVertex = function(remove){\n    this.coordinates[0].splice(remove, 1);\n    return this;\n  };\n  Polygon.prototype.close = function() {\n    this.coordinates = closedPolygon(this.coordinates);\n  };\n  Polygon.prototype.hasHoles = function() {\n    return this.coordinates.length > 1;\n  };\n  Polygon.prototype.holes = function() {\n    holes = [];\n    if (this.hasHoles()) {\n      for (var i = 1; i < this.coordinates.length; i++) {\n        holes.push(new Polygon([this.coordinates[i]]));\n      }\n    }\n    return holes;\n  };\n\n  /*\n  GeoJSON MultiPolygon Class\n      new MultiPolygon();\n      new MultiPolygon([ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]);\n      new MultiPolygon({\n        type: \"MultiPolygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n  function MultiPolygon(input){\n    if(input && input.type === \"MultiPolygon\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPolygon\";\n    }\n\n    this.type = \"MultiPolygon\";\n  }\n\n  MultiPolygon.prototype = new Primitive();\n  MultiPolygon.prototype.constructor = MultiPolygon;\n  MultiPolygon.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates ]);\n    }\n  };\n  MultiPolygon.prototype.get = function(i){\n    return new Polygon(this.coordinates[i]);\n  };\n  MultiPolygon.prototype.close = function(){\n    var outer = [];\n    this.forEach(function(polygon){\n      outer.push(closedPolygon(polygon));\n    });\n    this.coordinates = outer;\n    return this;\n  };\n\n  /*\n  GeoJSON Feature Class\n      new Feature();\n      new Feature({\n        type: \"Feature\",\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n        }\n      });\n      new Feature({\n        type: \"Polygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n  function Feature(input){\n    if(input && input.type === \"Feature\"){\n      extend(this, input);\n    } else if(input && input.type && input.coordinates) {\n      this.geometry = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Feature\";\n    }\n\n    this.type = \"Feature\";\n  }\n\n  Feature.prototype = new Primitive();\n  Feature.prototype.constructor = Feature;\n\n  /*\n  GeoJSON FeatureCollection Class\n      new FeatureCollection();\n      new FeatureCollection([feature, feature1]);\n      new FeatureCollection({\n        type: \"FeatureCollection\",\n        coordinates: [feature, feature1]\n      });\n  */\n  function FeatureCollection(input){\n    if(input && input.type === \"FeatureCollection\" && input.features){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.features = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.FeatureCollection\";\n    }\n\n    this.type = \"FeatureCollection\";\n  }\n\n  FeatureCollection.prototype = new Primitive();\n  FeatureCollection.prototype.constructor = FeatureCollection;\n  FeatureCollection.prototype.forEach = function(func){\n    for (var i = 0; i < this.features.length; i++) {\n      func.apply(this, [this.features[i], i, this.features]);\n    }\n  };\n  FeatureCollection.prototype.get = function(id){\n    var found;\n    this.forEach(function(feature){\n      if(feature.id === id){\n        found = feature;\n      }\n    });\n    return new Feature(found);\n  };\n\n  /*\n  GeoJSON GeometryCollection Class\n      new GeometryCollection();\n      new GeometryCollection([geometry, geometry1]);\n      new GeometryCollection({\n        type: \"GeometryCollection\",\n        coordinates: [geometry, geometry1]\n      });\n  */\n  function GeometryCollection(input){\n    if(input && input.type === \"GeometryCollection\" && input.geometries){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.geometries = input;\n    } else if(input.coordinates && input.type){\n      this.type = \"GeometryCollection\";\n      this.geometries = [input];\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.GeometryCollection\";\n    }\n\n    this.type = \"GeometryCollection\";\n  }\n\n  GeometryCollection.prototype = new Primitive();\n  GeometryCollection.prototype.constructor = GeometryCollection;\n  GeometryCollection.prototype.forEach = function(func){\n    for (var i = 0; i < this.geometries.length; i++) {\n      func.apply(this, [this.geometries[i], i, this.geometries]);\n    }\n  };\n  GeometryCollection.prototype.get = function(i){\n    return new Primitive(this.geometries[i]);\n  };\n\n  function createCircle(center, radius, interpolate){\n    var mercatorPosition = positionToMercator(center);\n    var steps = interpolate || 64;\n    var polygon = {\n      type: \"Polygon\",\n      coordinates: [[]]\n    };\n    for(var i=1; i<=steps; i++) {\n      var radians = i * (360/steps) * Math.PI / 180;\n      polygon.coordinates[0].push([mercatorPosition[0] + radius * Math.cos(radians), mercatorPosition[1] + radius * Math.sin(radians)]);\n    }\n    polygon.coordinates = closedPolygon(polygon.coordinates);\n\n    return toGeographic(polygon);\n  }\n\n  function Circle (center, radius, interpolate) {\n    var steps = interpolate || 64;\n    var rad = radius || 250;\n\n    if(!center || center.length < 2 || !rad || !steps) {\n      throw new Error(\"Terraformer: missing parameter for Terraformer.Circle\");\n    }\n\n    extend(this, new Feature({\n      type: \"Feature\",\n      geometry: createCircle(center, rad, steps),\n      properties: {\n        radius: rad,\n        center: center,\n        steps: steps\n      }\n    }));\n  }\n\n  Circle.prototype = new Primitive();\n  Circle.prototype.constructor = Circle;\n  Circle.prototype.recalculate = function(){\n    this.geometry = createCircle(this.properties.center, this.properties.radius, this.properties.steps);\n    return this;\n  };\n  Circle.prototype.center = function(coordinates){\n    if(coordinates){\n      this.properties.center = coordinates;\n      this.recalculate();\n    }\n    return this.properties.center;\n  };\n  Circle.prototype.radius = function(radius){\n    if(radius){\n      this.properties.radius = radius;\n      this.recalculate();\n    }\n    return this.properties.radius;\n  };\n  Circle.prototype.steps = function(steps){\n    if(steps){\n      this.properties.steps = steps;\n      this.recalculate();\n    }\n    return this.properties.steps;\n  };\n\n  Circle.prototype.toJSON = function() {\n    var output = Primitive.prototype.toJSON.call(this);\n    return output;\n  };\n\n  exports.Primitive = Primitive;\n  exports.Point = Point;\n  exports.MultiPoint = MultiPoint;\n  exports.LineString = LineString;\n  exports.MultiLineString = MultiLineString;\n  exports.Polygon = Polygon;\n  exports.MultiPolygon = MultiPolygon;\n  exports.Feature = Feature;\n  exports.FeatureCollection = FeatureCollection;\n  exports.GeometryCollection = GeometryCollection;\n  exports.Circle = Circle;\n\n  exports.toMercator = toMercator;\n  exports.toGeographic = toGeographic;\n\n  exports.Tools = {};\n  exports.Tools.positionToMercator = positionToMercator;\n  exports.Tools.positionToGeographic = positionToGeographic;\n  exports.Tools.applyConverter = applyConverter;\n  exports.Tools.toMercator = toMercator;\n  exports.Tools.toGeographic = toGeographic;\n  exports.Tools.createCircle = createCircle;\n\n  exports.Tools.calculateBounds = calculateBounds;\n  exports.Tools.calculateEnvelope = calculateEnvelope;\n\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.polygonContainsPoint = polygonContainsPoint;\n  exports.Tools.arraysIntersectArrays = arraysIntersectArrays;\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.coordinatesEqual = coordinatesEqual;\n  exports.Tools.convexHull = convexHull;\n  exports.Tools.isConvex = isConvex;\n\n  exports.MercatorCRS = MercatorCRS;\n  exports.GeographicCRS = GeographicCRS;\n\n  return exports;\n}));\n"]},"metadata":{},"sourceType":"script"}