{"ast":null,"code":"'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst Promise = require('../../promise');\n\nconst Utils = require('../../utils');\n\nconst debug = Utils.getLogger().debugContext('connection:sqlite');\n\nconst dataTypes = require('../../data-types').sqlite;\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('sqlite');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.config = sequelize.config;\n    this.dialect = dialect;\n    this.dialectName = this.sequelize.options.dialect;\n    this.connections = {}; // We attempt to parse file location from a connection uri but we shouldn't match sequelize default host.\n\n    if (this.sequelize.options.host === 'localhost') delete this.sequelize.options.host;\n\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath).verbose();\n      } else {\n        this.lib = require('sqlite3').verbose();\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install sqlite3 package manually');\n      }\n\n      throw err;\n    }\n\n    this.refreshTypeParser(dataTypes);\n  } // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.inMemory = (this.sequelize.options.storage || this.sequelize.options.host || ':memory:') === ':memory:' ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    options.readWriteMode = dialectOptions && dialectOptions.mode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return Promise.resolve(this.connections[options.inMemory || options.uuid]);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(this.sequelize.options.storage || this.sequelize.options.host || ':memory:', options.readWriteMode || this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE, // default mode\n      err => {\n        if (err) {\n          if (err.code === 'SQLITE_CANTOPEN') return reject(new sequelizeErrors.ConnectionError(err));\n          return reject(new sequelizeErrors.ConnectionError(err));\n        }\n\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    }).tap(connection => {\n      if (this.sequelize.config.password) {\n        // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n        connection.run('PRAGMA KEY=' + this.sequelize.escape(this.sequelize.config.password));\n      }\n\n      if (this.sequelize.options.foreignKeys !== false) {\n        // Make it possible to define and use foreign key constraints unless\n        // explicitly disallowed. It's still opt-in per relation\n        connection.run('PRAGMA FOREIGN_KEYS=ON');\n      }\n    });\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/dialects/sqlite/connection-manager.js"],"names":["AbstractConnectionManager","require","Promise","Utils","debug","getLogger","debugContext","dataTypes","sqlite","sequelizeErrors","parserStore","ConnectionManager","constructor","dialect","sequelize","config","dialectName","options","connections","host","dialectModulePath","lib","verbose","err","code","Error","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","getConnection","uuid","inMemory","storage","dialectOptions","readWriteMode","mode","resolve","reject","Database","OPEN_READWRITE","OPEN_CREATE","ConnectionError","tap","connection","password","run","escape","foreignKeys","releaseConnection","force","filename","close","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst Promise = require('../../promise');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.config = sequelize.config;\n    this.dialect = dialect;\n    this.dialectName = this.sequelize.options.dialect;\n    this.connections = {};\n\n    // We attempt to parse file location from a connection uri but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') delete this.sequelize.options.host;\n\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath).verbose();\n      } else {\n        this.lib = require('sqlite3').verbose();\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install sqlite3 package manually');\n      }\n      throw err;\n    }\n\n    this.refreshTypeParser(dataTypes);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n    options.inMemory = (this.sequelize.options.storage || this.sequelize.options.host || ':memory:') === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    options.readWriteMode = dialectOptions && dialectOptions.mode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return Promise.resolve(this.connections[options.inMemory || options.uuid]);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        this.sequelize.options.storage || this.sequelize.options.host || ':memory:',\n        options.readWriteMode || this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE, // default mode\n        err => {\n          if (err) {\n            if (err.code === 'SQLITE_CANTOPEN') return reject(new sequelizeErrors.ConnectionError(err));\n            return reject(new sequelizeErrors.ConnectionError(err));\n          }\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    }).tap(connection => {\n      if (this.sequelize.config.password) {\n        // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n        connection.run('PRAGMA KEY=' + this.sequelize.escape(this.sequelize.config.password));\n      }\n      if (this.sequelize.options.foreignKeys !== false) {\n        // Make it possible to define and use foreign key constraints unless\n        // explicitly disallowed. It's still opt-in per relation\n        connection.run('PRAGMA FOREIGN_KEYS=ON');\n      }\n    });\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}