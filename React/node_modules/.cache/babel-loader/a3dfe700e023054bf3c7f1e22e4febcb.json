{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\n\nconst authConstants_1 = require(\"../util/authConstants\");\n\nclass ApplicationTokenCredentialsBase extends tokenCredentialsBase_1.TokenCredentialsBase {\n  /**\n   * Creates a new ApplicationTokenCredentials object.\n   * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n   * for detailed instructions on creating an Azure Active Directory application.\n   * @constructor\n   * @param {string} clientId The active directory application client id.\n   * @param {string} domain The domain or tenant id containing this application.\n   * @param {string} [tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n   * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n   * @param {Environment} [environment] The azure environment to authenticate with.\n   * @param {object} [tokenCache] The token cache. Default value is the MemoryCache object from adal.\n   */\n  constructor(clientId, domain, tokenAudience, environment, tokenCache) {\n    super(clientId, domain, tokenAudience, environment, tokenCache);\n  }\n\n  getTokenFromCache() {\n    const _super = Object.create(null, {\n      getTokenFromCache: {\n        get: () => super.getTokenFromCache\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const self = this; // a thin wrapper over the base implementation. try get token from cache, additionaly clean up cache if required.\n\n      try {\n        const tokenResponse = yield _super.getTokenFromCache.call(this, undefined);\n        return Promise.resolve(tokenResponse);\n      } catch (error) {\n        // Remove the stale token from the tokencache. ADAL gives the same error message \"Entry not found in cache.\"\n        // for entry not being present in the cache and for accessToken being expired in the cache. We do not want the token cache\n        // to contain the expired token, we clean it up here.\n        const status = yield self.removeInvalidItemsFromCache({\n          _clientId: self.clientId\n        });\n\n        if (status.result) {\n          return Promise.reject(error);\n        }\n\n        const message = status && status.details && status.details.message ? status.details.message : status.details;\n        return Promise.reject(new Error(authConstants_1.AuthConstants.SDK_INTERNAL_ERROR + \" : \" + \"critical failure while removing expired token for service principal from token cache. \" + message));\n      }\n    });\n  }\n  /**\n   * Removes invalid items from token cache. This method is different. Here we never reject in case of error.\n   * Rather we resolve with an object that says the result is false and error information is provided in\n   * the details property of the resolved object. This is done to do better error handling in the above function\n   * where removeInvalidItemsFromCache() is called.\n   * @param {object} query The query to be used for finding the token for service principal from the cache\n   * @returns {result: boolean, details?: Error} resultObject with more info.\n   */\n\n\n  removeInvalidItemsFromCache(query) {\n    const self = this;\n    return new Promise(resolve => {\n      self.tokenCache.find(query, (error, entries) => {\n        if (error) {\n          return resolve({\n            result: false,\n            details: error\n          });\n        }\n\n        if (entries && entries.length > 0) {\n          return new Promise(resolve => {\n            return self.tokenCache.remove(entries, err => {\n              if (err) {\n                return resolve({\n                  result: false,\n                  details: err\n                });\n              }\n\n              return resolve({\n                result: true\n              });\n            });\n          });\n        } else {\n          return resolve({\n            result: true\n          });\n        }\n      });\n    });\n  }\n\n}\n\nexports.ApplicationTokenCredentialsBase = ApplicationTokenCredentialsBase;","map":{"version":3,"sources":["../../../lib/credentials/applicationTokenCredentialsBase.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAA,sBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEA,MAAA,eAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAGA,MAAsB,+BAAtB,SAA8D,sBAAA,CAAA,oBAA9D,CAAkF;AAChF;;;;;;;;;;;;AAYA,EAAA,WAAA,CACE,QADF,EAEE,MAFF,EAGE,aAHF,EAIE,WAJF,EAKE,UALF,EAKyB;AAEvB,UAAM,QAAN,EAAgB,MAAhB,EAAwB,aAAxB,EAAuC,WAAvC,EAAoD,UAApD;AACD;;AAEe,EAAA,iBAAiB,GAAA;;;;;;;;AAC/B,YAAM,IAAI,GAAG,IAAb,C,CAEA;;AACA,UAAI;AACF,cAAM,aAAa,GAAG,MAAM,MAAA,CAAM,iBAAN,CAAuB,IAAvB,CAAuB,IAAvB,EAAwB,SAAxB,CAA5B;AACA,eAAO,OAAO,CAAC,OAAR,CAAgB,aAAhB,CAAP;AACD,OAHD,CAGE,OAAO,KAAP,EAAc;AACd;AACA;AACA;AACA,cAAM,MAAM,GAAG,MAAM,IAAI,CAAC,2BAAL,CAAiC;AACpD,UAAA,SAAS,EAAE,IAAI,CAAC;AADoC,SAAjC,CAArB;;AAGA,YAAI,MAAM,CAAC,MAAX,EAAmB;AACjB,iBAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACD;;AACD,cAAM,OAAO,GACX,MAAM,IAAI,MAAM,CAAC,OAAjB,IAA4B,MAAM,CAAC,OAAP,CAAe,OAA3C,GACI,MAAM,CAAC,OAAP,CAAe,OADnB,GAEI,MAAM,CAAC,OAHb;AAIA,eAAO,OAAO,CAAC,MAAR,CACL,IAAI,KAAJ,CACE,eAAA,CAAA,aAAA,CAAc,kBAAd,GACA,KADA,GAEA,wFAFA,GAGA,OAJF,CADK,CAAP;AAQD;AACF,K;AAAA;AAED;;;;;;;;;;AAQQ,EAAA,2BAA2B,CACjC,KADiC,EACpB;AAEb,UAAM,IAAI,GAAG,IAAb;AACA,WAAO,IAAI,OAAJ,CAAkD,OAAO,IAAG;AACjE,MAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,KAArB,EAA4B,CAAC,KAAD,EAAe,OAAf,KAAiC;AAC3D,YAAI,KAAJ,EAAW;AACT,iBAAO,OAAO,CAAC;AAAE,YAAA,MAAM,EAAE,KAAV;AAAiB,YAAA,OAAO,EAAE;AAA1B,WAAD,CAAd;AACD;;AAED,YAAI,OAAO,IAAI,OAAO,CAAC,MAAR,GAAiB,CAAhC,EAAmC;AACjC,iBAAO,IAAI,OAAJ,CAAY,OAAO,IAAG;AAC3B,mBAAO,IAAI,CAAC,UAAL,CAAgB,MAAhB,CAAuB,OAAvB,EAAiC,GAAD,IAAe;AACpD,kBAAI,GAAJ,EAAS;AACP,uBAAO,OAAO,CAAC;AAAE,kBAAA,MAAM,EAAE,KAAV;AAAiB,kBAAA,OAAO,EAAE;AAA1B,iBAAD,CAAd;AACD;;AACD,qBAAO,OAAO,CAAC;AAAE,gBAAA,MAAM,EAAE;AAAV,eAAD,CAAd;AACD,aALM,CAAP;AAMD,WAPM,CAAP;AAQD,SATD,MASO;AACL,iBAAO,OAAO,CAAC;AAAE,YAAA,MAAM,EAAE;AAAV,WAAD,CAAd;AACD;AACF,OAjBD;AAkBD,KAnBM,CAAP;AAoBD;;AAvF+E;;AAAlF,OAAA,CAAA,+BAAA,GAAA,+BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\nconst authConstants_1 = require(\"../util/authConstants\");\nclass ApplicationTokenCredentialsBase extends tokenCredentialsBase_1.TokenCredentialsBase {\n    /**\n     * Creates a new ApplicationTokenCredentials object.\n     * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n     * for detailed instructions on creating an Azure Active Directory application.\n     * @constructor\n     * @param {string} clientId The active directory application client id.\n     * @param {string} domain The domain or tenant id containing this application.\n     * @param {string} [tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n     * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n     * @param {Environment} [environment] The azure environment to authenticate with.\n     * @param {object} [tokenCache] The token cache. Default value is the MemoryCache object from adal.\n     */\n    constructor(clientId, domain, tokenAudience, environment, tokenCache) {\n        super(clientId, domain, tokenAudience, environment, tokenCache);\n    }\n    getTokenFromCache() {\n        const _super = Object.create(null, {\n            getTokenFromCache: { get: () => super.getTokenFromCache }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const self = this;\n            // a thin wrapper over the base implementation. try get token from cache, additionaly clean up cache if required.\n            try {\n                const tokenResponse = yield _super.getTokenFromCache.call(this, undefined);\n                return Promise.resolve(tokenResponse);\n            }\n            catch (error) {\n                // Remove the stale token from the tokencache. ADAL gives the same error message \"Entry not found in cache.\"\n                // for entry not being present in the cache and for accessToken being expired in the cache. We do not want the token cache\n                // to contain the expired token, we clean it up here.\n                const status = yield self.removeInvalidItemsFromCache({\n                    _clientId: self.clientId\n                });\n                if (status.result) {\n                    return Promise.reject(error);\n                }\n                const message = status && status.details && status.details.message\n                    ? status.details.message\n                    : status.details;\n                return Promise.reject(new Error(authConstants_1.AuthConstants.SDK_INTERNAL_ERROR +\n                    \" : \" +\n                    \"critical failure while removing expired token for service principal from token cache. \" +\n                    message));\n            }\n        });\n    }\n    /**\n     * Removes invalid items from token cache. This method is different. Here we never reject in case of error.\n     * Rather we resolve with an object that says the result is false and error information is provided in\n     * the details property of the resolved object. This is done to do better error handling in the above function\n     * where removeInvalidItemsFromCache() is called.\n     * @param {object} query The query to be used for finding the token for service principal from the cache\n     * @returns {result: boolean, details?: Error} resultObject with more info.\n     */\n    removeInvalidItemsFromCache(query) {\n        const self = this;\n        return new Promise(resolve => {\n            self.tokenCache.find(query, (error, entries) => {\n                if (error) {\n                    return resolve({ result: false, details: error });\n                }\n                if (entries && entries.length > 0) {\n                    return new Promise(resolve => {\n                        return self.tokenCache.remove(entries, (err) => {\n                            if (err) {\n                                return resolve({ result: false, details: err });\n                            }\n                            return resolve({ result: true });\n                        });\n                    });\n                }\n                else {\n                    return resolve({ result: true });\n                }\n            });\n        });\n    }\n}\nexports.ApplicationTokenCredentialsBase = ApplicationTokenCredentialsBase;\n//# sourceMappingURL=applicationTokenCredentialsBase.js.map"]},"metadata":{},"sourceType":"script"}