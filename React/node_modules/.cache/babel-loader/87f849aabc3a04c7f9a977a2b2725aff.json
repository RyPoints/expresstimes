{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar DEFAULT_TIMEOUT = 3000;\nvar INIT_ID = 0;\nvar EVENT_CLOSED = 'closed';\nvar EVENT_DRAINED = 'drained';\n/**\n * Instance a new queue\n *\n * @param {Number} timeout a global timeout for new queue\n * @class\n * @constructor\n */\n\nvar SeqQueue = function (timeout) {\n  EventEmitter.call(this);\n\n  if (timeout && timeout > 0) {\n    this.timeout = timeout;\n  } else {\n    this.timeout = DEFAULT_TIMEOUT;\n  }\n\n  this.status = SeqQueueManager.STATUS_IDLE;\n  this.curId = INIT_ID;\n  this.queue = [];\n};\n\nutil.inherits(SeqQueue, EventEmitter);\n/**\n * Add a task into queue.\n * \n * @param fn new request\n * @param ontimeout callback when task timeout\n * @param timeout timeout for current request. take the global timeout if this is invalid\n * @returns true or false\n */\n\nSeqQueue.prototype.push = function (fn, ontimeout, timeout) {\n  if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n    //ignore invalid status\n    return false;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('fn should be a function.');\n  }\n\n  this.queue.push({\n    fn: fn,\n    ontimeout: ontimeout,\n    timeout: timeout\n  });\n\n  if (this.status === SeqQueueManager.STATUS_IDLE) {\n    this.status = SeqQueueManager.STATUS_BUSY;\n    var self = this;\n    process.nextTick(function () {\n      self._next(self.curId);\n    });\n  }\n\n  return true;\n};\n/**\n * Close queue\n * \n * @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue\n */\n\n\nSeqQueue.prototype.close = function (force) {\n  if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n    //ignore invalid status\n    return;\n  }\n\n  if (force) {\n    this.status = SeqQueueManager.STATUS_DRAINED;\n\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n      this.timerId = undefined;\n    }\n\n    this.emit(EVENT_DRAINED);\n  } else {\n    this.status = SeqQueueManager.STATUS_CLOSED;\n    this.emit(EVENT_CLOSED);\n  }\n};\n/**\n * Invoke next task\n * \n * @param {String|Number} tid last executed task id\n * @api private\n */\n\n\nSeqQueue.prototype._next = function (tid) {\n  if (tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {\n    //ignore invalid next call\n    return;\n  }\n\n  if (this.timerId) {\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n  }\n\n  var task = this.queue.shift();\n\n  if (!task) {\n    if (this.status === SeqQueueManager.STATUS_BUSY) {\n      this.status = SeqQueueManager.STATUS_IDLE;\n      this.curId++; //modify curId to invalidate timeout task\n    } else {\n      this.status = SeqQueueManager.STATUS_DRAINED;\n      this.emit(EVENT_DRAINED);\n    }\n\n    return;\n  }\n\n  var self = this;\n  task.id = ++this.curId;\n  var timeout = task.timeout > 0 ? task.timeout : this.timeout;\n  timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;\n  this.timerId = setTimeout(function () {\n    process.nextTick(function () {\n      self._next(task.id);\n    });\n    self.emit('timeout', task);\n\n    if (task.ontimeout) {\n      task.ontimeout();\n    }\n  }, timeout);\n\n  try {\n    task.fn({\n      done: function () {\n        var res = task.id === self.curId;\n        process.nextTick(function () {\n          self._next(task.id);\n        });\n        return res;\n      }\n    });\n  } catch (err) {\n    self.emit('error', err, task);\n    process.nextTick(function () {\n      self._next(task.id);\n    });\n  }\n};\n/**\n * Queue manager.\n * \n * @module\n */\n\n\nvar SeqQueueManager = module.exports;\n/**\n * Queue status: idle, welcome new tasks\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_IDLE = 0;\n/**\n * Queue status: busy, queue is working for some tasks now\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_BUSY = 1;\n/**\n * Queue status: closed, queue has closed and would not receive task any more \n * \t\t\t\t\tand is processing the remaining tasks now.\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_CLOSED = 2;\n/**\n * Queue status: drained, queue is ready to be destroy\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.STATUS_DRAINED = 3;\n/**\n * Create Sequence queue\n * \n * @param  {Number} timeout a global timeout for the new queue instance\n * @return {Object}         new queue instance\n * @memberOf SeqQueueManager\n */\n\nSeqQueueManager.createQueue = function (timeout) {\n  return new SeqQueue(timeout);\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/seq-queue/lib/seq-queue.js"],"names":["EventEmitter","require","util","DEFAULT_TIMEOUT","INIT_ID","EVENT_CLOSED","EVENT_DRAINED","SeqQueue","timeout","call","status","SeqQueueManager","STATUS_IDLE","curId","queue","inherits","prototype","push","fn","ontimeout","STATUS_BUSY","Error","self","process","nextTick","_next","close","force","STATUS_DRAINED","timerId","clearTimeout","undefined","emit","STATUS_CLOSED","tid","task","shift","id","setTimeout","done","res","err","module","exports","createQueue"],"mappings":"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","sourcesContent":["var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar DEFAULT_TIMEOUT = 3000;\nvar INIT_ID = 0;\nvar EVENT_CLOSED = 'closed';\nvar EVENT_DRAINED = 'drained';\n\n/**\n * Instance a new queue\n *\n * @param {Number} timeout a global timeout for new queue\n * @class\n * @constructor\n */\nvar SeqQueue = function(timeout) {\n\tEventEmitter.call(this);\n\t\n\tif(timeout && timeout > 0) {\n\t\tthis.timeout = timeout;\n\t} else {\n\t\tthis.timeout = DEFAULT_TIMEOUT;\n\t}\n\t\n\tthis.status = SeqQueueManager.STATUS_IDLE;\n\tthis.curId = INIT_ID;\n\tthis.queue = [];\n};\nutil.inherits(SeqQueue, EventEmitter);\n\n/**\n * Add a task into queue.\n * \n * @param fn new request\n * @param ontimeout callback when task timeout\n * @param timeout timeout for current request. take the global timeout if this is invalid\n * @returns true or false\n */\nSeqQueue.prototype.push = function(fn, ontimeout, timeout) {\n\tif(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n\t\t//ignore invalid status\n\t\treturn false;\n\t}\n\t\n\tif(typeof fn !== 'function') {\n\t\tthrow new Error('fn should be a function.');\n\t}\n\tthis.queue.push({fn: fn, ontimeout: ontimeout, timeout: timeout});\n\n\tif(this.status === SeqQueueManager.STATUS_IDLE) {\n\t\tthis.status = SeqQueueManager.STATUS_BUSY;\n\t\tvar self = this;\n\t\tprocess.nextTick(function() {\n\t\t\tself._next(self.curId);\n\t\t});\n\t}\n\treturn true;\n};\n\n/**\n * Close queue\n * \n * @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue\n */\nSeqQueue.prototype.close = function(force) {\n\tif(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n\t\t//ignore invalid status\n\t\treturn;\n\t}\n\t\n\tif(force) {\n\t\tthis.status = SeqQueueManager.STATUS_DRAINED;\n\t\tif(this.timerId) {\n\t\t\tclearTimeout(this.timerId);\n\t\t\tthis.timerId = undefined;\n\t\t}\n\t\tthis.emit(EVENT_DRAINED);\n\t} else {\n\t\tthis.status = SeqQueueManager.STATUS_CLOSED;\n\t\tthis.emit(EVENT_CLOSED);\n\t}\n};\n\n/**\n * Invoke next task\n * \n * @param {String|Number} tid last executed task id\n * @api private\n */\nSeqQueue.prototype._next = function(tid) {\n\tif(tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {\n\t\t//ignore invalid next call\n\t\treturn;\n\t}\n\t\n\tif(this.timerId) {\n\t\tclearTimeout(this.timerId);\n\t\tthis.timerId = undefined;\n\t}\n\t\n\tvar task = this.queue.shift();\n\tif(!task) {\n\t\tif(this.status === SeqQueueManager.STATUS_BUSY) {\n\t\t\tthis.status = SeqQueueManager.STATUS_IDLE;\n\t\t\tthis.curId++;\t//modify curId to invalidate timeout task\n\t\t} else {\n\t\t\tthis.status = SeqQueueManager.STATUS_DRAINED;\n\t\t\tthis.emit(EVENT_DRAINED);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tvar self = this;\n\ttask.id = ++this.curId;\n\n\tvar timeout = task.timeout > 0 ? task.timeout : this.timeout;\n\ttimeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;\n\tthis.timerId = setTimeout(function() {\n\t\tprocess.nextTick(function() {\n\t\t\tself._next(task.id);\n\t\t});\n\t\tself.emit('timeout', task);\n\t\tif(task.ontimeout) {\n\t\t\ttask.ontimeout();\n\t\t}\n\t}, timeout);\n\n\ttry {\n\t\ttask.fn({\n\t\t\tdone: function() {\n\t\t\t\tvar res = task.id === self.curId;\n\t\t\t\tprocess.nextTick(function() {\n\t\t\t\t\tself._next(task.id);\n\t\t\t\t});\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t} catch(err) {\n\t\tself.emit('error', err, task);\n\t\tprocess.nextTick(function() {\n\t\t\tself._next(task.id);\n\t\t});\n\t}\n};\n\n/**\n * Queue manager.\n * \n * @module\n */\nvar SeqQueueManager = module.exports;\n\n/**\n * Queue status: idle, welcome new tasks\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_IDLE = 0;\n\n/**\n * Queue status: busy, queue is working for some tasks now\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_BUSY = 1;\n\n/**\n * Queue status: closed, queue has closed and would not receive task any more \n * \t\t\t\t\tand is processing the remaining tasks now.\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_CLOSED = 2; \n\n/**\n * Queue status: drained, queue is ready to be destroy\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_DRAINED = 3;\n\n/**\n * Create Sequence queue\n * \n * @param  {Number} timeout a global timeout for the new queue instance\n * @return {Object}         new queue instance\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.createQueue = function(timeout) {\n\treturn new SeqQueue(timeout);\n};"]},"metadata":{},"sourceType":"script"}