{"ast":null,"code":"'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\n\nconst NativeBuffer = require('buffer').Buffer;\n\nconst Long = require('long');\n\nconst StringParser = require('../parsers/string.js');\n\nconst INVALID_DATE = new Date(NaN); // this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\n\nconst pad = '000000000000';\n\nfunction leftPad(num, value) {\n  const s = value.toString(); // if we don't need to pad\n\n  if (s.length >= num) {\n    return s;\n  }\n\n  return (pad + s).slice(-num);\n} // The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0); // TODO: handle E notation\n\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  } // ==============================\n  // readers\n  // ==============================\n\n\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n\n    if (byte1 < 251) {\n      return byte1;\n    }\n\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n\n    if (tag === 0xfb) {\n      return null;\n    }\n\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n\n      res = new Long(word0, word1, !signed); // Long need unsigned\n\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    } // eslint-disable-next-line no-console\n\n\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  } // DATE, DATETIME and TIMESTAMP\n\n\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n\n      if (length === 0xfb) {\n        return null;\n      }\n\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n\n    let str = this.readDateTimeString(6, 'T');\n\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':')}`;\n    }\n\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n\n      if (decimals) {\n        ms = leftPad(6, ms);\n\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n\n      str += ms;\n    }\n\n    return str;\n  } // TIME - value as a string, Can be negative\n\n\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n\n    if (length === 0) {\n      return '00:00:00';\n    }\n\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n\n    return (sign === -1 ? '-' : '') + [d ? d * 24 + H : H, leftPad(2, M), leftPad(2, S)].join(':') + (ms ? `.${ms}` : '');\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber(); // TODO: check manually first byte here to avoid polymorphic return type?\n\n    if (len === null) {\n      return null;\n    }\n\n    this.offset += len; // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n\n    return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n\n    if (len === null) {\n      return null;\n    }\n\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer.slice(start, end), encoding);\n  } // TODO reuse?\n\n\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n\n    this.offset += len;\n    return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    } // max precise int is 9007199254740992\n\n\n    let str;\n    const numDigits = end - this.offset;\n\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n\n        if (result.toString() === str) {\n          return sign * result;\n        }\n\n        return sign === -1 ? `-${str}` : str;\n      }\n\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n\n    const num = result * sign;\n\n    if (!supportBigNumbers) {\n      return num;\n    }\n\n    str = this.buffer.toString('ascii', start, end);\n\n    if (num.toString() === str) {\n      return num;\n    }\n\n    return str;\n  } // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n\n\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n\n    return result * sign;\n  } // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n\n\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n      offset += 4;\n\n      switch (wkbType) {\n        case 1:\n          // WKBPoint\n          x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = {\n            x: x,\n            y: y\n          };\n          break;\n\n        case 2:\n          // WKBLineString\n          numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({\n              x: x,\n              y: y\n            });\n          }\n\n          break;\n\n        case 3:\n          // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({\n                x: x,\n                y: y\n              });\n            }\n\n            result.push(line);\n          }\n\n          break;\n\n        case 4: // WKBMultiPoint\n\n        case 5: // WKBMultiLineString\n\n        case 6: // WKBMultiPolygon\n\n        case 7:\n          // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n\n          break;\n      }\n\n      return result;\n    }\n\n    return parseGeometry();\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n\n    if (strLen === null) {\n      return null;\n    }\n\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n\n    const y = this.parseInt(4);\n    this.offset++; // -\n\n    const m = this.parseInt(2);\n    this.offset++; // -\n\n    const d = this.parseInt(2);\n\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n\n    return new Date(`${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`);\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n\n    if (str === null) {\n      return null;\n    }\n\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n\n    return new Date(`${str}${timezone}`);\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return result / factor * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  } // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n\n\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n\n    const errorCode = this.readInt16();\n    let sqlState = '';\n\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  } // TODO: refactor following three?\n\n\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n\n    if (s.length === 0) {\n      return;\n    } // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n\n\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    } // TODO: check that n is out of int precision\n\n\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));\n\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n\n    if (this.isError()) {\n      return 'Error';\n    }\n\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n\n    if (n < 0xffff) {\n      return 3;\n    }\n\n    if (n < 0xffffff) {\n      return 5;\n    }\n\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function () {};\n\n    const res = Buffer.alloc(0);\n\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n\n    return res;\n  }\n\n}\n\nmodule.exports = Packet;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/mysql2/lib/packets/packet.js"],"names":["ErrorCodeToName","require","NativeBuffer","Buffer","Long","StringParser","INVALID_DATE","Date","NaN","pad","leftPad","num","value","s","toString","length","slice","minus","charCodeAt","plus","dot","exponent","exponentCapital","Packet","constructor","id","buffer","start","end","sequenceId","numPackets","offset","reset","dump","console","log","asciiSlice","haveMoreData","skip","readInt8","readInt16","readUInt16LE","readInt24","readInt32","readUInt32LE","readSInt8","readSInt16","readInt16LE","readSInt32","readInt32LE","readInt64JSNumber","word0","word1","l","toNumber","readSInt64JSNumber","readInt64String","res","readSInt64String","readInt64","resNumber","resString","readSInt64","isEOF","eofStatusFlags","eofWarningCount","readLengthCodedNumber","bigNumberStrings","signed","byte1","readLengthCodedNumberExt","readLengthCodedNumberSigned","tag","trace","Error","readFloat","readFloatLE","readDouble","readDoubleLE","readBuffer","len","readDateTime","timezone","y","m","d","H","M","S","ms","UTC","str","readDateTimeString","decimals","timeSep","join","substring","readTimeString","convertTtoMs","sign","readLengthCodedString","encoding","decode","readLengthCodedBuffer","readNullTerminatedString","readString","undefined","parseInt","supportBigNumbers","Number","result","numDigits","parseIntNoBigCheck","parseGeometryValue","parseGeometry","x","i","j","numPoints","line","byteOrder","readUInt8","wkbType","readUInt32BE","readDoubleBE","push","numRings","parseDate","strLen","parseDateTime","parseFloat","factor","pastDot","charCode","exponentValue","Math","pow","parseLengthCodedIntNoBigCheck","parseLengthCodedInt","parseLengthCodedIntString","parseLengthCodedFloat","peekByte","isAlt","isError","asError","errorCode","sqlState","message","err","code","errno","sqlMessage","writeInt32","n","writeUInt32LE","writeInt24","writeInt8","writeInt16","writeUInt16LE","writeUInt8","writeDouble","writeDoubleLE","writeBuffer","b","copy","writeNull","writeNullTerminatedString","buf","encode","writeString","writeLengthCodedString","writeLengthCodedNumber","writeLengthCodedBuffer","writeDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","writeHeader","clone","type","lengthCodedNumberLength","lengthCodedStringLength","slen","MockBuffer","noop","alloc","op","prototype","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\nconst NativeBuffer = require('buffer').Buffer;\nconst Long = require('long');\nconst StringParser = require('../parsers/string.js');\n\nconst INVALID_DATE = new Date(NaN);\n\n// this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\nconst pad = '000000000000';\nfunction leftPad(num, value) {\n  const s = value.toString();\n  // if we don't need to pad\n  if (s.length >= num) {\n    return s;\n  }\n  return (pad + s).slice(-num);\n}\n\n// The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\n\n// TODO: handle E notation\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  }\n\n  // ==============================\n  // readers\n  // ==============================\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log(\n      [this.buffer.asciiSlice(this.start, this.end)],\n      this.buffer.slice(this.start, this.end),\n      this.length(),\n      this.sequenceId\n    );\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n    if (byte1 < 251) {\n      return byte1;\n    }\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n    if (tag === 0xfb) {\n      return null;\n    }\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n      res = new Long(word0, word1, !signed); // Long need unsigned\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    }\n    // eslint-disable-next-line no-console\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  }\n\n  // DATE, DATETIME and TIMESTAMP\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n      if (length === 0xfb) {\n        return null;\n      }\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n    let str = this.readDateTimeString(6, 'T');\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[\n        leftPad(2, H),\n        leftPad(2, M),\n        leftPad(2, S)\n      ].join(':')}`;\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n      if (decimals) {\n        ms = leftPad(6, ms);\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n      str += ms;\n    }\n    return str;\n  }\n\n  // TIME - value as a string, Can be negative\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n    if (length === 0) {\n      return '00:00:00';\n    }\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n    return (\n      (sign === -1 ? '-' : '') +\n      [d ? d * 24 + H : H, leftPad(2, M), leftPad(2, S)].join(':') +\n      (ms ? `.${ms}` : '')\n    );\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber();\n    // TODO: check manually first byte here to avoid polymorphic return type?\n    if (len === null) {\n      return null;\n    }\n    this.offset += len;\n    // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n    return StringParser.decode(\n      this.buffer.slice(this.offset - len, this.offset),\n      encoding\n    );\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n    if (len === null) {\n      return null;\n    }\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer.slice(start, end), encoding);\n  }\n\n  // TODO reuse?\n  readString(len, encoding) {\n    if ((typeof len === 'string') && (typeof encoding === 'undefined')) {\n      encoding = len\n      len = undefined\n    }\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return StringParser.decode(\n      this.buffer.slice(this.offset - len, this.offset),\n      encoding\n    );\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    // max precise int is 9007199254740992\n    let str;\n    const numDigits = end - this.offset;\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n        if (result.toString() === str) {\n          return sign * result;\n        }\n        return sign === -1 ? `-${str}` : str;\n      }\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    const num = result * sign;\n    if (!supportBigNumbers) {\n      return num;\n    }\n    str = this.buffer.toString('ascii', start, end);\n    if (num.toString() === str) {\n      return num;\n    }\n    return str;\n  }\n\n  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    return result * sign;\n  }\n\n  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder\n        ? buffer.readUInt32LE(offset)\n        : buffer.readUInt32BE(offset);\n      offset += 4;\n      switch (wkbType) {\n        case 1: // WKBPoint\n          x = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = { x: x, y: y };\n          break;\n        case 2: // WKBLineString\n          numPoints = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({ x: x, y: y });\n          }\n          break;\n        case 3: // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder\n              ? buffer.readUInt32LE(offset)\n              : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({ x: x, y: y });\n            }\n            result.push(line);\n          }\n          break;\n        case 4: // WKBMultiPoint\n        case 5: // WKBMultiLineString\n        case 6: // WKBMultiPolygon\n        case 7: // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n          break;\n      }\n      return result;\n    }\n    return parseGeometry();\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n    if (strLen === null) {\n      return null;\n    }\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n    const y = this.parseInt(4);\n    this.offset++; // -\n    const m = this.parseInt(2);\n    this.offset++; // -\n    const d = this.parseInt(2);\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n    return new Date(\n      `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`\n    );\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n    if (str === null) {\n      return null;\n    }\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n    return new Date(`${str}${timezone}`);\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return (result / factor) * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  }\n\n  // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n    const errorCode = this.readInt16();\n    let sqlState = '';\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  }\n\n  // TODO: refactor following three?\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n    if (s.length === 0) {\n      return;\n    }\n    // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    }\n    // TODO: check that n is out of int precision\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset =\n          (timezone[0] === '-' ? -1 : 1) *\n          (parseInt(timezone.substring(1, 3), 10) * 60 +\n            parseInt(timezone.substring(4), 10));\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n    if (this.isError()) {\n      return 'Error';\n    }\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n    if (n < 0xffff) {\n      return 3;\n    }\n    if (n < 0xffffff) {\n      return 5;\n    }\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function() {};\n    const res = Buffer.alloc(0);\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n    return res;\n  }\n}\n\nmodule.exports = Packet;\n"]},"metadata":{},"sourceType":"script"}