{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nfunction checkNamingCollision(association) {\n  if (association.source.rawAttributes.hasOwnProperty(association.as)) {\n    throw new Error('Naming collision between attribute \\'' + association.as + '\\' and association \\'' + association.as + '\\' on model ' + association.source.name + '. To remedy this, change either foreignKey or as in your association definition');\n  }\n}\n\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behaviour\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = _.chain(source.rawAttributes).keys().filter(key => source.rawAttributes[key].primaryKey).map(key => source.rawAttributes[key].field || key).value();\n\n    if (primaryKeys.length === 1) {\n      if (source._schema) {\n        newAttribute.references = {\n          model: source.sequelize.getQueryInterface().QueryGenerator.addSchema({\n            tableName: source.tableName,\n            _schema: source._schema,\n            _schemaDelimiter: source._schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = {\n          model: source.tableName\n        };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\n\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n * @param {Object} Association instance\n * @param {Object} Model prototype\n * @param {Array} Method names to inject\n * @param {Object} Mapping between model and association method names\n */\n\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!obj[association.accessors[method]]) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function () {\n        const instance = this;\n        const args = [instance].concat(Array.from(arguments));\n        return association[realMethod].apply(association, args);\n      };\n    }\n  }\n}\n\nexports.mixinMethods = mixinMethods;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/associations/helpers.js"],"names":["_","require","checkNamingCollision","association","source","rawAttributes","hasOwnProperty","as","Error","name","exports","addForeignKeyConstraints","newAttribute","target","options","key","foreignKeyConstraint","onDelete","onUpdate","primaryKeys","chain","keys","filter","primaryKey","map","field","value","length","_schema","references","model","sequelize","getQueryInterface","QueryGenerator","addSchema","tableName","_schemaDelimiter","mixinMethods","obj","methods","aliases","method","accessors","realMethod","instance","args","concat","Array","from","arguments","apply"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nfunction checkNamingCollision(association) {\n  if (association.source.rawAttributes.hasOwnProperty(association.as)) {\n    throw new Error(\n      'Naming collision between attribute \\'' + association.as +\n      '\\' and association \\'' + association.as + '\\' on model ' + association.source.name +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behaviour\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = _.chain(source.rawAttributes).keys()\n      .filter(key => source.rawAttributes[key].primaryKey)\n      .map(key => source.rawAttributes[key].field || key).value();\n\n    if (primaryKeys.length === 1) {\n      if (source._schema) {\n        newAttribute.references = {\n          model: source.sequelize.getQueryInterface().QueryGenerator.addSchema({\n            tableName: source.tableName,\n            _schema: source._schema,\n            _schemaDelimiter: source._schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = { model: source.tableName };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n * @param {Object} Association instance\n * @param {Object} Model prototype\n * @param {Array} Method names to inject\n * @param {Object} Mapping between model and association method names\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!obj[association.accessors[method]]) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        const instance = this;\n        const args = [instance].concat(Array.from(arguments));\n\n        return association[realMethod].apply(association, args);\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n"]},"metadata":{},"sourceType":"script"}