{"ast":null,"code":"'use strict';\n\nconst Readable = require('stream').Readable;\n\nconst Command = require('./command.js');\n\nconst Packets = require('../packets/index.js');\n\nconst getTextParser = require('../parsers/text_parser.js');\n\nconst ServerStatus = require('../constants/server_status.js');\n\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nconst EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4); // http://dev.mysql.com/doc/internals/en/com-query.html\n\nclass Query extends Command {\n  constructor(options, callback) {\n    super();\n    this.sql = options.sql;\n    this.values = options.values;\n    this._queryOptions = options;\n    this.namedPlaceholders = options.namedPlaceholders || false;\n    this.onResult = callback;\n    this._fieldCount = 0;\n    this._rowParser = null;\n    this._fields = [];\n    this._rows = [];\n    this._receivedFieldsCount = 0;\n    this._resultIndex = 0;\n    this._localStream = null;\n\n    this._unpipeStream = function () {};\n\n    this._streamFactory = options.infileStreamFactory;\n    this._connection = null;\n  }\n\n  then() {\n    const err = \"You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://www.npmjs.com/package/mysql2#using-promise-wrapper, or the mysql2 documentation at https://github.com/sidorares/node-mysql2/tree/master/documentation/Promise-Wrapper.md\"; // eslint-disable-next-line\n\n    console.log(err);\n    throw new Error(err);\n  }\n\n  start(packet, connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('        Sending query command: %s', this.sql);\n    }\n\n    this._connection = connection;\n    this.options = Object.assign({}, connection.config, this._queryOptions);\n    const cmdPacket = new Packets.Query(this.sql, connection.config.charsetNumber);\n    connection.writePacket(cmdPacket.toPacket(1));\n    return Query.prototype.resultsetHeader;\n  }\n\n  done() {\n    this._unpipeStream();\n\n    if (this.onResult) {\n      let rows, fields;\n\n      if (this._resultIndex === 0) {\n        rows = this._rows[0];\n        fields = this._fields[0];\n      } else {\n        rows = this._rows;\n        fields = this._fields;\n      }\n\n      if (fields) {\n        process.nextTick(() => {\n          this.onResult(null, rows, fields);\n        });\n      } else {\n        process.nextTick(() => {\n          this.onResult(null, rows);\n        });\n      }\n    }\n\n    return null;\n  }\n\n  doneInsert(rs) {\n    if (this._localStreamError) {\n      if (this.onResult) {\n        this.onResult(this._localStreamError, rs);\n      } else {\n        this.emit('error', this._localStreamError);\n      }\n\n      return null;\n    }\n\n    this._rows.push(rs);\n\n    this._fields.push(void 0);\n\n    this.emit('fields', void 0);\n    this.emit('result', rs);\n\n    if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {\n      this._resultIndex++;\n      return this.resultsetHeader;\n    }\n\n    return this.done();\n  }\n\n  resultsetHeader(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    this._fieldCount = rs.fieldCount;\n\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(`        Resultset header received, expecting ${rs.fieldCount} column definition packets`);\n    }\n\n    if (this._fieldCount === 0) {\n      return this.doneInsert(rs);\n    }\n\n    if (this._fieldCount === null) {\n      return this._streamLocalInfile(connection, rs.infileName);\n    }\n\n    this._receivedFieldsCount = 0;\n\n    this._rows.push([]);\n\n    this._fields.push([]);\n\n    return this.readField;\n  }\n\n  _streamLocalInfile(connection, path) {\n    if (this._streamFactory) {\n      this._localStream = this._streamFactory(path);\n    } else {\n      this._localStreamError = new Error(`As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`);\n      connection.writePacket(EmptyPacket);\n      return this.infileOk;\n    }\n\n    const onConnectionError = () => {\n      this._unpipeStream();\n    };\n\n    const onDrain = () => {\n      this._localStream.resume();\n    };\n\n    const onPause = () => {\n      this._localStream.pause();\n    };\n\n    const onData = function (data) {\n      const dataWithHeader = Buffer.allocUnsafe(data.length + 4);\n      data.copy(dataWithHeader, 4);\n      connection.writePacket(new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length));\n    };\n\n    const onEnd = () => {\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n\n    const onError = err => {\n      this._localStreamError = err;\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n\n    this._unpipeStream = () => {\n      connection.stream.removeListener('pause', onPause);\n      connection.stream.removeListener('drain', onDrain);\n\n      this._localStream.removeListener('data', onData);\n\n      this._localStream.removeListener('end', onEnd);\n\n      this._localStream.removeListener('error', onError);\n    };\n\n    connection.stream.on('pause', onPause);\n    connection.stream.on('drain', onDrain);\n\n    this._localStream.on('data', onData);\n\n    this._localStream.on('end', onEnd);\n\n    this._localStream.on('error', onError);\n\n    connection.once('error', onConnectionError);\n    return this.infileOk;\n  }\n\n  readField(packet, connection) {\n    this._receivedFieldsCount++; // Often there is much more data in the column definition than in the row itself\n    // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)\n    // you can 'cache' result of parsing. Field packets still received, but ignored in that case\n    // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)\n\n    if (this._fields[this._resultIndex].length !== this._fieldCount) {\n      const field = new Packets.ColumnDefinition(packet, connection.clientEncoding);\n\n      this._fields[this._resultIndex].push(field);\n\n      if (connection.config.debug) {\n        /* eslint-disable no-console */\n        console.log('        Column definition:');\n        console.log(`          name: ${field.name}`);\n        console.log(`          type: ${field.columnType}`);\n        console.log(`         flags: ${field.flags}`);\n        /* eslint-enable no-console */\n      }\n    } // last field received\n\n\n    if (this._receivedFieldsCount === this._fieldCount) {\n      const fields = this._fields[this._resultIndex];\n      this.emit('fields', fields);\n      this._rowParser = getTextParser(fields, this.options, connection.config);\n      return Query.prototype.fieldsEOF;\n    }\n\n    return Query.prototype.readField;\n  }\n\n  fieldsEOF(packet, connection) {\n    // check EOF\n    if (!packet.isEOF()) {\n      return connection.protocolError('Expected EOF packet');\n    }\n\n    return this.row;\n  }\n\n  row(packet) {\n    if (packet.isEOF()) {\n      const status = packet.eofStatusFlags();\n      const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;\n\n      if (moreResults) {\n        this._resultIndex++;\n        return Query.prototype.resultsetHeader;\n      }\n\n      return this.done();\n    }\n\n    const row = new this._rowParser(packet, this._fields[this._resultIndex], this.options, CharsetToEncoding);\n\n    if (this.onResult) {\n      this._rows[this._resultIndex].push(row);\n    } else {\n      this.emit('result', row);\n    }\n\n    return Query.prototype.row;\n  }\n\n  infileOk(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    return this.doneInsert(rs);\n  }\n\n  stream(options) {\n    options = options || {};\n    options.objectMode = true;\n    const stream = new Readable(options);\n\n    stream._read = () => {\n      this._connection && this._connection.resume();\n    };\n\n    this.on('result', row => {\n      if (!stream.push(row)) {\n        this._connection.pause();\n      }\n\n      stream.emit('result', row); // replicate old emitter\n    });\n    this.on('error', err => {\n      stream.emit('error', err); // Pass on any errors\n    });\n    this.on('end', () => {\n      stream.push(null); // pushing null, indicating EOF\n\n      stream.emit('close'); // notify readers that query has completed\n    });\n    this.on('fields', fields => {\n      stream.emit('fields', fields); // replicate old emitter\n    });\n    return stream;\n  }\n\n}\n\nQuery.prototype.catch = Query.prototype.then;\nmodule.exports = Query;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/mysql2/lib/commands/query.js"],"names":["Readable","require","Command","Packets","getTextParser","ServerStatus","CharsetToEncoding","EmptyPacket","Packet","Buffer","allocUnsafe","Query","constructor","options","callback","sql","values","_queryOptions","namedPlaceholders","onResult","_fieldCount","_rowParser","_fields","_rows","_receivedFieldsCount","_resultIndex","_localStream","_unpipeStream","_streamFactory","infileStreamFactory","_connection","then","err","console","log","Error","start","packet","connection","config","debug","Object","assign","cmdPacket","charsetNumber","writePacket","toPacket","prototype","resultsetHeader","done","rows","fields","process","nextTick","doneInsert","rs","_localStreamError","emit","push","serverStatus","SERVER_MORE_RESULTS_EXISTS","ResultSetHeader","fieldCount","_streamLocalInfile","infileName","readField","path","infileOk","onConnectionError","onDrain","resume","onPause","pause","onData","data","dataWithHeader","length","copy","onEnd","removeListener","onError","stream","on","once","field","ColumnDefinition","clientEncoding","name","columnType","flags","fieldsEOF","isEOF","protocolError","row","status","eofStatusFlags","moreResults","objectMode","_read","catch","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Readable = require('stream').Readable;\n\nconst Command = require('./command.js');\nconst Packets = require('../packets/index.js');\nconst getTextParser = require('../parsers/text_parser.js');\nconst ServerStatus = require('../constants/server_status.js');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nconst EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4);\n\n// http://dev.mysql.com/doc/internals/en/com-query.html\nclass Query extends Command {\n  constructor(options, callback) {\n    super();\n    this.sql = options.sql;\n    this.values = options.values;\n    this._queryOptions = options;\n    this.namedPlaceholders = options.namedPlaceholders || false;\n    this.onResult = callback;\n    this._fieldCount = 0;\n    this._rowParser = null;\n    this._fields = [];\n    this._rows = [];\n    this._receivedFieldsCount = 0;\n    this._resultIndex = 0;\n    this._localStream = null;\n    this._unpipeStream = function() {};\n    this._streamFactory = options.infileStreamFactory;\n    this._connection = null;\n  }\n\n  then() {\n    const err =\n      \"You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://www.npmjs.com/package/mysql2#using-promise-wrapper, or the mysql2 documentation at https://github.com/sidorares/node-mysql2/tree/master/documentation/Promise-Wrapper.md\";\n    // eslint-disable-next-line\n    console.log(err);\n    throw new Error(err);\n  }\n\n  start(packet, connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('        Sending query command: %s', this.sql);\n    }\n    this._connection = connection;\n    this.options = Object.assign({}, connection.config, this._queryOptions);\n    const cmdPacket = new Packets.Query(\n      this.sql,\n      connection.config.charsetNumber\n    );\n    connection.writePacket(cmdPacket.toPacket(1));\n    return Query.prototype.resultsetHeader;\n  }\n\n  done() {\n    this._unpipeStream();\n    if (this.onResult) {\n      let rows, fields;\n      if (this._resultIndex === 0) {\n        rows = this._rows[0];\n        fields = this._fields[0];\n      } else {\n        rows = this._rows;\n        fields = this._fields;\n      }\n      if (fields) {\n        process.nextTick(() => {\n          this.onResult(null, rows, fields);\n        });\n      } else {\n        process.nextTick(() => {\n          this.onResult(null, rows);\n        });\n      }\n    }\n    return null;\n  }\n\n  doneInsert(rs) {\n    if (this._localStreamError) {\n      if (this.onResult) {\n        this.onResult(this._localStreamError, rs);\n      } else {\n        this.emit('error', this._localStreamError);\n      }\n      return null;\n    }\n    this._rows.push(rs);\n    this._fields.push(void 0);\n    this.emit('fields', void 0);\n    this.emit('result', rs);\n    if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {\n      this._resultIndex++;\n      return this.resultsetHeader;\n    }\n    return this.done();\n  }\n\n  resultsetHeader(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    this._fieldCount = rs.fieldCount;\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        `        Resultset header received, expecting ${rs.fieldCount} column definition packets`\n      );\n    }\n    if (this._fieldCount === 0) {\n      return this.doneInsert(rs);\n    }\n    if (this._fieldCount === null) {\n      return this._streamLocalInfile(connection, rs.infileName);\n    }\n    this._receivedFieldsCount = 0;\n    this._rows.push([]);\n    this._fields.push([]);\n    return this.readField;\n  }\n\n  _streamLocalInfile(connection, path) {\n    if (this._streamFactory) {\n      this._localStream = this._streamFactory(path);\n    } else {\n      this._localStreamError = new Error(\n        `As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`\n      );\n      connection.writePacket(EmptyPacket);\n      return this.infileOk;\n    }\n\n    const onConnectionError = () => {\n      this._unpipeStream();\n    };\n    const onDrain = () => {\n      this._localStream.resume();\n    };\n    const onPause = () => {\n      this._localStream.pause();\n    };\n    const onData = function(data) {\n      const dataWithHeader = Buffer.allocUnsafe(data.length + 4);\n      data.copy(dataWithHeader, 4);\n      connection.writePacket(\n        new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length)\n      );\n    };\n    const onEnd = () => {\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n    const onError = err => {\n      this._localStreamError = err;\n      connection.removeListener('error', onConnectionError);\n      connection.writePacket(EmptyPacket);\n    };\n    this._unpipeStream = () => {\n      connection.stream.removeListener('pause', onPause);\n      connection.stream.removeListener('drain', onDrain);\n      this._localStream.removeListener('data', onData);\n      this._localStream.removeListener('end', onEnd);\n      this._localStream.removeListener('error', onError);\n    };\n    connection.stream.on('pause', onPause);\n    connection.stream.on('drain', onDrain);\n    this._localStream.on('data', onData);\n    this._localStream.on('end', onEnd);\n    this._localStream.on('error', onError);\n    connection.once('error', onConnectionError);\n    return this.infileOk;\n  }\n\n  readField(packet, connection) {\n    this._receivedFieldsCount++;\n    // Often there is much more data in the column definition than in the row itself\n    // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)\n    // you can 'cache' result of parsing. Field packets still received, but ignored in that case\n    // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)\n    if (this._fields[this._resultIndex].length !== this._fieldCount) {\n      const field = new Packets.ColumnDefinition(\n        packet,\n        connection.clientEncoding\n      );\n      this._fields[this._resultIndex].push(field);\n      if (connection.config.debug) {\n        /* eslint-disable no-console */\n        console.log('        Column definition:');\n        console.log(`          name: ${field.name}`);\n        console.log(`          type: ${field.columnType}`);\n        console.log(`         flags: ${field.flags}`);\n        /* eslint-enable no-console */\n      }\n    }\n    // last field received\n    if (this._receivedFieldsCount === this._fieldCount) {\n      const fields = this._fields[this._resultIndex];\n      this.emit('fields', fields);\n      this._rowParser = getTextParser(fields, this.options, connection.config);\n      return Query.prototype.fieldsEOF;\n    }\n    return Query.prototype.readField;\n  }\n\n  fieldsEOF(packet, connection) {\n    // check EOF\n    if (!packet.isEOF()) {\n      return connection.protocolError('Expected EOF packet');\n    }\n    return this.row;\n  }\n\n  row(packet) {\n    if (packet.isEOF()) {\n      const status = packet.eofStatusFlags();\n      const moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;\n      if (moreResults) {\n        this._resultIndex++;\n        return Query.prototype.resultsetHeader;\n      }\n      return this.done();\n    }\n    const row = new this._rowParser(\n      packet,\n      this._fields[this._resultIndex],\n      this.options,\n      CharsetToEncoding\n    );\n    if (this.onResult) {\n      this._rows[this._resultIndex].push(row);\n    } else {\n      this.emit('result', row);\n    }\n    return Query.prototype.row;\n  }\n\n  infileOk(packet, connection) {\n    const rs = new Packets.ResultSetHeader(packet, connection);\n    return this.doneInsert(rs);\n  }\n\n  stream(options) {\n    options = options || {};\n    options.objectMode = true;\n    const stream = new Readable(options);\n    stream._read = () => {\n      this._connection && this._connection.resume();\n    };\n    this.on('result', row => {\n      if (!stream.push(row)) {\n        this._connection.pause();\n      }\n      stream.emit('result', row); // replicate old emitter\n    });\n    this.on('error', err => {\n      stream.emit('error', err); // Pass on any errors\n    });\n    this.on('end', () => {\n      stream.push(null); // pushing null, indicating EOF\n      stream.emit('close'); // notify readers that query has completed\n    });\n    this.on('fields', fields => {\n      stream.emit('fields', fields); // replicate old emitter\n    });\n    return stream;\n  }\n}\n\nQuery.prototype.catch = Query.prototype.then;\n\nmodule.exports = Query;\n"]},"metadata":{},"sourceType":"script"}