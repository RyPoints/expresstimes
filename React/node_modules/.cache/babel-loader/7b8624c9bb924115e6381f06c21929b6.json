{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar xmldom = require('xmldom');\n\nvar xmlutil = require('./xmlutil');\n\nvar Logger = require('./log').Logger;\n\nvar WSTrustVersion = require('./constants').WSTrustVersion;\n\nvar select = xmlutil.xpathSelect;\nvar DOMParser = xmldom.DOMParser; // A regular expression for finding the SAML Assertion in an RSTR.  Used to remove the SAML\n// assertion when logging the RSTR.\n\nvar assertionRegEx = /RequestedSecurityToken.*?((<.*?:Assertion.*?>).*<\\/.*?Assertion>).*?/;\n/**\r\n * Creates a log message that contains the RSTR scrubbed of the actual SAML assertion.\r\n * @private\r\n * @return {string} A log message.\r\n */\n\nfunction scrubRSTRLogMessage(RSTR) {\n  var scrubbedRSTR = null;\n  var singleLineRSTR = RSTR.replace(/(\\r\\n|\\n|\\r)/gm, '');\n  var matchResult = assertionRegEx.exec(singleLineRSTR);\n\n  if (null === matchResult) {\n    // No Assertion was matched so just return the RSTR as is.\n    scrubbedRSTR = singleLineRSTR;\n  } else {\n    var samlAssertion = matchResult[1];\n    var samlAssertionStartTag = matchResult[2];\n    scrubbedRSTR = singleLineRSTR.replace(samlAssertion, samlAssertionStartTag + 'ASSERTION CONTENTS REDACTED</saml:Assertion>');\n  }\n\n  return 'RSTR Response: ' + scrubbedRSTR;\n}\n/**\r\n * Creates a new WSTrustResponse instance.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} response   A soap response from a WS-Trust request.\r\n * @param {sting}  wstrustVersion The version for the WS-Trust request. \r\n */\n\n\nfunction WSTrustResponse(callContext, response, wstrustVersion) {\n  this._log = new Logger('WSTrustResponse', callContext._logContext);\n  this._callContext = callContext;\n  this._response = response;\n  this._dom = null;\n  this._errorCode = null;\n  this._faultMessage = null;\n  this._tokenType = null;\n  this._token = null;\n  this._wstrustVersion = wstrustVersion;\n\n  this._log.verbose(function () {\n    return scrubRSTRLogMessage(response);\n  });\n}\n/**\r\n * If the soap response contained a soap fault then this property will contain the fault\r\n * error code.  Otherwise it will return null\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name errorCode\r\n */\n\n\nObject.defineProperty(WSTrustResponse.prototype, 'errorCode', {\n  get: function () {\n    return this._errorCode;\n  }\n});\n/**\r\n * @property {string} FaultMessage If the soap resopnse contained a soap fault with a fault message then it will\r\n * be returned by this property.\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name faultMessage\r\n */\n\nObject.defineProperty(WSTrustResponse.prototype, 'faultMessage', {\n  get: function () {\n    return this._faultMessage;\n  }\n});\n/**\r\n * @property {string} TokenType If the soap resonse contained a token then this property will contain\r\n * the token type uri\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name tokenType\r\n */\n\nObject.defineProperty(WSTrustResponse.prototype, 'tokenType', {\n  get: function () {\n    return this._tokenType;\n  }\n});\n/**\r\n * @property {string} Token If the soap response contained a token then this property will hold that token.\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name token\r\n */\n\nObject.defineProperty(WSTrustResponse.prototype, 'token', {\n  get: function () {\n    return this._token;\n  }\n}); // Sample error message\n//<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:a=\"http://www.w3.org/2005/08/addressing\" xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">\n//   <s:Header>\n//    <a:Action s:mustUnderstand=\"1\">http://www.w3.org/2005/08/addressing/soap/fault</a:Action>\n//  - <o:Security s:mustUnderstand=\"1\" xmlns:o=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\n//      <u:Timestamp u:Id=\"_0\">\n//      <u:Created>2013-07-30T00:32:21.989Z</u:Created>\n//      <u:Expires>2013-07-30T00:37:21.989Z</u:Expires>\n//      </u:Timestamp>\n//    </o:Security>\n//    </s:Header>\n//  <s:Body>\n//    <s:Fault>\n//      <s:Code>\n//        <s:Value>s:Sender</s:Value>\n//        <s:Subcode>\n//        <s:Value xmlns:a=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">a:RequestFailed</s:Value>\n//        </s:Subcode>\n//      </s:Code>\n//      <s:Reason>\n//      <s:Text xml:lang=\"en-US\">MSIS3127: The specified request failed.</s:Text>\n//      </s:Reason>\n//    </s:Fault>\n// </s:Body>\n//</s:Envelope>\n\n/**\r\n * Attempts to parse an error from the soap response.  If there is one then it\r\n * will fill in the error related properties.  Otherwsie it will do nothing.\r\n * @private\r\n * @returns {bool} true if an error was found and parsed in the response.\r\n */\n\nWSTrustResponse.prototype._parseError = function () {\n  var errorFound = false;\n  var faultNode = select(this._dom, '//s:Envelope/s:Body/s:Fault/s:Reason');\n\n  if (faultNode.length) {\n    this._faultMessage = xmlutil.serializeNodeChildren(faultNode[0]);\n\n    if (this._faultMessage) {\n      errorFound = true;\n    }\n  } // Subcode has minoccurs=0 and maxoccurs=1(default) according to the http://www.w3.org/2003/05/soap-envelope\n  // Subcode may have another subcode as well. This is only targetting at top level subcode.\n  // Subcode value may have different messages not always uses http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd.\n  // text inside the value is not possible to select without prefix, so substring is necessary\n\n\n  var subcodeNode = select(this._dom, '//s:Envelope/s:Body/s:Fault/s:Code/s:Subcode/s:Value');\n\n  if (1 < subcodeNode.length) {\n    throw this._log.createError('Found too many fault code values:' + subcodeNode.length);\n  }\n\n  if (subcodeNode.length) {\n    var errorCode = subcodeNode[0].firstChild.data;\n    this._errorCode = errorCode.split(':')[1];\n    errorFound = true;\n  }\n\n  return errorFound;\n};\n/**\r\n * Attempts to parse a token from the soap response.  If there is one then it will fill in the\r\n * token related properties.  Otherwise it does nothing.\r\n * @private\r\n * @throws {Error} If the response is not parseable, or too many tokens are found.\r\n */\n\n\nWSTrustResponse.prototype._parseToken = function () {\n  var xPath = this._wstrustVersion === WSTrustVersion.WSTRUST2005 ? '//s:Envelope/s:Body/t:RequestSecurityTokenResponse/t:TokenType' : '//s:Envelope/s:Body/wst:RequestSecurityTokenResponseCollection/wst:RequestSecurityTokenResponse/wst:TokenType';\n  var tokenTypeNodes = select(this._dom, xPath);\n\n  if (!tokenTypeNodes.length) {\n    this._log.warn('No TokenType elements found in RSTR');\n  }\n\n  for (var i = 0, length = tokenTypeNodes.length; i < length; i++) {\n    if (this._token) {\n      this._log.warn('Found more than one returned token.  Using the first.');\n\n      break;\n    }\n\n    var tokenTypeNode = tokenTypeNodes[i];\n    var tokenType = xmlutil.findElementText(tokenTypeNode);\n\n    if (!tokenType) {\n      this._log.warn('Could not find token type in RSTR token');\n    }\n\n    var securityTokenPath = this._wstrustVersion === WSTrustVersion.WSTRUST2005 ? 't:RequestedSecurityToken' : 'wst:RequestedSecurityToken';\n    var requestedTokenNode = select(tokenTypeNode.parentNode, securityTokenPath);\n\n    if (1 < requestedTokenNode) {\n      throw this._log.createError('Found too many RequestedSecurityToken nodes for token type: ' + tokenType);\n    }\n\n    if (!requestedTokenNode.length) {\n      this._log.warn('Unable to find RequestsSecurityToken element associated with TokenType element: ' + tokenType);\n\n      continue;\n    }\n\n    var token = xmlutil.serializeNodeChildren(requestedTokenNode[0]);\n\n    if (!token) {\n      this._log.warn('Unable to find token associated with TokenType element: ' + tokenType);\n\n      continue;\n    }\n\n    this._token = token;\n    this._tokenType = tokenType;\n\n    this._log.info('Found token of type: ' + this._tokenType);\n  }\n\n  if (!this._token) {\n    throw this._log.createError('Unable to find any tokens in RSTR.');\n  }\n};\n/**\r\n * This method parses the soap response that was passed in at construction.\r\n * @throws {Error} If the server returned an error, or there was any failure to parse the response.\r\n */\n\n\nWSTrustResponse.prototype.parse = function () {\n  if (!this._response) {\n    throw this._log.createError('Received empty RSTR response body.');\n  }\n\n  try {\n    try {\n      var options = {\n        errorHandler: this._log.error\n      };\n      this._dom = new DOMParser(options).parseFromString(this._response);\n    } catch (err) {\n      throw this._log.createError('Failed to parse RSTR in to DOM', err, true);\n    }\n\n    var errorFound = this._parseError();\n\n    if (errorFound) {\n      var stringErrorCode = this.ErrorCode || 'NONE';\n      var stringFaultMessage = this.FaultMessage || 'NONE';\n      throw this._log.createError('Server returned error in RSTR - ErrorCode: ' + stringErrorCode + ' : FaultMessage: ' + stringFaultMessage, true);\n    }\n\n    this._parseToken();\n  } catch (err) {\n    delete this._dom;\n    throw err;\n  }\n};\n\nmodule.exports = WSTrustResponse;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/adal-node/lib/wstrust-response.js"],"names":["xmldom","require","xmlutil","Logger","WSTrustVersion","select","xpathSelect","DOMParser","assertionRegEx","scrubRSTRLogMessage","RSTR","scrubbedRSTR","singleLineRSTR","replace","matchResult","exec","samlAssertion","samlAssertionStartTag","WSTrustResponse","callContext","response","wstrustVersion","_log","_logContext","_callContext","_response","_dom","_errorCode","_faultMessage","_tokenType","_token","_wstrustVersion","verbose","Object","defineProperty","prototype","get","_parseError","errorFound","faultNode","length","serializeNodeChildren","subcodeNode","createError","errorCode","firstChild","data","split","_parseToken","xPath","WSTRUST2005","tokenTypeNodes","warn","i","tokenTypeNode","tokenType","findElementText","securityTokenPath","requestedTokenNode","parentNode","token","info","parse","options","errorHandler","error","parseFromString","err","stringErrorCode","ErrorCode","stringFaultMessage","FaultMessage","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n'use strict';\r\n\r\nvar xmldom = require('xmldom');\r\n\r\nvar xmlutil = require('./xmlutil');\r\n\r\nvar Logger = require('./log').Logger;\r\n\r\nvar WSTrustVersion = require('./constants').WSTrustVersion;\r\n\r\nvar select = xmlutil.xpathSelect;\r\nvar DOMParser = xmldom.DOMParser;\r\n\r\n// A regular expression for finding the SAML Assertion in an RSTR.  Used to remove the SAML\r\n// assertion when logging the RSTR.\r\nvar assertionRegEx = /RequestedSecurityToken.*?((<.*?:Assertion.*?>).*<\\/.*?Assertion>).*?/;\r\n\r\n/**\r\n * Creates a log message that contains the RSTR scrubbed of the actual SAML assertion.\r\n * @private\r\n * @return {string} A log message.\r\n */\r\nfunction scrubRSTRLogMessage(RSTR) {\r\n  var scrubbedRSTR = null;\r\n\r\n  var singleLineRSTR = RSTR.replace(/(\\r\\n|\\n|\\r)/gm,'');\r\n\r\n  var matchResult = assertionRegEx.exec(singleLineRSTR);\r\n  if (null === matchResult) {\r\n    // No Assertion was matched so just return the RSTR as is.\r\n    scrubbedRSTR = singleLineRSTR;\r\n  } else {\r\n    var samlAssertion = matchResult[1];\r\n    var samlAssertionStartTag = matchResult[2];\r\n\r\n    scrubbedRSTR = singleLineRSTR.replace(samlAssertion, samlAssertionStartTag + 'ASSERTION CONTENTS REDACTED</saml:Assertion>');\r\n  }\r\n\r\n  return 'RSTR Response: ' + scrubbedRSTR;\r\n}\r\n\r\n/**\r\n * Creates a new WSTrustResponse instance.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} response   A soap response from a WS-Trust request.\r\n * @param {sting}  wstrustVersion The version for the WS-Trust request. \r\n */\r\nfunction WSTrustResponse(callContext, response, wstrustVersion) {\r\n  this._log = new Logger('WSTrustResponse', callContext._logContext);\r\n  this._callContext = callContext;\r\n  this._response = response;\r\n  this._dom = null;\r\n  this._errorCode = null;\r\n  this._faultMessage = null;\r\n  this._tokenType = null;\r\n  this._token = null;\r\n  this._wstrustVersion = wstrustVersion;\r\n\r\n  this._log.verbose(function(){return scrubRSTRLogMessage(response);});\r\n}\r\n\r\n/**\r\n * If the soap response contained a soap fault then this property will contain the fault\r\n * error code.  Otherwise it will return null\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name errorCode\r\n */\r\nObject.defineProperty(WSTrustResponse.prototype, 'errorCode', {\r\n  get: function() {\r\n    return this._errorCode;\r\n  }\r\n});\r\n\r\n/**\r\n * @property {string} FaultMessage If the soap resopnse contained a soap fault with a fault message then it will\r\n * be returned by this property.\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name faultMessage\r\n */\r\nObject.defineProperty(WSTrustResponse.prototype, 'faultMessage', {\r\n  get: function() {\r\n    return this._faultMessage;\r\n  }\r\n});\r\n\r\n/**\r\n * @property {string} TokenType If the soap resonse contained a token then this property will contain\r\n * the token type uri\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name tokenType\r\n */\r\nObject.defineProperty(WSTrustResponse.prototype, 'tokenType', {\r\n  get: function() {\r\n    return this._tokenType;\r\n  }\r\n});\r\n\r\n/**\r\n * @property {string} Token If the soap response contained a token then this property will hold that token.\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name token\r\n */\r\nObject.defineProperty(WSTrustResponse.prototype, 'token', {\r\n  get: function() {\r\n    return this._token;\r\n  }\r\n});\r\n\r\n    // Sample error message\r\n    //<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:a=\"http://www.w3.org/2005/08/addressing\" xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">\r\n    //   <s:Header>\r\n    //    <a:Action s:mustUnderstand=\"1\">http://www.w3.org/2005/08/addressing/soap/fault</a:Action>\r\n    //  - <o:Security s:mustUnderstand=\"1\" xmlns:o=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\r\n    //      <u:Timestamp u:Id=\"_0\">\r\n    //      <u:Created>2013-07-30T00:32:21.989Z</u:Created>\r\n    //      <u:Expires>2013-07-30T00:37:21.989Z</u:Expires>\r\n    //      </u:Timestamp>\r\n    //    </o:Security>\r\n    //    </s:Header>\r\n    //  <s:Body>\r\n    //    <s:Fault>\r\n    //      <s:Code>\r\n    //        <s:Value>s:Sender</s:Value>\r\n    //        <s:Subcode>\r\n    //        <s:Value xmlns:a=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">a:RequestFailed</s:Value>\r\n    //        </s:Subcode>\r\n    //      </s:Code>\r\n    //      <s:Reason>\r\n    //      <s:Text xml:lang=\"en-US\">MSIS3127: The specified request failed.</s:Text>\r\n    //      </s:Reason>\r\n    //    </s:Fault>\r\n    // </s:Body>\r\n    //</s:Envelope>\r\n\r\n/**\r\n * Attempts to parse an error from the soap response.  If there is one then it\r\n * will fill in the error related properties.  Otherwsie it will do nothing.\r\n * @private\r\n * @returns {bool} true if an error was found and parsed in the response.\r\n */\r\nWSTrustResponse.prototype._parseError = function() {\r\n  var errorFound = false;\r\n\r\n  var faultNode = select(this._dom, '//s:Envelope/s:Body/s:Fault/s:Reason');\r\n  if (faultNode.length) {\r\n    this._faultMessage = xmlutil.serializeNodeChildren(faultNode[0]);\r\n\r\n    if (this._faultMessage) {\r\n      errorFound = true;\r\n    }\r\n  }\r\n\r\n  // Subcode has minoccurs=0 and maxoccurs=1(default) according to the http://www.w3.org/2003/05/soap-envelope\r\n  // Subcode may have another subcode as well. This is only targetting at top level subcode.\r\n  // Subcode value may have different messages not always uses http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd.\r\n  // text inside the value is not possible to select without prefix, so substring is necessary\r\n  var subcodeNode = select(this._dom, '//s:Envelope/s:Body/s:Fault/s:Code/s:Subcode/s:Value');\r\n  if (1 < subcodeNode.length) {\r\n    throw this._log.createError('Found too many fault code values:' + subcodeNode.length);\r\n  }\r\n\r\n  if (subcodeNode.length) {\r\n    var errorCode = subcodeNode[0].firstChild.data;\r\n    this._errorCode = (errorCode.split(':'))[1];\r\n    errorFound = true;\r\n  }\r\n\r\n  return errorFound;\r\n};\r\n\r\n/**\r\n * Attempts to parse a token from the soap response.  If there is one then it will fill in the\r\n * token related properties.  Otherwise it does nothing.\r\n * @private\r\n * @throws {Error} If the response is not parseable, or too many tokens are found.\r\n */\r\nWSTrustResponse.prototype._parseToken = function() {\r\n  var xPath = this._wstrustVersion === WSTrustVersion.WSTRUST2005 ? '//s:Envelope/s:Body/t:RequestSecurityTokenResponse/t:TokenType' : '//s:Envelope/s:Body/wst:RequestSecurityTokenResponseCollection/wst:RequestSecurityTokenResponse/wst:TokenType';\r\n\r\n  var tokenTypeNodes = select(this._dom, xPath);\r\n  if (!tokenTypeNodes.length) {\r\n    this._log.warn('No TokenType elements found in RSTR');\r\n  }\r\n\r\n  for (var i = 0, length = tokenTypeNodes.length; i < length; i++) {\r\n    if (this._token) {\r\n      this._log.warn('Found more than one returned token.  Using the first.');\r\n      break;\r\n    }\r\n\r\n    var tokenTypeNode = tokenTypeNodes[i];\r\n    var tokenType = xmlutil.findElementText(tokenTypeNode);\r\n    if (!tokenType) {\r\n      this._log.warn('Could not find token type in RSTR token');\r\n    }\r\n\r\n    var securityTokenPath = this._wstrustVersion === WSTrustVersion.WSTRUST2005 ? 't:RequestedSecurityToken' : 'wst:RequestedSecurityToken';\r\n    var requestedTokenNode = select(tokenTypeNode.parentNode, securityTokenPath);\r\n    if (1 < requestedTokenNode) {\r\n      throw this._log.createError('Found too many RequestedSecurityToken nodes for token type: ' + tokenType);\r\n    }\r\n    if (!requestedTokenNode.length) {\r\n      this._log.warn('Unable to find RequestsSecurityToken element associated with TokenType element: ' + tokenType);\r\n      continue;\r\n    }\r\n\r\n    var token = xmlutil.serializeNodeChildren(requestedTokenNode[0]);\r\n    if (!token) {\r\n      this._log.warn('Unable to find token associated with TokenType element: ' + tokenType);\r\n      continue;\r\n    }\r\n\r\n    this._token = token;\r\n    this._tokenType = tokenType;\r\n\r\n    this._log.info('Found token of type: ' + this._tokenType);\r\n  }\r\n\r\n  if (!this._token) {\r\n    throw this._log.createError('Unable to find any tokens in RSTR.');\r\n  }\r\n};\r\n\r\n/**\r\n * This method parses the soap response that was passed in at construction.\r\n * @throws {Error} If the server returned an error, or there was any failure to parse the response.\r\n */\r\nWSTrustResponse.prototype.parse = function() {\r\n  if (!this._response) {\r\n    throw this._log.createError('Received empty RSTR response body.');\r\n  }\r\n\r\n  try {\r\n    try {\r\n      var options = {\r\n        errorHandler : this._log.error\r\n      };\r\n      this._dom = new DOMParser(options).parseFromString(this._response);\r\n    } catch (err) {\r\n      throw this._log.createError('Failed to parse RSTR in to DOM', err, true);\r\n    }\r\n\r\n    var errorFound = this._parseError();\r\n\r\n    if (errorFound) {\r\n      var stringErrorCode = this.ErrorCode || 'NONE';\r\n      var stringFaultMessage = this.FaultMessage || 'NONE';\r\n      throw this._log.createError('Server returned error in RSTR - ErrorCode: ' + stringErrorCode + ' : FaultMessage: ' + stringFaultMessage, true);\r\n    }\r\n\r\n    this._parseToken();\r\n  } catch (err) {\r\n    delete this._dom;\r\n    throw err;\r\n  }\r\n};\r\n\r\nmodule.exports = WSTrustResponse;"]},"metadata":{},"sourceType":"script"}