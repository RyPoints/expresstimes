{"ast":null,"code":"'use strict'; // based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\n\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,\n      DQUOTE = 34,\n      SQUOTE = 39,\n      BSLASH = 92;\n\nfunction parse(query) {\n  let ppos = RE_PARAM.exec(query);\n  let curpos = 0;\n  let start = 0;\n  let end;\n  const parts = [];\n  let inQuote = false;\n  let escape = false;\n  let qchr;\n  const tokens = [];\n  let qcnt = 0;\n  let lastTokenEndPos = 0;\n  let i;\n\n  if (ppos) {\n    do {\n      for (i = curpos, end = ppos.index; i < end; ++i) {\n        let chr = query.charCodeAt(i);\n        if (chr === BSLASH) escape = !escape;else {\n          if (escape) {\n            escape = false;\n            continue;\n          }\n\n          if (inQuote && chr === qchr) {\n            if (query.charCodeAt(i + 1) === qchr) {\n              // quote escaped via \"\" or ''\n              ++i;\n              continue;\n            }\n\n            inQuote = false;\n          } else if (chr === DQUOTE || chr === SQUOTE) {\n            inQuote = true;\n            qchr = chr;\n          }\n        }\n      }\n\n      if (!inQuote) {\n        parts.push(query.substring(start, end));\n        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n        start = end + ppos[0].length;\n        lastTokenEndPos = start;\n      }\n\n      curpos = end + ppos[0].length;\n    } while (ppos = RE_PARAM.exec(query));\n\n    if (tokens.length) {\n      if (curpos < query.length) {\n        parts.push(query.substring(lastTokenEndPos));\n      }\n\n      return [parts, tokens];\n    }\n  }\n\n  return [query];\n}\n\n;\n\nconst EMPTY_LRU_FN = (key, value) => {};\n\nfunction createCompiler(config) {\n  if (!config) config = {};\n\n  if (!config.placeholder) {\n    config.placeholder = '?';\n  }\n\n  let ncache = 100;\n  let cache;\n\n  if (typeof config.cache === 'number') {\n    ncache = config.cache;\n  }\n\n  if (typeof config.cache === 'object') {\n    cache = config.cache;\n  }\n\n  if (config.cache !== false && !cache) {\n    cache = require('lru-cache')({\n      max: ncache,\n      dispose: EMPTY_LRU_FN\n    });\n  }\n\n  function toArrayParams(tree, params) {\n    const arr = [];\n\n    if (tree.length == 1) {\n      return [tree[0], []];\n    }\n\n    if (typeof params == 'undefined') throw new Error('Named query contains placeholders, but parameters object is undefined');\n    const tokens = tree[1];\n\n    for (let i = 0; i < tokens.length; ++i) {\n      arr.push(params[tokens[i]]);\n    }\n\n    return [tree[0], arr];\n  }\n\n  function noTailingSemicolon(s) {\n    if (s.slice(-1) == ':') {\n      return s.slice(0, -1);\n    }\n\n    return s;\n  }\n\n  function join(tree) {\n    if (tree.length == 1) {\n      return tree;\n    }\n\n    let unnamed = noTailingSemicolon(tree[0][0]);\n\n    for (let i = 1; i < tree[0].length; ++i) {\n      if (tree[0][i - 1].slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n\n      unnamed += config.placeholder;\n      unnamed += noTailingSemicolon(tree[0][i]);\n    }\n\n    const last = tree[0][tree[0].length - 1];\n\n    if (tree[0].length == tree[1].length) {\n      if (last.slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n\n      unnamed += config.placeholder;\n    }\n\n    return [unnamed, tree[1]];\n  }\n\n  function compile(query, paramsObj) {\n    let tree;\n\n    if (cache && (tree = cache.get(query))) {\n      return toArrayParams(tree, paramsObj);\n    }\n\n    tree = join(parse(query));\n\n    if (cache) {\n      cache.set(query, tree);\n    }\n\n    return toArrayParams(tree, paramsObj);\n  }\n\n  compile.parse = parse;\n  return compile;\n} // named :one :two to postgres-style numbered $1 $2 $3\n\n\nfunction toNumbered(q, params) {\n  const tree = parse(q);\n  const paramsArr = [];\n\n  if (tree.length == 1) {\n    return [tree[0], paramsArr];\n  }\n\n  const pIndexes = {};\n  let pLastIndex = 0;\n  let qs = '';\n  let varIndex;\n  const varNames = [];\n\n  for (let i = 0; i < tree[0].length; ++i) {\n    varIndex = pIndexes[tree[1][i]];\n\n    if (!varIndex) {\n      varIndex = ++pLastIndex;\n      pIndexes[tree[1][i]] = varIndex;\n    }\n\n    if (tree[1][i]) {\n      varNames[varIndex - 1] = tree[1][i];\n      qs += tree[0][i] + '$' + varIndex;\n    } else {\n      qs += tree[0][i];\n    }\n  }\n\n  return [qs, varNames.map(n => params[n])];\n}\n\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/named-placeholders/index.js"],"names":["RE_PARAM","DQUOTE","SQUOTE","BSLASH","parse","query","ppos","exec","curpos","start","end","parts","inQuote","escape","qchr","tokens","qcnt","lastTokenEndPos","i","index","chr","charCodeAt","push","substring","length","EMPTY_LRU_FN","key","value","createCompiler","config","placeholder","ncache","cache","require","max","dispose","toArrayParams","tree","params","arr","Error","noTailingSemicolon","s","slice","join","unnamed","last","compile","paramsObj","get","set","toNumbered","q","paramsArr","pIndexes","pLastIndex","qs","varIndex","varNames","map","n","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\r\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\r\n\r\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,\r\nDQUOTE = 34,\r\nSQUOTE = 39,\r\nBSLASH = 92;\r\n\r\nfunction parse(query) {\r\n  let ppos = RE_PARAM.exec(query);\r\n  let curpos = 0;\r\n  let start = 0;\r\n  let end;\r\n  const parts = [];\r\n  let inQuote = false;\r\n  let escape = false;\r\n  let qchr;\r\n  const tokens = [];\r\n  let qcnt = 0;\r\n  let lastTokenEndPos = 0;\r\n  let i;\r\n\r\n  if (ppos) {\r\n    do {\r\n      for (i=curpos,end=ppos.index; i<end; ++i) {\r\n        let chr = query.charCodeAt(i);\r\n        if (chr === BSLASH)\r\n        escape = !escape;\r\n        else {\r\n          if (escape) {\r\n            escape = false;\r\n            continue;\r\n          }\r\n          if (inQuote && chr === qchr) {\r\n            if (query.charCodeAt(i + 1) === qchr) {\r\n              // quote escaped via \"\" or ''\r\n              ++i;\r\n              continue;\r\n            }\r\n            inQuote = false;\r\n          } else if (chr === DQUOTE || chr === SQUOTE) {\r\n            inQuote = true;\r\n            qchr = chr;\r\n          }\r\n        }\r\n      }\r\n      if (!inQuote) {\r\n        parts.push(query.substring(start, end));\r\n        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\r\n        start = end + ppos[0].length;\r\n        lastTokenEndPos = start;\r\n      }\r\n      curpos = end + ppos[0].length;\r\n    } while (ppos = RE_PARAM.exec(query));\r\n\r\n    if (tokens.length) {\r\n      if (curpos < query.length) {\r\n        parts.push(query.substring(lastTokenEndPos));\r\n      }\r\n      return [parts, tokens];\r\n    }\r\n  }\r\n  return [query];\r\n};\r\n\r\nconst EMPTY_LRU_FN = (key, value) => {};\r\n\r\nfunction createCompiler(config) {\r\n  if (!config)\r\n  config = {};\r\n  if (!config.placeholder) {\r\n    config.placeholder = '?';\r\n  }\r\n  let ncache = 100;\r\n  let cache;\r\n  if (typeof config.cache === 'number') {\r\n    ncache = config.cache;\r\n  }\r\n  if (typeof config.cache === 'object') {\r\n    cache = config.cache;\r\n  }\r\n  if (config.cache !== false && !cache) {\r\n    cache = require('lru-cache')({ max: ncache, dispose: EMPTY_LRU_FN });\r\n  }\r\n\r\n  function toArrayParams(tree, params) {\r\n    const arr = [];\r\n    if (tree.length == 1) {\r\n      return [tree[0], []];\r\n    }\r\n\r\n    if (typeof params == 'undefined')\r\n      throw new Error('Named query contains placeholders, but parameters object is undefined');\r\n\r\n    const tokens = tree[1];\r\n    for (let i=0; i < tokens.length; ++i) {\r\n      arr.push(params[tokens[i]]);\r\n    }\r\n    return [tree[0], arr];\r\n  }\r\n\r\n  function noTailingSemicolon(s) {\r\n    if (s.slice(-1) == ':') {\r\n      return s.slice(0, -1);\r\n    }\r\n    return s;\r\n  }\r\n\r\n  function join(tree) {\r\n    if (tree.length == 1) {\r\n      return tree;\r\n    }\r\n\r\n    let unnamed = noTailingSemicolon(tree[0][0]);\r\n    for (let i=1; i < tree[0].length; ++i) {\r\n      if (tree[0][i-1].slice(-1) == ':') {\r\n        unnamed += config.placeholder;\r\n      }\r\n      unnamed += config.placeholder;\r\n      unnamed += noTailingSemicolon(tree[0][i]);\r\n    }\r\n\r\n    const last = tree[0][tree[0].length -1];\r\n    if (tree[0].length == tree[1].length) {\r\n      if (last.slice(-1) == ':') {\r\n        unnamed += config.placeholder;\r\n      }\r\n      unnamed += config.placeholder;\r\n    }\r\n    return [unnamed, tree[1]];\r\n  }\r\n\r\n  function compile(query, paramsObj) {\r\n    let tree;\r\n    if (cache && (tree = cache.get(query))) {\r\n      return toArrayParams(tree, paramsObj)\r\n    }\r\n    tree = join(parse(query));\r\n    if(cache) {\r\n      cache.set(query, tree);\r\n    }\r\n    return toArrayParams(tree, paramsObj);\r\n  }\r\n\r\n  compile.parse = parse;\r\n  return compile;\r\n}\r\n\r\n// named :one :two to postgres-style numbered $1 $2 $3\r\nfunction toNumbered(q, params) {\r\n  const tree = parse(q);\r\n  const paramsArr = [];\r\n  if (tree.length == 1) {\r\n    return [tree[0], paramsArr];\r\n  }\r\n\r\n  const pIndexes = {};\r\n  let pLastIndex = 0;\r\n  let qs = '';\r\n  let varIndex;\r\n  const varNames = [];\r\n  for (let i=0; i < tree[0].length; ++i) {\r\n    varIndex = pIndexes[tree[1][i]];\r\n    if (!varIndex) {\r\n      varIndex = ++pLastIndex;\r\n      pIndexes[tree[1][i]] = varIndex;\r\n    }\r\n    if (tree[1][i]) {\r\n      varNames[varIndex - 1] = tree[1][i];\r\n      qs += tree[0][i] + '$' + varIndex;\r\n    } else {\r\n      qs += tree[0][i];\r\n    }\r\n  }\r\n  return [qs, varNames.map(n => params[n])];\r\n}\r\n\r\nmodule.exports = createCompiler;\r\nmodule.exports.toNumbered = toNumbered;\r\n"]},"metadata":{},"sourceType":"script"}