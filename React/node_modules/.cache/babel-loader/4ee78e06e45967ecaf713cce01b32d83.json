{"ast":null,"code":"'use strict';\n\nconst Packet = require('./packets/packet.js');\n\nconst MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    } // array of last payload chunks\n    // only used when current payload is not complete\n\n\n    this.buffer = []; // total length of chunks on buffer\n\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength; // incomplete header state: number of header bytes received\n\n    this.headerLen = 0; // expected payload length\n\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;\n  }\n\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n\n        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n          this.onPacket(new Packet(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n\n          this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));\n\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n\n      this.length = chunk[start];\n\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;\n\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n\n      if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n        this.onPacket(new Packet(sequenceId, payload, 0, this.length + this.packetHeaderLength));\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n\n        this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));\n\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n\n    return null;\n  }\n\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    }\n\n    this.execute = PacketParser.prototype.executeHeader3;\n    return null;\n  }\n\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n\n}\n\nmodule.exports = PacketParser;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/mysql2/lib/packet_parser.js"],"names":["Packet","require","MAX_PACKET_LENGTH","readPacketLength","b","off","b0","b1","b2","PacketParser","constructor","onPacket","packetHeaderLength","buffer","bufferLength","headerLen","length","largePacketParts","firstPacketSequenceId","execute","prototype","executeStart","_flushLargePacket","_flushLargePacket7","_flushLargePacket4","numPackets","unshift","Buffer","from","body","concat","packet","chunk","start","end","sequenceId","push","slice","executePayload","executeHeader3","executeHeader2","remainingPayload","payload","allocUnsafe","offset","i","copy","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Packet = require('./packets/packet.js');\n\nconst MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    }\n    // array of last payload chunks\n    // only used when current payload is not complete\n    this.buffer = [];\n    // total length of chunks on buffer\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength;\n    // incomplete header state: number of header bytes received\n    this.headerLen = 0;\n    // expected payload length\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket =\n      packetHeaderLength === 7\n        ? this._flushLargePacket7\n        : this._flushLargePacket4;\n  }\n\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n        if (\n          this.length < MAX_PACKET_LENGTH &&\n          this.largePacketParts.length === 0\n        ) {\n          this.onPacket(\n            new Packet(\n              sequenceId,\n              chunk,\n              start,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n          this.largePacketParts.push(\n            chunk.slice(\n              start + this.packetHeaderLength,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n      this.length = chunk[start];\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload =\n      this.length - this.bufferLength + this.packetHeaderLength - 3;\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n      if (\n        this.length < MAX_PACKET_LENGTH &&\n        this.largePacketParts.length === 0\n      ) {\n        this.onPacket(\n          new Packet(\n            sequenceId,\n            payload,\n            0,\n            this.length + this.packetHeaderLength\n          )\n        );\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n        this.largePacketParts.push(\n          payload.slice(\n            this.packetHeaderLength,\n            this.packetHeaderLength + this.length\n          )\n        );\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n    return null;\n  }\n\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    } \n    this.execute = PacketParser.prototype.executeHeader3;\n    \n    return null;\n  }\n\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n}\n\nmodule.exports = PacketParser;\n"]},"metadata":{},"sourceType":"script"}