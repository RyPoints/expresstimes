{"ast":null,"code":"'use strict';\n\nconst _require = require('sequelize-pool'),\n      Pool = _require.Pool,\n      TimeoutError = _require.TimeoutError;\n\nconst _ = require('lodash');\n\nconst semver = require('semver');\n\nconst Promise = require('../../promise');\n\nconst errors = require('../../errors');\n\nconst _require2 = require('../../utils/logger'),\n      logger = _require2.logger;\n\nconst debug = logger.debugContext('pool');\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\n\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {Object}\n   */\n\n\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n\n      return require(moduleName);\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n\n\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.destroyAllNow();\n    });\n  }\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n\n\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n\n\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: connection => {\n          return this._disconnect(connection).tap(() => {\n            debug('connection destroy');\n          });\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    } // Map main connection config\n\n\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication')); // Apply defaults to each read config\n\n    config.replication.read = config.replication.read.map(readConfig => _.defaults(readConfig, _.omit(this.config, 'replication'))); // custom pooling for replication (original author @janmeier)\n\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: () => {\n        return Promise.join(this.pool.read.destroyAllNow(), this.pool.write.destroyAllNow()).tap(() => {\n          debug('all connections destroyed');\n        });\n      },\n      drain: () => {\n        return Promise.join(this.pool.write.drain(), this.pool.read.drain());\n      },\n      read: new Pool({\n        name: 'sequelize:read',\n        create: () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          return this._connect(config.replication.read[nextRead]).tap(connection => {\n            connection.queryType = 'read';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: () => {\n          return this._connect(config.replication.write).tap(connection => {\n            connection.queryType = 'write';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n\n\n  getConnection(options) {\n    options = options || {};\n    let promise;\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config).then(connection => {\n          const _options = {};\n          _options.transaction = {\n            connection\n          }; // Cheat .query to use our private connection\n\n          _options.logging = () => {};\n\n          _options.logging.__testLoggingFn = true; //connection might have set databaseVersion value at initialization,\n          //avoiding a useless round trip\n\n          if (this.sequelize.options.databaseVersion === 0) {\n            return this.sequelize.databaseVersion(_options).then(version => {\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.defaultVersion;\n              this.versionPromise = null;\n              return this._disconnect(connection);\n            });\n          }\n\n          this.versionPromise = null;\n          return this._disconnect(connection);\n        }).catch(err => {\n          this.versionPromise = null;\n          throw err;\n        });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.type, options.useMaster).catch(error => {\n        if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n        throw error;\n      });\n    }).tap(() => {\n      debug('connection acquired');\n    });\n  }\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n\n\n  releaseConnection(connection) {\n    return Promise.try(() => {\n      this.pool.release(connection);\n      debug('connection released');\n    });\n  }\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n\n\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config).then(() => this.dialect.connectionManager.connect(config)).then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n\n\n  _disconnect(connection) {\n    return this.sequelize.runHooks('beforeDisconnect', connection).then(() => this.dialect.connectionManager.disconnect(connection)).then(() => this.sequelize.runHooks('afterDisconnect', connection));\n  }\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n\n\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/dialects/abstract/connection-manager.js"],"names":["require","Pool","TimeoutError","_","semver","Promise","errors","logger","debug","debugContext","ConnectionManager","constructor","dialect","sequelize","config","cloneDeep","versionPromise","dialectName","options","pool","Error","defaults","max","min","idle","acquire","evict","validate","_validate","bind","initPools","refreshTypeParser","dataTypes","each","dataType","Object","prototype","hasOwnProperty","call","types","_refreshTypeParser","key","_loadDialectModule","moduleName","dialectModulePath","dialectModule","err","code","_onProcessExit","resolve","drain","then","destroyAllNow","close","getConnection","reject","replication","name","create","_connect","destroy","connection","_disconnect","tap","acquireTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","Array","isArray","read","write","omit","map","readConfig","reads","release","client","queryType","useMaster","undefined","join","nextRead","length","promise","databaseVersion","_options","transaction","logging","__testLoggingFn","version","parsedVersion","get","coerce","valid","defaultVersion","catch","type","error","ConnectionAcquireTimeoutError","releaseConnection","try","runHooks","connectionManager","connect","return","disconnect","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { Pool, TimeoutError } = require('sequelize-pool');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst Promise = require('../../promise');\nconst errors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('pool');\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {Object}\n   */\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return require(moduleName);\n\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.destroyAllNow();\n    });\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: connection => {\n          return this._disconnect(connection)\n            .tap(() => { debug('connection destroy'); });\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = config.replication.read.map(readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: () => {\n        return Promise.join(\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ).tap(() => { debug('all connections destroyed'); });\n      },\n      drain: () => {\n        return Promise.join(\n          this.pool.write.drain(),\n          this.pool.read.drain()\n        );\n      },\n      read: new Pool({\n        name: 'sequelize:read',\n        create: () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          return this._connect(config.replication.read[nextRead]).tap(connection => {\n            connection.queryType = 'read';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: () => {\n          return this._connect(config.replication.write).tap(connection => {\n            connection.queryType = 'write';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n  getConnection(options) {\n    options = options || {};\n\n    let promise;\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config)\n          .then(connection => {\n            const _options = {};\n\n            _options.transaction = { connection }; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n            if (this.sequelize.options.databaseVersion === 0) {\n              return this.sequelize.databaseVersion(_options).then(version => {\n                const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n                this.sequelize.options.databaseVersion = semver.valid(parsedVersion)\n                  ? parsedVersion\n                  : this.defaultVersion;\n                this.versionPromise = null;\n                return this._disconnect(connection);\n              });\n            }\n\n            this.versionPromise = null;\n            return this._disconnect(connection);\n          }).catch(err => {\n            this.versionPromise = null;\n            throw err;\n          });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.type, options.useMaster)\n        .catch(error => {\n          if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n          throw error;\n        });\n    }).tap(() => { debug('connection acquired'); });\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n  releaseConnection(connection) {\n    return Promise.try(() => {\n      this.pool.release(connection);\n      debug('connection released');\n    });\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config)\n      .then(() => this.dialect.connectionManager.connect(config))\n      .then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  _disconnect(connection) {\n    return this.sequelize.runHooks('beforeDisconnect', connection)\n      .then(() => this.dialect.connectionManager.disconnect(connection))\n      .then(() => this.sequelize.runHooks('afterDisconnect', connection));\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}