{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as tslib_1 from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: function (nextPolicy, options) {\n      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n *\n * @constructor\n * @param {number} retryCount        The client retry count.\n * @param {number} retryInterval     The client retry interval, in milliseconds.\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\n */\n\nvar SystemErrorRetryPolicy =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SystemErrorRetryPolicy, _super);\n\n  function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n\n    _this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\n    _this.DEFAULT_CLIENT_RETRY_COUNT = 3;\n    _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n    _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n    _this.retryCount = typeof retryCount === \"number\" ? retryCount : _this.DEFAULT_CLIENT_RETRY_COUNT;\n    _this.retryInterval = typeof retryInterval === \"number\" ? retryInterval : _this.DEFAULT_CLIENT_RETRY_INTERVAL;\n    _this.minRetryInterval = typeof minRetryInterval === \"number\" ? minRetryInterval : _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    _this.maxRetryInterval = typeof maxRetryInterval === \"number\" ? maxRetryInterval : _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    return _this;\n  }\n\n  SystemErrorRetryPolicy.prototype.sendRequest = function (request) {\n    var _this = this;\n\n    return this._nextPolicy.sendRequest(request.clone()).then(function (response) {\n      return retry(_this, request, response);\n    });\n  };\n\n  return SystemErrorRetryPolicy;\n}(BaseRequestPolicy);\n\nexport { SystemErrorRetryPolicy };\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\n\nfunction shouldRetry(policy, retryData) {\n  var currentCount;\n\n  if (!retryData) {\n    throw new Error(\"retryData for the SystemErrorRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n\n  return currentCount < policy.retryCount;\n}\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {RetryData} retryData  The retry data.\n * @param {object} err        The operation\"s error, if any.\n */\n\n\nfunction updateRetryData(policy, retryData, err) {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  } // Adjust retry count\n\n\n  retryData.retryCount++; // Adjust retry interval\n\n  var incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  var boundedRandDelta = policy.retryInterval * 0.8 + Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n  retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);\n  return retryData;\n}\n\nfunction retry(policy, request, operationResponse, retryData, err) {\n  retryData = updateRetryData(policy, retryData, err);\n\n  if (err && err.code && shouldRetry(policy, retryData) && (err.code === \"ETIMEDOUT\" || err.code === \"ESOCKETTIMEDOUT\" || err.code === \"ECONNREFUSED\" || err.code === \"ECONNRESET\" || err.code === \"ENOENT\")) {\n    // If previous operation ended with an error and the policy allows a retry, do that\n    return utils.delay(retryData.retryInterval).then(function () {\n      return policy._nextPolicy.sendRequest(request.clone());\n    }).then(function (res) {\n      return retry(policy, request, res, retryData, err);\n    }).catch(function (err) {\n      return retry(policy, request, operationResponse, retryData, err);\n    });\n  } else {\n    if (err != undefined) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      err = retryData.error;\n      return Promise.reject(err);\n    }\n\n    return Promise.resolve(operationResponse);\n  }\n}","map":{"version":3,"sources":["../../../lib/policies/systemErrorRetryPolicy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as tslib_1 from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    return {\n        create: function (nextPolicy, options) {\n            return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n        }\n    };\n}\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n *\n * @constructor\n * @param {number} retryCount        The client retry count.\n * @param {number} retryInterval     The client retry interval, in milliseconds.\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\n */\nvar SystemErrorRetryPolicy = /** @class */ (function (_super) {\n    tslib_1.__extends(SystemErrorRetryPolicy, _super);\n    function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n        var _this = _super.call(this, nextPolicy, options) || this;\n        _this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\n        _this.DEFAULT_CLIENT_RETRY_COUNT = 3;\n        _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n        _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n        _this.retryCount = typeof retryCount === \"number\" ? retryCount : _this.DEFAULT_CLIENT_RETRY_COUNT;\n        _this.retryInterval = typeof retryInterval === \"number\" ? retryInterval : _this.DEFAULT_CLIENT_RETRY_INTERVAL;\n        _this.minRetryInterval = typeof minRetryInterval === \"number\" ? minRetryInterval : _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n        _this.maxRetryInterval = typeof maxRetryInterval === \"number\" ? maxRetryInterval : _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n        return _this;\n    }\n    SystemErrorRetryPolicy.prototype.sendRequest = function (request) {\n        var _this = this;\n        return this._nextPolicy.sendRequest(request.clone()).then(function (response) { return retry(_this, request, response); });\n    };\n    return SystemErrorRetryPolicy;\n}(BaseRequestPolicy));\nexport { SystemErrorRetryPolicy };\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(policy, retryData) {\n    var currentCount;\n    if (!retryData) {\n        throw new Error(\"retryData for the SystemErrorRetryPolicyFilter cannot be null.\");\n    }\n    else {\n        currentCount = (retryData && retryData.retryCount);\n    }\n    return (currentCount < policy.retryCount);\n}\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {RetryData} retryData  The retry data.\n * @param {object} err        The operation\"s error, if any.\n */\nfunction updateRetryData(policy, retryData, err) {\n    if (!retryData) {\n        retryData = {\n            retryCount: 0,\n            retryInterval: 0\n        };\n    }\n    if (err) {\n        if (retryData.error) {\n            err.innerError = retryData.error;\n        }\n        retryData.error = err;\n    }\n    // Adjust retry count\n    retryData.retryCount++;\n    // Adjust retry interval\n    var incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n    var boundedRandDelta = policy.retryInterval * 0.8 +\n        Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n    incrementDelta *= boundedRandDelta;\n    retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);\n    return retryData;\n}\nfunction retry(policy, request, operationResponse, retryData, err) {\n    retryData = updateRetryData(policy, retryData, err);\n    if (err && err.code && shouldRetry(policy, retryData) &&\n        (err.code === \"ETIMEDOUT\" || err.code === \"ESOCKETTIMEDOUT\" || err.code === \"ECONNREFUSED\" ||\n            err.code === \"ECONNRESET\" || err.code === \"ENOENT\")) {\n        // If previous operation ended with an error and the policy allows a retry, do that\n        return utils.delay(retryData.retryInterval)\n            .then(function () { return policy._nextPolicy.sendRequest(request.clone()); })\n            .then(function (res) { return retry(policy, request, res, retryData, err); })\n            .catch(function (err) { return retry(policy, request, operationResponse, retryData, err); });\n    }\n    else {\n        if (err != undefined) {\n            // If the operation failed in the end, return all errors instead of just the last one\n            err = retryData.error;\n            return Promise.reject(err);\n        }\n        return Promise.resolve(operationResponse);\n    }\n}\n//# sourceMappingURL=systemErrorRetryPolicy.js.map"]},"metadata":{},"sourceType":"module"}