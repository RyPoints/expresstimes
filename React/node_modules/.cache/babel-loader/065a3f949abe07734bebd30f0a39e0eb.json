{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nclass Command extends EventEmitter {\n  constructor() {\n    super();\n    this.next = null;\n  } // slow. debug only\n\n\n  stateName() {\n    const state = this.next;\n\n    for (const i in this) {\n      if (this[i] === state && i !== 'next') {\n        return i;\n      }\n    }\n\n    return 'unknown name';\n  }\n\n  execute(packet, connection) {\n    if (!this.next) {\n      this.next = this.start;\n\n      connection._resetSequenceId();\n    }\n\n    if (packet && packet.isError()) {\n      const err = packet.asError(connection.clientEncoding);\n\n      if (this.onResult) {\n        this.onResult(err);\n        this.emit('end');\n      } else {\n        this.emit('error', err);\n        this.emit('end');\n      }\n\n      return true;\n    } // TODO: don't return anything from execute, it's ugly and error-prone. Listen for 'end' event in connection\n\n\n    this.next = this.next(packet, connection);\n\n    if (this.next) {\n      return false;\n    }\n\n    this.emit('end');\n    return true;\n  }\n\n}\n\nmodule.exports = Command;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/mysql2/lib/commands/command.js"],"names":["EventEmitter","require","Command","constructor","next","stateName","state","i","execute","packet","connection","start","_resetSequenceId","isError","err","asError","clientEncoding","onResult","emit","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AAEA,MAAME,OAAN,SAAsBF,YAAtB,CAAmC;AACjCG,EAAAA,WAAW,GAAG;AACZ;AACA,SAAKC,IAAL,GAAY,IAAZ;AACD,GAJgC,CAMjC;;;AACAC,EAAAA,SAAS,GAAG;AACV,UAAMC,KAAK,GAAG,KAAKF,IAAnB;;AACA,SAAK,MAAMG,CAAX,IAAgB,IAAhB,EAAsB;AACpB,UAAI,KAAKA,CAAL,MAAYD,KAAZ,IAAqBC,CAAC,KAAK,MAA/B,EAAuC;AACrC,eAAOA,CAAP;AACD;AACF;;AACD,WAAO,cAAP;AACD;;AAEDC,EAAAA,OAAO,CAACC,MAAD,EAASC,UAAT,EAAqB;AAC1B,QAAI,CAAC,KAAKN,IAAV,EAAgB;AACd,WAAKA,IAAL,GAAY,KAAKO,KAAjB;;AACAD,MAAAA,UAAU,CAACE,gBAAX;AACD;;AACD,QAAIH,MAAM,IAAIA,MAAM,CAACI,OAAP,EAAd,EAAgC;AAC9B,YAAMC,GAAG,GAAGL,MAAM,CAACM,OAAP,CAAeL,UAAU,CAACM,cAA1B,CAAZ;;AACA,UAAI,KAAKC,QAAT,EAAmB;AACjB,aAAKA,QAAL,CAAcH,GAAd;AACA,aAAKI,IAAL,CAAU,KAAV;AACD,OAHD,MAGO;AACL,aAAKA,IAAL,CAAU,OAAV,EAAmBJ,GAAnB;AACA,aAAKI,IAAL,CAAU,KAAV;AACD;;AACD,aAAO,IAAP;AACD,KAfyB,CAgB1B;;;AACA,SAAKd,IAAL,GAAY,KAAKA,IAAL,CAAUK,MAAV,EAAkBC,UAAlB,CAAZ;;AACA,QAAI,KAAKN,IAAT,EAAe;AACb,aAAO,KAAP;AACD;;AACD,SAAKc,IAAL,CAAU,KAAV;AACA,WAAO,IAAP;AAED;;AAzCgC;;AA4CnCC,MAAM,CAACC,OAAP,GAAiBlB,OAAjB","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nclass Command extends EventEmitter {\n  constructor() {\n    super();\n    this.next = null;\n  }\n\n  // slow. debug only\n  stateName() {\n    const state = this.next;\n    for (const i in this) {\n      if (this[i] === state && i !== 'next') {\n        return i;\n      }\n    }\n    return 'unknown name';\n  }\n\n  execute(packet, connection) {\n    if (!this.next) {\n      this.next = this.start;\n      connection._resetSequenceId();\n    }\n    if (packet && packet.isError()) {\n      const err = packet.asError(connection.clientEncoding);\n      if (this.onResult) {\n        this.onResult(err);\n        this.emit('end');\n      } else {\n        this.emit('error', err);\n        this.emit('end');\n      }\n      return true;\n    }\n    // TODO: don't return anything from execute, it's ugly and error-prone. Listen for 'end' event in connection\n    this.next = this.next(packet, connection);\n    if (this.next) {\n      return false;\n    } \n    this.emit('end');\n    return true;\n    \n  }\n}\n\nmodule.exports = Command;\n"]},"metadata":{},"sourceType":"script"}