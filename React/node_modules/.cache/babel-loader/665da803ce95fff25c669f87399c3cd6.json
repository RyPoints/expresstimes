{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst EE = require('events').EventEmitter;\n\nconst Minimatch = require('minimatch').Minimatch;\n\nclass Walker extends EE {\n  constructor(opts) {\n    opts = opts || {};\n    super(opts);\n    this.path = opts.path || process.cwd();\n    this.basename = path.basename(this.path);\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    this.ignoreRules = {};\n    this.parent = opts.parent || null;\n    this.includeEmpty = !!opts.includeEmpty;\n    this.root = this.parent ? this.parent.root : this.path;\n    this.follow = !!opts.follow;\n    this.result = this.parent ? this.parent.result : [];\n    this.entries = null;\n    this.sawError = false;\n  }\n\n  sort(a, b) {\n    return a.localeCompare(b);\n  }\n\n  emit(ev, data) {\n    let ret = false;\n\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') this.sawError = true;else if (ev === 'done' && !this.parent) data = data.sort(this.sort);\n      if (ev === 'error' && this.parent) ret = this.parent.emit('error', data);else ret = super.emit(ev, data);\n    }\n\n    return ret;\n  }\n\n  start() {\n    fs.readdir(this.path, (er, entries) => er ? this.emit('error', er) : this.onReaddir(entries));\n    return this;\n  }\n\n  isIgnoreFile(e) {\n    return e !== \".\" && e !== \"..\" && -1 !== this.ignoreFiles.indexOf(e);\n  }\n\n  onReaddir(entries) {\n    this.entries = entries;\n\n    if (entries.length === 0) {\n      if (this.includeEmpty) this.result.push(this.path.substr(this.root.length + 1));\n      this.emit('done', this.result);\n    } else {\n      const hasIg = this.entries.some(e => this.isIgnoreFile(e));\n      if (hasIg) this.addIgnoreFiles();else this.filterEntries();\n    }\n  }\n\n  addIgnoreFiles() {\n    const newIg = this.entries.filter(e => this.isIgnoreFile(e));\n    let igCount = newIg.length;\n\n    const then = _ => {\n      if (--igCount === 0) this.filterEntries();\n    };\n\n    newIg.forEach(e => this.addIgnoreFile(e, then));\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    fs.readFile(ig, 'utf8', (er, data) => er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then));\n  }\n\n  onReadIgnoreFile(file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    };\n    const rules = data.split(/\\r?\\n/).filter(line => !/^#|^$/.test(line.trim())).map(r => new Minimatch(r, mmopt));\n    this.ignoreRules[file] = rules;\n    then();\n  }\n\n  filterEntries() {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry);\n      const passDir = this.filterEntry(entry, true);\n      return passFile || passDir ? [entry, passFile, passDir] : false;\n    }).filter(e => e); // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n\n    let entryCount = filtered.length;\n\n    if (entryCount === 0) {\n      this.emit('done', this.result);\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) this.emit('done', this.result);\n      };\n\n      filtered.forEach(filt => {\n        const entry = filt[0];\n        const file = filt[1];\n        const dir = filt[2];\n        this.stat(entry, file, dir, then);\n      });\n    }\n  }\n\n  onstat(st, entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n\n    if (!st.isDirectory()) {\n      if (file) this.result.push(abs.substr(this.root.length + 1));\n      then();\n    } else {\n      // is a directory\n      if (dir) this.walker(entry, then);else then();\n    }\n  }\n\n  stat(entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n    fs[this.follow ? 'stat' : 'lstat'](abs, (er, st) => {\n      if (er) this.emit('error', er);else this.onstat(st, entry, file, dir, then);\n    });\n  }\n\n  walkerOpt(entry) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty\n    };\n  }\n\n  walker(entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start();\n  }\n\n  filterEntry(entry, partial) {\n    let included = true; // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + \"/\" + entry;\n      included = this.parent.filterEntry(pt, partial);\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/')) || !!partial && rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true));\n            if (match) included = rule.negate;\n          }\n        });\n      }\n    });\n    return included;\n  }\n\n}\n\nclass WalkerSync extends Walker {\n  constructor(opt) {\n    super(opt);\n  }\n\n  start() {\n    this.onReaddir(fs.readdirSync(this.path));\n    return this;\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n  }\n\n  stat(entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n    const st = fs[this.follow ? 'statSync' : 'lstatSync'](abs);\n    this.onstat(st, entry, file, dir, then);\n  }\n\n  walker(entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start();\n    then();\n  }\n\n}\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(options).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = options => {\n  return new WalkerSync(options).start().result;\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/chokidar/node_modules/fsevents/node_modules/ignore-walk/index.js"],"names":["fs","require","path","EE","EventEmitter","Minimatch","Walker","constructor","opts","process","cwd","basename","ignoreFiles","ignoreRules","parent","includeEmpty","root","follow","result","entries","sawError","sort","a","b","localeCompare","emit","ev","data","ret","start","readdir","er","onReaddir","isIgnoreFile","e","indexOf","length","push","substr","hasIg","some","addIgnoreFiles","filterEntries","newIg","filter","igCount","then","_","forEach","addIgnoreFile","file","ig","resolve","readFile","onReadIgnoreFile","mmopt","matchBase","dot","flipNegate","nocase","rules","split","line","test","trim","map","r","filtered","entry","passFile","filterEntry","passDir","entryCount","filt","dir","stat","onstat","st","abs","isDirectory","walker","walkerOpt","on","partial","included","pt","f","rule","negate","match","WalkerSync","opt","readdirSync","readFileSync","walk","options","callback","p","Promise","reject","res","walkSync","module","exports","sync"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst EE = require('events').EventEmitter\nconst Minimatch = require('minimatch').Minimatch\n\nclass Walker extends EE {\n  constructor (opts) {\n    opts = opts || {}\n    super(opts)\n    this.path = opts.path || process.cwd()\n    this.basename = path.basename(this.path)\n    this.ignoreFiles = opts.ignoreFiles || [ '.ignore' ]\n    this.ignoreRules = {}\n    this.parent = opts.parent || null\n    this.includeEmpty = !!opts.includeEmpty\n    this.root = this.parent ? this.parent.root : this.path\n    this.follow = !!opts.follow\n    this.result = this.parent ? this.parent.result : []\n    this.entries = null\n    this.sawError = false\n  }\n\n  sort (a, b) {\n    return a.localeCompare(b)\n  }\n\n  emit (ev, data) {\n    let ret = false\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error')\n        this.sawError = true\n      else if (ev === 'done' && !this.parent)\n        data = data.sort(this.sort)\n      if (ev === 'error' && this.parent)\n        ret = this.parent.emit('error', data)\n      else\n        ret = super.emit(ev, data)\n    }\n    return ret\n  }\n\n  start () {\n    fs.readdir(this.path, (er, entries) =>\n      er ? this.emit('error', er) : this.onReaddir(entries))\n    return this\n  }\n\n  isIgnoreFile (e) {\n    return e !== \".\" &&\n      e !== \"..\" &&\n      -1 !== this.ignoreFiles.indexOf(e)\n  }\n\n  onReaddir (entries) {\n    this.entries = entries\n    if (entries.length === 0) {\n      if (this.includeEmpty)\n        this.result.push(this.path.substr(this.root.length + 1))\n      this.emit('done', this.result)\n    } else {\n      const hasIg = this.entries.some(e =>\n        this.isIgnoreFile(e))\n\n      if (hasIg)\n        this.addIgnoreFiles()\n      else\n        this.filterEntries()\n    }\n  }\n\n  addIgnoreFiles () {\n    const newIg = this.entries\n      .filter(e => this.isIgnoreFile(e))\n\n    let igCount = newIg.length\n    const then = _ => {\n      if (--igCount === 0)\n        this.filterEntries()\n    }\n\n    newIg.forEach(e => this.addIgnoreFile(e, then))\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    fs.readFile(ig, 'utf8', (er, data) =>\n      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    }\n    const rules = data.split(/\\r?\\n/)\n      .filter(line => !/^#|^$/.test(line.trim()))\n      .map(r => new Minimatch(r, mmopt))\n\n    this.ignoreRules[file] = rules\n\n    then()\n  }\n\n  filterEntries () {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry)\n      const passDir = this.filterEntry(entry, true)\n      return (passFile || passDir) ? [entry, passFile, passDir] : false\n    }).filter(e => e)\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length\n    if (entryCount === 0) {\n      this.emit('done', this.result)\n    } else {\n      const then = _ => {\n        if (-- entryCount === 0)\n          this.emit('done', this.result)\n      }\n      filtered.forEach(filt => {\n        const entry = filt[0]\n        const file = filt[1]\n        const dir = filt[2]\n        this.stat(entry, file, dir, then)\n      })\n    }\n  }\n\n  onstat (st, entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    if (!st.isDirectory()) {\n      if (file)\n        this.result.push(abs.substr(this.root.length + 1))\n      then()\n    } else {\n      // is a directory\n      if (dir)\n        this.walker(entry, then)\n      else\n        then()\n    }\n  }\n\n  stat (entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    fs[this.follow ? 'stat' : 'lstat'](abs, (er, st) => {\n      if (er)\n        this.emit('error', er)\n      else\n        this.onstat(st, entry, file, dir, then)\n    })\n  }\n\n  walkerOpt (entry) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty\n    }\n  }\n\n  walker (entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start()\n  }\n\n  filterEntry (entry, partial) {\n    let included = true\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + \"/\" + entry\n      included = this.parent.filterEntry(pt, partial)\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) ||\n              rule.match(entry) ||\n              (!!partial && (\n                rule.match('/' + entry + '/') ||\n                rule.match(entry + '/'))) ||\n              (!!partial && rule.negate && (\n                rule.match('/' + entry, true) ||\n                rule.match(entry, true)))\n\n            if (match)\n              included = rule.negate\n          }\n        })\n      }\n    })\n\n    return included\n  }\n}\n\nclass WalkerSync extends Walker {\n  constructor (opt) {\n    super(opt)\n  }\n\n  start () {\n    this.onReaddir(fs.readdirSync(this.path))\n    return this\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)\n  }\n\n  stat (entry, file, dir, then) {\n    const abs = this.path + '/' + entry\n    const st = fs[this.follow ? 'statSync' : 'lstatSync'](abs)\n    this.onstat(st, entry, file, dir, then)\n  }\n\n  walker (entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start()\n    then()\n  }\n}\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(options).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = options => {\n  return new WalkerSync(options).start().result\n}\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n"]},"metadata":{},"sourceType":"script"}