{"ast":null,"code":"(function (undefined) {\n  var root = this; // Weird IE shit, objects do not have hasOwn, but the prototype does...\n\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var reverseDupArray = function (array) {\n    var result = new Array(array.length);\n    var index = array.length;\n    var arrayMaxIndex = index - 1;\n\n    while (index--) {\n      result[arrayMaxIndex - index] = array[index];\n    }\n\n    return result;\n  };\n\n  var Dottie = function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length == 2) {\n      return Dottie.find.apply(this, args);\n    }\n\n    return Dottie.transform.apply(this, args);\n  }; // Legacy syntax, changed syntax to have get/set be similar in arg order\n\n\n  Dottie.find = function (path, object) {\n    return Dottie.get(object, path);\n  }; // Dottie memoization flag\n\n\n  Dottie.memoizePath = true;\n  var memoized = {}; // Traverse object according to path, return value if found - Return undefined if destination is unreachable\n\n  Dottie.get = function (object, path, defaultVal) {\n    if (object === undefined || object === null || path === undefined || path === null) {\n      return defaultVal;\n    }\n\n    var names;\n\n    if (typeof path === \"string\") {\n      if (Dottie.memoizePath) {\n        if (memoized[path]) {\n          names = memoized[path].slice(0);\n        } else {\n          names = path.split('.').reverse();\n          memoized[path] = names.slice(0);\n        }\n      } else {\n        names = path.split('.').reverse();\n      }\n    } else if (Array.isArray(path)) {\n      names = reverseDupArray(path);\n    }\n\n    while (names.length && (object = object[names.pop()]) !== undefined && object !== null); // Handle cases where accessing a childprop of a null value\n\n\n    if (object === null && names.length) object = undefined;\n    return object === undefined ? defaultVal : object;\n  };\n\n  Dottie.exists = function (object, path) {\n    return Dottie.get(object, path) !== undefined;\n  }; // Set nested value\n\n\n  Dottie.set = function (object, path, value, options) {\n    var pieces = Array.isArray(path) ? path : path.split('.'),\n        current = object,\n        piece,\n        length = pieces.length;\n\n    if (typeof current !== 'object') {\n      throw new Error('Parent is not an object.');\n    }\n\n    for (var index = 0; index < length; index++) {\n      piece = pieces[index]; // Create namespace (object) where none exists.\n      // If `force === true`, bruteforce the path without throwing errors.\n\n      if (!hasOwnProp.call(current, piece) || current[piece] === undefined || typeof current[piece] !== 'object' && options && options.force === true) {\n        current[piece] = {};\n      }\n\n      if (index == length - 1) {\n        // Set final value\n        current[piece] = value;\n      } else {\n        // We do not overwrite existing path pieces by default\n        if (typeof current[piece] !== 'object') {\n          throw new Error('Target key \"' + piece + '\" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');\n        } // Traverse next in path\n\n\n        current = current[piece];\n      }\n    } // Is there any case when this is relevant? It's also the last line in the above for-loop\n\n\n    current[piece] = value;\n  }; // Set default nested value\n\n\n  Dottie['default'] = function (object, path, value) {\n    if (Dottie.get(object, path) === undefined) {\n      Dottie.set(object, path, value);\n    }\n  }; // Transform unnested object with .-seperated keys into a nested object.\n\n\n  Dottie.transform = function Dottie$transformfunction(object, options) {\n    if (Array.isArray(object)) {\n      return object.map(function (o) {\n        return Dottie.transform(o, options);\n      });\n    }\n\n    options = options || {};\n    options.delimiter = options.delimiter || '.';\n    var pieces,\n        piecesLength,\n        piece,\n        current,\n        transformed = {},\n        key,\n        keys = Object.keys(object),\n        length = keys.length,\n        i;\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n\n      if (key.indexOf(options.delimiter) !== -1) {\n        pieces = key.split(options.delimiter);\n        piecesLength = pieces.length;\n        current = transformed;\n\n        for (var index = 0; index < piecesLength; index++) {\n          piece = pieces[index];\n\n          if (index != piecesLength - 1 && !current.hasOwnProperty(piece)) {\n            current[piece] = {};\n          }\n\n          if (index == piecesLength - 1) {\n            current[piece] = object[key];\n          }\n\n          current = current[piece];\n\n          if (current === null) {\n            break;\n          }\n        }\n      } else {\n        transformed[key] = object[key];\n      }\n    }\n\n    return transformed;\n  };\n\n  Dottie.flatten = function (object, seperator) {\n    if (typeof seperator === \"undefined\") seperator = '.';\n    var flattened = {},\n        current,\n        nested;\n\n    for (var key in object) {\n      if (hasOwnProp.call(object, key)) {\n        current = object[key];\n\n        if (Object.prototype.toString.call(current) === \"[object Object]\") {\n          nested = Dottie.flatten(current, seperator);\n\n          for (var _key in nested) {\n            flattened[key + seperator + _key] = nested[_key];\n          }\n        } else {\n          flattened[key] = current;\n        }\n      }\n    }\n\n    return flattened;\n  };\n\n  Dottie.paths = function (object, prefixes) {\n    var paths = [];\n    var value;\n    var key;\n    prefixes = prefixes || [];\n\n    if (typeof object === 'object') {\n      for (key in object) {\n        value = object[key];\n\n        if (typeof value === 'object' && value !== null) {\n          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));\n        } else {\n          paths.push(prefixes.concat(key).join('.'));\n        }\n      }\n    } else {\n      throw new Error('Paths was called with non-object argument.');\n    }\n\n    return paths;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = Dottie;\n  } else {\n    root['Dottie'] = Dottie;\n    root['Dot'] = Dottie; //BC\n\n    if (typeof define === \"function\") {\n      define([], function () {\n        return Dottie;\n      });\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/dottie/dottie.js"],"names":["undefined","root","hasOwnProp","Object","prototype","hasOwnProperty","reverseDupArray","array","result","Array","length","index","arrayMaxIndex","Dottie","args","slice","call","arguments","find","apply","transform","path","object","get","memoizePath","memoized","defaultVal","names","split","reverse","isArray","pop","exists","set","value","options","pieces","current","piece","Error","force","Dottie$transformfunction","map","o","delimiter","piecesLength","transformed","key","keys","i","indexOf","flatten","seperator","flattened","nested","toString","_key","paths","prefixes","concat","push","join","module","exports","define"],"mappings":"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","sourcesContent":["(function(undefined) {\n  var root = this;\n\n  // Weird IE shit, objects do not have hasOwn, but the prototype does...\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var reverseDupArray = function (array) {\n    var result = new Array(array.length);\n    var index  = array.length;\n    var arrayMaxIndex = index - 1;\n\n    while (index--) {\n      result[arrayMaxIndex - index] = array[index];\n    }\n\n    return result;\n  };\n\n  var Dottie = function() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length == 2) {\n      return Dottie.find.apply(this, args);\n    }\n    return Dottie.transform.apply(this, args);\n  };\n\n  // Legacy syntax, changed syntax to have get/set be similar in arg order\n  Dottie.find = function(path, object) {\n    return Dottie.get(object, path);\n  };\n\n  // Dottie memoization flag\n  Dottie.memoizePath = true;\n  var memoized = {};\n\n  // Traverse object according to path, return value if found - Return undefined if destination is unreachable\n  Dottie.get = function(object, path, defaultVal) {\n    if ((object === undefined) || (object === null) || (path === undefined) || (path === null)) {\n        return defaultVal;\n    }\n\n    var names;\n\n    if (typeof path === \"string\") {\n      if (Dottie.memoizePath) {\n        if (memoized[path]) {\n          names = memoized[path].slice(0);\n        } else {\n          names = path.split('.').reverse();\n          memoized[path] = names.slice(0);\n        }\n      } else {\n        names = path.split('.').reverse();\n      }\n    } else if (Array.isArray(path)) {\n      names = reverseDupArray(path);\n    }\n\n    while (names.length && (object = object[names.pop()]) !== undefined && object !== null);\n\n    // Handle cases where accessing a childprop of a null value\n    if (object === null && names.length) object = undefined;\n\n    return (object === undefined ? defaultVal : object);\n  };\n\n  Dottie.exists = function(object, path) {\n    return Dottie.get(object, path) !== undefined;\n  };\n\n  // Set nested value\n  Dottie.set = function(object, path, value, options) {\n    var pieces = Array.isArray(path) ? path : path.split('.'), current = object, piece, length = pieces.length;\n\n    if (typeof current !== 'object') {\n        throw new Error('Parent is not an object.');\n    }\n\n    for (var index = 0; index < length; index++) {\n      piece = pieces[index];\n\n      // Create namespace (object) where none exists.\n      // If `force === true`, bruteforce the path without throwing errors.\n      if (!hasOwnProp.call(current, piece) || current[piece] === undefined || (typeof current[piece] !== 'object' && options && options.force === true)) {\n        current[piece] = {};\n      }\n\n      if (index == (length - 1)) {\n        // Set final value\n        current[piece] = value;\n      } else {\n        // We do not overwrite existing path pieces by default\n        if (typeof current[piece] !== 'object') {\n          throw new Error('Target key \"' + piece + '\" is not suitable for a nested value. (It is in use as non-object. Set `force` to `true` to override.)');\n        }\n\n        // Traverse next in path\n        current = current[piece];\n      }\n    }\n\n    // Is there any case when this is relevant? It's also the last line in the above for-loop\n    current[piece] = value;\n  };\n\n  // Set default nested value\n  Dottie['default'] = function(object, path, value) {\n    if (Dottie.get(object, path) === undefined) {\n      Dottie.set(object, path, value);\n    }\n  };\n\n  // Transform unnested object with .-seperated keys into a nested object.\n  Dottie.transform = function Dottie$transformfunction(object, options) {\n    if (Array.isArray(object)) {\n      return object.map(function(o) {\n        return Dottie.transform(o, options);\n      });\n    }\n\n    options = options || {};\n    options.delimiter = options.delimiter || '.';\n\n    var pieces\n      , piecesLength\n      , piece\n      , current\n      , transformed = {}\n      , key\n      , keys = Object.keys(object)\n      , length = keys.length\n      , i;\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n\n      if (key.indexOf(options.delimiter) !== -1) {\n        pieces = key.split(options.delimiter);\n        piecesLength = pieces.length;\n        current = transformed;\n\n        for (var index = 0; index < piecesLength; index++) {\n          piece = pieces[index];\n          if (index != (piecesLength - 1) && !current.hasOwnProperty(piece)) {\n            current[piece] = {};\n          }\n\n          if (index == (piecesLength - 1)) {\n            current[piece] = object[key];\n          }\n\n          current = current[piece];\n          if (current === null) {\n            break;\n          }\n        }\n      } else {\n        transformed[key] = object[key];\n      }\n    }\n\n    return transformed;\n  };\n\n  Dottie.flatten = function(object, seperator) {\n    if (typeof seperator === \"undefined\") seperator = '.';\n    var flattened = {}\n      , current\n      , nested;\n\n    for (var key in object) {\n      if (hasOwnProp.call(object, key)) {\n        current = object[key];\n        if (Object.prototype.toString.call(current) === \"[object Object]\") {\n          nested = Dottie.flatten(current, seperator);\n\n          for (var _key in nested) {\n            flattened[key+seperator+_key] = nested[_key];\n          }\n        } else {\n          flattened[key] = current;\n        }\n      }\n    }\n\n    return flattened;\n  };\n\n  Dottie.paths = function(object, prefixes) {\n    var paths = [];\n    var value;\n    var key;\n\n    prefixes = prefixes || [];\n\n    if (typeof object === 'object') {\n      for (key in object) {\n        value = object[key];\n\n        if (typeof value === 'object' && value !== null) {\n          paths = paths.concat(Dottie.paths(value, prefixes.concat([key])));\n        } else {\n          paths.push(prefixes.concat(key).join('.'));\n        }\n      }\n    } else {\n      throw new Error('Paths was called with non-object argument.');\n    }\n\n    return paths;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = Dottie;\n  } else {\n    root['Dottie'] = Dottie;\n    root['Dot'] = Dottie; //BC\n\n    if (typeof define === \"function\") {\n      define([], function () { return Dottie; });\n    }\n  }\n})();\n"]},"metadata":{},"sourceType":"script"}