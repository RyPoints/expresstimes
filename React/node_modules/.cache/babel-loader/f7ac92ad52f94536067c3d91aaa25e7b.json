{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\n\nclass UserTokenCredentials extends tokenCredentialsBase_1.TokenCredentialsBase {\n  /**\n   * Creates a new UserTokenCredentials object.\n   *\n   * @constructor\n   * @param {string} clientId The active directory application client id.\n   * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n   * for an example.\n   * @param {string} domain The domain or tenant id containing this application.\n   * @param {string} username The user name for the Organization Id account.\n   * @param {string} password The password for the Organization Id account.\n   * @param {string} [tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n   * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n   * @param {Environment} [environment] The azure environment to authenticate with.\n   * @param {object} [tokenCache] The token cache. Default value is the MemoryCache object from adal.\n   */\n  constructor(clientId, domain, username, password, tokenAudience, environment, tokenCache) {\n    if (!clientId || typeof clientId.valueOf() !== \"string\") {\n      throw new Error(\"clientId must be a non empty string.\");\n    }\n\n    if (!domain || typeof domain.valueOf() !== \"string\") {\n      throw new Error(\"domain must be a non empty string.\");\n    }\n\n    if (!username || typeof username.valueOf() !== \"string\") {\n      throw new Error(\"username must be a non empty string.\");\n    }\n\n    if (!password || typeof password.valueOf() !== \"string\") {\n      throw new Error(\"password must be a non empty string.\");\n    }\n\n    super(clientId, domain, tokenAudience, environment, tokenCache);\n    this.username = username;\n    this.password = password;\n  }\n\n  crossCheckUserNameWithToken(username, userIdFromToken) {\n    // to maintain the casing consistency between \"azureprofile.json\" and token cache. (RD 1996587)\n    // use the \"userId\" here, which should be the same with \"username\" except the casing.\n    return username.toLowerCase() === userIdFromToken.toLowerCase();\n  }\n  /**\n   * Tries to get the token from cache initially. If that is unsuccessful then it tries to get the token from ADAL.\n   * @returns {Promise<TokenResponse>}\n   * {object} [tokenResponse] The tokenResponse (tokenType and accessToken are the two important properties).\n   * @memberof UserTokenCredentials\n   */\n\n\n  getToken() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.getTokenFromCache(this.username);\n      } catch (error) {\n        const self = this;\n        const resource = this.getActiveDirectoryResourceId();\n        return new Promise((resolve, reject) => {\n          self.authContext.acquireTokenWithUsernamePassword(resource, self.username, self.password, self.clientId, (error, tokenResponse) => {\n            if (error) {\n              return reject(error);\n            }\n\n            if (tokenResponse.error || tokenResponse.errorDescription) {\n              return reject(tokenResponse);\n            }\n\n            tokenResponse = tokenResponse;\n\n            if (self.crossCheckUserNameWithToken(self.username, tokenResponse.userId)) {\n              return resolve(tokenResponse);\n            } else {\n              return reject(`The userId \"${tokenResponse.userId}\" in access token doesn\"t match the username \"${self.username}\" provided during authentication.`);\n            }\n          });\n        });\n      }\n    });\n  }\n\n}\n\nexports.UserTokenCredentials = UserTokenCredentials;","map":{"version":3,"sources":["../../../lib/credentials/userTokenCredentials.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAA,sBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAKA,MAAa,oBAAb,SAA0C,sBAAA,CAAA,oBAA1C,CAA8D;AAK5D;;;;;;;;;;;;;;;AAeA,EAAA,WAAA,CACE,QADF,EAEE,MAFF,EAGE,QAHF,EAIE,QAJF,EAKE,aALF,EAME,WANF,EAOE,UAPF,EAOyB;AAEvB,QAAI,CAAC,QAAD,IAAa,OAAO,QAAQ,CAAC,OAAT,EAAP,KAA8B,QAA/C,EAAyD;AACvD,YAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,QAAI,CAAC,MAAD,IAAW,OAAO,MAAM,CAAC,OAAP,EAAP,KAA4B,QAA3C,EAAqD;AACnD,YAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,QAAI,CAAC,QAAD,IAAa,OAAO,QAAQ,CAAC,OAAT,EAAP,KAA8B,QAA/C,EAAyD;AACvD,YAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,QAAI,CAAC,QAAD,IAAa,OAAO,QAAQ,CAAC,OAAT,EAAP,KAA8B,QAA/C,EAAyD;AACvD,YAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,UAAM,QAAN,EAAgB,MAAhB,EAAwB,aAAxB,EAAuC,WAAvC,EAAoD,UAApD;AAEA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,QAAL,GAAgB,QAAhB;AACD;;AAEO,EAAA,2BAA2B,CAAC,QAAD,EAAmB,eAAnB,EAA0C;AAC3E;AACA;AACA,WAAQ,QAAQ,CAAC,WAAT,OAA2B,eAAe,CAAC,WAAhB,EAAnC;AACD;AAED;;;;;;;;AAMa,EAAA,QAAQ,GAAA;;AACnB,UAAI;AACF,eAAO,MAAM,KAAK,iBAAL,CAAuB,KAAK,QAA5B,CAAb;AACD,OAFD,CAEE,OAAO,KAAP,EAAc;AACd,cAAM,IAAI,GAAG,IAAb;AACA,cAAM,QAAQ,GAAG,KAAK,4BAAL,EAAjB;AAEA,eAAO,IAAI,OAAJ,CAA2B,CAAC,OAAD,EAAU,MAAV,KAAoB;AACpD,UAAA,IAAI,CAAC,WAAL,CAAiB,gCAAjB,CAAkD,QAAlD,EAA4D,IAAI,CAAC,QAAjE,EAA2E,IAAI,CAAC,QAAhF,EAA0F,IAAI,CAAC,QAA/F,EACE,CAAC,KAAD,EAAe,aAAf,KAA+D;AAC7D,gBAAI,KAAJ,EAAW;AACT,qBAAO,MAAM,CAAC,KAAD,CAAb;AACD;;AAED,gBAAI,aAAa,CAAC,KAAd,IAAuB,aAAa,CAAC,gBAAzC,EAA2D;AACzD,qBAAO,MAAM,CAAC,aAAD,CAAb;AACD;;AAED,YAAA,aAAa,GAAG,aAAhB;;AACA,gBAAI,IAAI,CAAC,2BAAL,CAAiC,IAAI,CAAC,QAAtC,EAAgD,aAAa,CAAC,MAA9D,CAAJ,EAA4E;AAC1E,qBAAO,OAAO,CAAE,aAAF,CAAd;AACD,aAFD,MAEO;AACL,qBAAO,MAAM,CAAC,eAAe,aAAa,CAAC,MAAM,iDAAiD,IAAI,CAAC,QAAQ,mCAAlG,CAAb;AACD;AACF,WAhBH;AAiBD,SAlBM,CAAP;AAmBD;AACF,K;AAAA;;AA1F2D;;AAA9D,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\nclass UserTokenCredentials extends tokenCredentialsBase_1.TokenCredentialsBase {\n    /**\n     * Creates a new UserTokenCredentials object.\n     *\n     * @constructor\n     * @param {string} clientId The active directory application client id.\n     * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n     * for an example.\n     * @param {string} domain The domain or tenant id containing this application.\n     * @param {string} username The user name for the Organization Id account.\n     * @param {string} password The password for the Organization Id account.\n     * @param {string} [tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n     * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n     * @param {Environment} [environment] The azure environment to authenticate with.\n     * @param {object} [tokenCache] The token cache. Default value is the MemoryCache object from adal.\n     */\n    constructor(clientId, domain, username, password, tokenAudience, environment, tokenCache) {\n        if (!clientId || typeof clientId.valueOf() !== \"string\") {\n            throw new Error(\"clientId must be a non empty string.\");\n        }\n        if (!domain || typeof domain.valueOf() !== \"string\") {\n            throw new Error(\"domain must be a non empty string.\");\n        }\n        if (!username || typeof username.valueOf() !== \"string\") {\n            throw new Error(\"username must be a non empty string.\");\n        }\n        if (!password || typeof password.valueOf() !== \"string\") {\n            throw new Error(\"password must be a non empty string.\");\n        }\n        super(clientId, domain, tokenAudience, environment, tokenCache);\n        this.username = username;\n        this.password = password;\n    }\n    crossCheckUserNameWithToken(username, userIdFromToken) {\n        // to maintain the casing consistency between \"azureprofile.json\" and token cache. (RD 1996587)\n        // use the \"userId\" here, which should be the same with \"username\" except the casing.\n        return (username.toLowerCase() === userIdFromToken.toLowerCase());\n    }\n    /**\n     * Tries to get the token from cache initially. If that is unsuccessful then it tries to get the token from ADAL.\n     * @returns {Promise<TokenResponse>}\n     * {object} [tokenResponse] The tokenResponse (tokenType and accessToken are the two important properties).\n     * @memberof UserTokenCredentials\n     */\n    getToken() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield this.getTokenFromCache(this.username);\n            }\n            catch (error) {\n                const self = this;\n                const resource = this.getActiveDirectoryResourceId();\n                return new Promise((resolve, reject) => {\n                    self.authContext.acquireTokenWithUsernamePassword(resource, self.username, self.password, self.clientId, (error, tokenResponse) => {\n                        if (error) {\n                            return reject(error);\n                        }\n                        if (tokenResponse.error || tokenResponse.errorDescription) {\n                            return reject(tokenResponse);\n                        }\n                        tokenResponse = tokenResponse;\n                        if (self.crossCheckUserNameWithToken(self.username, tokenResponse.userId)) {\n                            return resolve(tokenResponse);\n                        }\n                        else {\n                            return reject(`The userId \"${tokenResponse.userId}\" in access token doesn\"t match the username \"${self.username}\" provided during authentication.`);\n                        }\n                    });\n                });\n            }\n        });\n    }\n}\nexports.UserTokenCredentials = UserTokenCredentials;\n//# sourceMappingURL=userTokenCredentials.js.map"]},"metadata":{},"sourceType":"script"}