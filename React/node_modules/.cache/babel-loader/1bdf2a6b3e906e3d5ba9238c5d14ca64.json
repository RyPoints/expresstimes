{"ast":null,"code":"'use strict';\n\nconst Toposort = require('toposort-class');\n\nconst _ = require('lodash');\n\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n    return model;\n  }\n\n  removeModel(modelToRemove) {\n    this.models = this.models.filter(model => model.name !== modelToRemove.name);\n    delete this.sequelize.models[modelToRemove.name];\n  }\n\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: 'name'\n    });\n    const model = this.models.filter(model => model[options.attribute] === against);\n    return model ? model[0] : null;\n  }\n\n  get all() {\n    return this.models;\n  }\n  /**\n   * Iterate over Models in an order suitable for e.g. creating tables. Will\n   * take foreign key constraints into account so that dependencies are visited\n   * before dependents.\n   * @private\n   */\n\n\n  forEachModel(iterator, options) {\n    const models = {};\n    const sorter = new Toposort();\n    let sorted;\n    let dep;\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n\n      if (_.isObject(tableName)) {\n        tableName = tableName.schema + '.' + tableName.tableName;\n      }\n\n      models[tableName] = model;\n\n      for (const attrName in model.rawAttributes) {\n        if (model.rawAttributes.hasOwnProperty(attrName)) {\n          const attribute = model.rawAttributes[attrName];\n\n          if (attribute.references) {\n            dep = attribute.references.model;\n\n            if (_.isObject(dep)) {\n              dep = dep.schema + '.' + dep.tableName;\n            }\n\n            deps.push(dep);\n          }\n        }\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n      sorter.add(tableName, deps);\n    }\n\n    sorted = sorter.sort();\n\n    if (options.reverse) {\n      sorted = sorted.reverse();\n    }\n\n    for (const name of sorted) {\n      iterator(models[name], name);\n    }\n  }\n\n}\n\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports.default = ModelManager;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/model-manager.js"],"names":["Toposort","require","_","ModelManager","constructor","sequelize","models","addModel","model","push","name","removeModel","modelToRemove","filter","getModel","against","options","defaults","attribute","all","forEachModel","iterator","sorter","sorted","dep","reverse","deps","tableName","getTableName","isObject","schema","attrName","rawAttributes","hasOwnProperty","references","add","sort","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Toposort = require('toposort-class');\nconst _ = require('lodash');\n\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n\n    return model;\n  }\n\n  removeModel(modelToRemove) {\n    this.models = this.models.filter(model => model.name !== modelToRemove.name);\n\n    delete this.sequelize.models[modelToRemove.name];\n  }\n\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: 'name'\n    });\n\n    const model = this.models.filter(model => model[options.attribute] === against);\n\n    return model ? model[0] : null;\n  }\n\n  get all() {\n    return this.models;\n  }\n\n  /**\n   * Iterate over Models in an order suitable for e.g. creating tables. Will\n   * take foreign key constraints into account so that dependencies are visited\n   * before dependents.\n   * @private\n   */\n  forEachModel(iterator, options) {\n    const models = {};\n    const sorter = new Toposort();\n    let sorted;\n    let dep;\n\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n\n      if (_.isObject(tableName)) {\n        tableName = tableName.schema + '.' + tableName.tableName;\n      }\n\n      models[tableName] = model;\n\n      for (const attrName in model.rawAttributes) {\n        if (model.rawAttributes.hasOwnProperty(attrName)) {\n          const attribute = model.rawAttributes[attrName];\n\n          if (attribute.references) {\n            dep = attribute.references.model;\n\n            if (_.isObject(dep)) {\n              dep = dep.schema + '.' + dep.tableName;\n            }\n\n            deps.push(dep);\n          }\n        }\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n\n      sorter.add(tableName, deps);\n    }\n\n    sorted = sorter.sort();\n    if (options.reverse) {\n      sorted = sorted.reverse();\n    }\n    for (const name of sorted) {\n      iterator(models[name], name);\n    }\n  }\n}\n\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports.default = ModelManager;\n"]},"metadata":{},"sourceType":"script"}