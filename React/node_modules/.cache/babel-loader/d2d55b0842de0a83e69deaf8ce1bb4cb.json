{"ast":null,"code":"'use strict';\n\nconst Utils = require('../../utils');\n\nconst Transaction = require('../../transaction');\n\nconst _ = require('lodash');\n\nconst MySqlQueryGenerator = require('../mysql/query-generator');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = _.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n        let dataTypeString = dataType;\n\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n          }\n        }\n\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    } // https://sqlite.org/json1.html\n\n\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  } //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n\n\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n\n    return value;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, {\n      context: 'addColumn'\n    });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n    const bind = [];\n    const bindParam = this.bindParam(bind);\n\n    const upsertOptions = _.defaults({\n      bindParam\n    }, options);\n\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n    const query = `${insert.query} ${update.query}`;\n    return {\n      query,\n      bind\n    };\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n          context: 'UPDATE'\n        })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n          context: 'UPDATE'\n        }, bindParam)}`);\n      }\n    }\n\n    let query;\n\n    const whereOptions = _.defaults({\n      bindParam\n    }, options);\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return {\n      query,\n      bind\n    };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [`DELETE FROM ${this.quoteTable(tableName)}`, options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', '); // Temporary table cannot work for foreign keys.\n\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};` + `DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};` + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n    return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};` + `DROP TABLE ${quotedTableName};` + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n    return `${this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE')}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};` + `DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};` + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n\n}\n\nmodule.exports = SQLiteQueryGenerator;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/dialects/sqlite/query-generator.js"],"names":["Utils","require","Transaction","_","MySqlQueryGenerator","AbstractQueryGenerator","SQLiteQueryGenerator","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","options","primaryKeys","needsMultiplePrimaryKeys","values","filter","definition","includes","length","attrArray","attr","Object","prototype","hasOwnProperty","call","dataType","containsAutoIncrement","dataTypeString","substr","indexOf","push","replace","quoteIdentifier","table","quoteTable","attrStr","join","pkString","map","pk","uniqueKeys","each","columns","customIndex","fields","field","sql","replaceBooleanDefaults","booleanValue","value","_checkValidJsonStatement","stmt","jsonFunctionRegex","tokenCaptureRegex","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","functionMatches","exec","tokenMatches","capturedToken","Error","_toJSONValue","Date","toISOString","Array","isArray","val","handleSequelizeMethod","smth","factory","prepend","Json","Cast","test","type","addColumnQuery","key","attributesToSQL","context","attribute","showTablesQuery","upsertQuery","insertValues","updateValues","where","model","ignoreDuplicates","bind","bindParam","upsertOptions","defaults","insert","insertQuery","rawAttributes","update","updateQuery","query","attrValueHash","removeNullValuesFromHash","omitNull","modelAttributeMap","SequelizeMethod","escape","undefined","format","whereOptions","limit","whereQuery","truncateTableQuery","restartIdentity","addTicks","removeTicks","deleteQuery","whereClause","getWhereConditions","result","name","fieldName","isObject","toString","allowNull","defaultValueSchemable","defaultValue","unique","primaryKey","autoIncrement","references","referencesTable","referencesKey","onDelete","toUpperCase","onUpdate","showIndexesQuery","showConstraintsQuery","constraintName","removeIndexQuery","indexNameOrAttributes","indexName","underscore","describeTableQuery","schema","schemaDelimiter","_schema","_schemaDelimiter","addSchema","describeCreateTableQuery","removeColumnQuery","backupTableName","quotedTableName","quotedBackupTableName","attributeNames","keys","_alterConstraintQuery","createTableSql","renameColumnQuery","attrNameBefore","attrNameAfter","attributeNamesImport","attributeNamesExport","startTransactionQuery","transaction","parent","setIsolationLevelQuery","ISOLATION_LEVELS","REPEATABLE_READ","READ_UNCOMMITTED","READ_COMMITTED","SERIALIZABLE","getForeignKeysQuery","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = _.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n\n    const bind = [];\n    const bindParam = this.bindParam(bind);\n\n    const upsertOptions = _.defaults({ bindParam }, options);\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n\n    const query = `${insert.query} ${update.query}`;\n\n    return { query, bind };\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE')\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n}\n\nmodule.exports = SQLiteQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}