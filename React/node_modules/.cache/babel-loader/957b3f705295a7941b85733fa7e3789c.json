{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as tslib_1 from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { RestError } from \"../restError\";\nexport function exponentialRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: function (nextPolicy, options) {\n      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\nvar DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nvar DEFAULT_CLIENT_RETRY_COUNT = 3;\nvar DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nvar DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\n\nvar ExponentialRetryPolicy =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ExponentialRetryPolicy, _super);\n  /**\n   * @constructor\n   * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.\n   * @param {RequestPolicyOptions} options The options for this RequestPolicy.\n   * @param {number} [retryCount]        The client retry count.\n   * @param {number} [retryInterval]     The client retry interval, in milliseconds.\n   * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.\n   * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.\n   */\n\n\n  function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n\n    function isNumber(n) {\n      return typeof n === \"number\";\n    }\n\n    _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    _this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    return _this;\n  }\n\n  ExponentialRetryPolicy.prototype.sendRequest = function (request) {\n    var _this = this;\n\n    return this._nextPolicy.sendRequest(request.clone()).then(function (response) {\n      return retry(_this, request, response);\n    }).catch(function (error) {\n      return retry(_this, request, error.response, undefined, error);\n    });\n  };\n\n  return ExponentialRetryPolicy;\n}(BaseRequestPolicy);\n\nexport { ExponentialRetryPolicy };\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\n\nfunction shouldRetry(policy, statusCode, retryData) {\n  if (statusCode == undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {\n    return false;\n  }\n\n  var currentCount;\n\n  if (!retryData) {\n    throw new Error(\"retryData for the ExponentialRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n\n  return currentCount < policy.retryCount;\n}\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {RetryData} retryData  The retry data.\n * @param {RetryError} [err] The operation\"s error, if any.\n */\n\n\nfunction updateRetryData(policy, retryData, err) {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  } // Adjust retry count\n\n\n  retryData.retryCount++; // Adjust retry interval\n\n  var incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  var boundedRandDelta = policy.retryInterval * 0.8 + Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n  incrementDelta *= boundedRandDelta;\n  retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);\n  return retryData;\n}\n\nfunction retry(policy, request, response, retryData, requestError) {\n  retryData = updateRetryData(policy, retryData, requestError);\n  var isAborted = request.abortSignal && request.abortSignal.aborted;\n\n  if (!isAborted && shouldRetry(policy, response && response.status, retryData)) {\n    return utils.delay(retryData.retryInterval).then(function () {\n      return policy._nextPolicy.sendRequest(request.clone());\n    }).then(function (res) {\n      return retry(policy, request, res, retryData, undefined);\n    }).catch(function (err) {\n      return retry(policy, request, response, retryData, err);\n    });\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    var err = retryData.error || new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n    return Promise.reject(err);\n  } else {\n    return Promise.resolve(response);\n  }\n}","map":{"version":3,"sources":["../../../lib/policies/exponentialRetryPolicy.ts"],"names":[],"mappings":"AAAA;AACA;;AAGA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AAEA,SAAS,iBAAT,QAA6F,iBAA7F;AACA,SAAS,SAAT,QAA0B,cAA1B;AAcA,OAAM,SAAU,sBAAV,CAAiC,UAAjC,EAAsD,aAAtD,EAA8E,gBAA9E,EAAyG,gBAAzG,EAAkI;AACtI,SAAO;AACL,IAAA,MAAM,EAAE,UAAC,UAAD,EAA4B,OAA5B,EAAyD;AAC/D,aAAO,IAAI,sBAAJ,CAA2B,UAA3B,EAAuC,OAAvC,EAAgD,UAAhD,EAA4D,aAA5D,EAA2E,gBAA3E,EAA6F,gBAA7F,CAAP;AACD;AAHI,GAAP;AAKD;AAED,IAAM,6BAA6B,GAAG,OAAO,EAA7C;AACA,IAAM,0BAA0B,GAAG,CAAnC;AACA,IAAM,iCAAiC,GAAG,OAAO,EAAjD;AACA,IAAM,iCAAiC,GAAG,OAAO,CAAjD;AAEA;;;;;AAIA,IAAA,sBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA4C,EAAA,OAAA,CAAA,SAAA,CAAA,sBAAA,EAAA,MAAA;AAkB1C;;;;;;;;;;;AASA,WAAA,sBAAA,CAAY,UAAZ,EAAuC,OAAvC,EAAsE,UAAtE,EAA2F,aAA3F,EAAmH,gBAAnH,EAA8I,gBAA9I,EAAuK;AAAvK,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,UAAN,EAAkB,OAAlB,KAA0B,IAD5B;;AAEE,aAAS,QAAT,CAAkB,CAAlB,EAAwB;AAAiB,aAAO,OAAO,CAAP,KAAa,QAApB;AAA+B;;AACxE,IAAA,KAAI,CAAC,UAAL,GAAkB,QAAQ,CAAC,UAAD,CAAR,GAAuB,UAAvB,GAAoC,0BAAtD;AACA,IAAA,KAAI,CAAC,aAAL,GAAqB,QAAQ,CAAC,aAAD,CAAR,GAA0B,aAA1B,GAA0C,6BAA/D;AACA,IAAA,KAAI,CAAC,gBAAL,GAAwB,QAAQ,CAAC,gBAAD,CAAR,GAA6B,gBAA7B,GAAgD,iCAAxE;AACA,IAAA,KAAI,CAAC,gBAAL,GAAwB,QAAQ,CAAC,gBAAD,CAAR,GAA6B,gBAA7B,GAAgD,iCAAxE;;AACD;;AAEM,EAAA,sBAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,OAAnB,EAAuC;AAAvC,QAAA,KAAA,GAAA,IAAA;;AACE,WAAO,KAAK,WAAL,CAAiB,WAAjB,CAA6B,OAAO,CAAC,KAAR,EAA7B,EACJ,IADI,CACC,UAAA,QAAA,EAAQ;AAAI,aAAA,KAAK,CAAC,KAAD,EAAO,OAAP,EAAL,QAAK,CAAL;AAA8B,KAD3C,EAEJ,KAFI,CAEE,UAAA,KAAA,EAAK;AAAI,aAAA,KAAK,CAAC,KAAD,EAAO,OAAP,EAAgB,KAAK,CAAC,QAAtB,EAAgC,SAAhC,EAAL,KAAK,CAAL;AAAsD,KAFjE,CAAP;AAGD,GAJM;;AAKT,SAAA,sBAAA;AAAC,CAzCD,CAA4C,iBAA5C,CAAA;;;AA2CA;;;;;;;;;AAQA,SAAS,WAAT,CAAqB,MAArB,EAAqD,UAArD,EAAqF,SAArF,EAAyG;AACvG,MAAI,UAAU,IAAI,SAAd,IAA4B,UAAU,GAAG,GAAb,IAAoB,UAAU,KAAK,GAA/D,IAAuE,UAAU,KAAK,GAAtF,IAA6F,UAAU,KAAK,GAAhH,EAAqH;AACnH,WAAO,KAAP;AACD;;AAED,MAAI,YAAJ;;AACA,MAAI,CAAC,SAAL,EAAgB;AACd,UAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AACD,GAFD,MAEO;AACL,IAAA,YAAY,GAAI,SAAS,IAAI,SAAS,CAAC,UAAvC;AACD;;AAED,SAAQ,YAAY,GAAG,MAAM,CAAC,UAA9B;AACD;AAED;;;;;;;;;AAOA,SAAS,eAAT,CAAyB,MAAzB,EAAyD,SAAzD,EAAgF,GAAhF,EAAgG;AAC9F,MAAI,CAAC,SAAL,EAAgB;AACd,IAAA,SAAS,GAAG;AACV,MAAA,UAAU,EAAE,CADF;AAEV,MAAA,aAAa,EAAE;AAFL,KAAZ;AAID;;AAED,MAAI,GAAJ,EAAS;AACP,QAAI,SAAS,CAAC,KAAd,EAAqB;AACnB,MAAA,GAAG,CAAC,UAAJ,GAAiB,SAAS,CAAC,KAA3B;AACD;;AAED,IAAA,SAAS,CAAC,KAAV,GAAkB,GAAlB;AACD,GAd6F,CAgB9F;;;AACA,EAAA,SAAS,CAAC,UAAV,GAjB8F,CAmB9F;;AACA,MAAI,cAAc,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,SAAS,CAAC,UAAtB,IAAoC,CAAzD;AACA,MAAM,gBAAgB,GAAG,MAAM,CAAC,aAAP,GAAuB,GAAvB,GACvB,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAL,MAAiB,MAAM,CAAC,aAAP,GAAuB,GAAvB,GAA6B,MAAM,CAAC,aAAP,GAAuB,GAArE,CAAX,CADF;AAEA,EAAA,cAAc,IAAI,gBAAlB;AAEA,EAAA,SAAS,CAAC,aAAV,GAA0B,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,gBAAP,GAA0B,cAAnC,EAAmD,MAAM,CAAC,gBAA1D,CAA1B;AAEA,SAAO,SAAP;AACD;;AAED,SAAS,KAAT,CAAe,MAAf,EAA+C,OAA/C,EAAqE,QAArE,EAAuG,SAAvG,EAA8H,YAA9H,EAAuJ;AACrJ,EAAA,SAAS,GAAG,eAAe,CAAC,MAAD,EAAS,SAAT,EAAoB,YAApB,CAA3B;AACA,MAAM,SAAS,GAAwB,OAAO,CAAC,WAAR,IAAuB,OAAO,CAAC,WAAR,CAAoB,OAAlF;;AACA,MAAI,CAAC,SAAD,IAAc,WAAW,CAAC,MAAD,EAAS,QAAQ,IAAI,QAAQ,CAAC,MAA9B,EAAsC,SAAtC,CAA7B,EAA+E;AAC7E,WAAO,KAAK,CAAC,KAAN,CAAY,SAAS,CAAC,aAAtB,EACJ,IADI,CACC,YAAA;AAAM,aAAA,MAAM,CAAC,WAAP,CAAmB,WAAnB,CAA+B,OAAO,CAAtC,KAA+B,EAA/B,CAAA;AAA+C,KADtD,EAEJ,IAFI,CAEC,UAAA,GAAA,EAAG;AAAI,aAAA,KAAK,CAAC,MAAD,EAAS,OAAT,EAAkB,GAAlB,EAAuB,SAAvB,EAAL,SAAK,CAAL;AAAiD,KAFzD,EAGJ,KAHI,CAGE,UAAA,GAAA,EAAG;AAAI,aAAA,KAAK,CAAC,MAAD,EAAS,OAAT,EAAkB,QAAlB,EAA4B,SAA5B,EAAL,GAAK,CAAL;AAAgD,KAHzD,CAAP;AAID,GALD,MAKO,IAAI,SAAS,IAAI,YAAb,IAA6B,CAAC,QAAlC,EAA4C;AACjD;AACA,QAAM,GAAG,GAAG,SAAS,CAAC,KAAV,IACV,IAAI,SAAJ,CACE,6BADF,EAEE,SAAS,CAAC,kBAFZ,EAGE,QAAQ,IAAI,QAAQ,CAAC,MAHvB,EAIE,QAAQ,IAAI,QAAQ,CAAC,OAJvB,EAKE,QALF,CADF;AAOA,WAAO,OAAO,CAAC,MAAR,CAAe,GAAf,CAAP;AACD,GAVM,MAUA;AACL,WAAO,OAAO,CAAC,OAAR,CAAgB,QAAhB,CAAP;AACD;AACF","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as tslib_1 from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { RestError } from \"../restError\";\nexport function exponentialRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    return {\n        create: function (nextPolicy, options) {\n            return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n        }\n    };\n}\nvar DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nvar DEFAULT_CLIENT_RETRY_COUNT = 3;\nvar DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nvar DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n/**\n * @class\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nvar ExponentialRetryPolicy = /** @class */ (function (_super) {\n    tslib_1.__extends(ExponentialRetryPolicy, _super);\n    /**\n     * @constructor\n     * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.\n     * @param {RequestPolicyOptions} options The options for this RequestPolicy.\n     * @param {number} [retryCount]        The client retry count.\n     * @param {number} [retryInterval]     The client retry interval, in milliseconds.\n     * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.\n     * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.\n     */\n    function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n        var _this = _super.call(this, nextPolicy, options) || this;\n        function isNumber(n) { return typeof n === \"number\"; }\n        _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n        _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n        _this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n        _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n        return _this;\n    }\n    ExponentialRetryPolicy.prototype.sendRequest = function (request) {\n        var _this = this;\n        return this._nextPolicy.sendRequest(request.clone())\n            .then(function (response) { return retry(_this, request, response); })\n            .catch(function (error) { return retry(_this, request, error.response, undefined, error); });\n    };\n    return ExponentialRetryPolicy;\n}(BaseRequestPolicy));\nexport { ExponentialRetryPolicy };\n/**\n * Determines if the operation should be retried and how long to wait until the next retry.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {number} statusCode The HTTP status code.\n * @param {RetryData} retryData  The retry data.\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n */\nfunction shouldRetry(policy, statusCode, retryData) {\n    if (statusCode == undefined || (statusCode < 500 && statusCode !== 408) || statusCode === 501 || statusCode === 505) {\n        return false;\n    }\n    var currentCount;\n    if (!retryData) {\n        throw new Error(\"retryData for the ExponentialRetryPolicyFilter cannot be null.\");\n    }\n    else {\n        currentCount = (retryData && retryData.retryCount);\n    }\n    return (currentCount < policy.retryCount);\n}\n/**\n * Updates the retry data for the next attempt.\n *\n * @param {ExponentialRetryPolicy} policy The ExponentialRetryPolicy that this function is being called against.\n * @param {RetryData} retryData  The retry data.\n * @param {RetryError} [err] The operation\"s error, if any.\n */\nfunction updateRetryData(policy, retryData, err) {\n    if (!retryData) {\n        retryData = {\n            retryCount: 0,\n            retryInterval: 0\n        };\n    }\n    if (err) {\n        if (retryData.error) {\n            err.innerError = retryData.error;\n        }\n        retryData.error = err;\n    }\n    // Adjust retry count\n    retryData.retryCount++;\n    // Adjust retry interval\n    var incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n    var boundedRandDelta = policy.retryInterval * 0.8 +\n        Math.floor(Math.random() * (policy.retryInterval * 1.2 - policy.retryInterval * 0.8));\n    incrementDelta *= boundedRandDelta;\n    retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);\n    return retryData;\n}\nfunction retry(policy, request, response, retryData, requestError) {\n    retryData = updateRetryData(policy, retryData, requestError);\n    var isAborted = request.abortSignal && request.abortSignal.aborted;\n    if (!isAborted && shouldRetry(policy, response && response.status, retryData)) {\n        return utils.delay(retryData.retryInterval)\n            .then(function () { return policy._nextPolicy.sendRequest(request.clone()); })\n            .then(function (res) { return retry(policy, request, res, retryData, undefined); })\n            .catch(function (err) { return retry(policy, request, response, retryData, err); });\n    }\n    else if (isAborted || requestError || !response) {\n        // If the operation failed in the end, return all errors instead of just the last one\n        var err = retryData.error ||\n            new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n        return Promise.reject(err);\n    }\n    else {\n        return Promise.resolve(response);\n    }\n}\n//# sourceMappingURL=exponentialRetryPolicy.js.map"]},"metadata":{},"sourceType":"module"}