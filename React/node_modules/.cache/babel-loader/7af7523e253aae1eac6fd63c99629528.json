{"ast":null,"code":"'use strict';\n\nconst Utils = require('./../utils');\n\nconst _ = require('lodash');\n\nconst HasOne = require('./has-one');\n\nconst HasMany = require('./has-many');\n\nconst BelongsToMany = require('./belongs-to-many');\n\nconst BelongsTo = require('./belongs-to');\n\nconst Mixin = {\n  hasMany(target, options) {\n    // testhint options:none\n    if (!target || !target.prototype || !(target.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.hasMany called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options = _.extend(options, _.omit(source.options, ['hooks'])); // the id is in the foreign table or in a connecting table\n\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association.injectAttributes();\n    association.mixin(source.prototype);\n    return association;\n  },\n\n  belongsToMany(targetModel, options) {\n    // testhint options:none\n    if (!targetModel || !targetModel.prototype || !(targetModel.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.belongsToMany called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const sourceModel = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    options = _.extend(options, _.omit(sourceModel.options, ['hooks', 'timestamps', 'scopes', 'defaultScope'])); // the id is in the foreign table or in a connecting table\n\n    const association = new BelongsToMany(sourceModel, targetModel, options);\n    sourceModel.associations[association.associationAccessor] = association;\n    association.injectAttributes();\n    association.mixin(sourceModel.prototype);\n    return association;\n  },\n\n  getAssociations(target) {\n    return _.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => this.verifyAssociationAlias(association, alias)) || null;\n  },\n\n  verifyAssociationAlias(association, alias) {\n    if (alias) {\n      return association.as === alias;\n    } else {\n      return !association.isAliased;\n    }\n  }\n\n}; // The logic for hasOne and belongsTo is exactly the same\n\nfunction singleLinked(Type) {\n  return function (target, options) {\n    // testhint options:none\n    if (!target || !target.prototype || !(target.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.' + Utils.lowercaseFirst(Type.toString()) + ' called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks; // the id is in the foreign table\n\n    const association = new Type(source, target, _.extend(options, source.options));\n    source.associations[association.associationAccessor] = association;\n    association.injectAttributes();\n    association.mixin(source.prototype);\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/associations/mixin.js"],"names":["Utils","require","_","HasOne","HasMany","BelongsToMany","BelongsTo","Mixin","hasMany","target","options","prototype","sequelize","Model","Error","name","source","hooks","undefined","Boolean","useHooks","extend","omit","association","associations","associationAccessor","injectAttributes","mixin","belongsToMany","targetModel","sourceModel","timestamps","getAssociations","values","filter","getAssociationForAlias","alias","find","verifyAssociationAlias","as","isAliased","singleLinked","Type","lowercaseFirst","toString","hasOne","belongsTo","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst _ = require('lodash');\nconst HasOne = require('./has-one');\nconst HasMany = require('./has-many');\nconst BelongsToMany = require('./belongs-to-many');\nconst BelongsTo = require('./belongs-to');\n\nconst Mixin = {\n  hasMany(target, options) { // testhint options:none\n    if (!target || !target.prototype || !(target.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.hasMany called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    options = _.extend(options, _.omit(source.options, ['hooks']));\n\n    // the id is in the foreign table or in a connecting table\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association.injectAttributes();\n    association.mixin(source.prototype);\n\n    return association;\n  },\n\n  belongsToMany(targetModel, options) { // testhint options:none\n    if (!targetModel || !targetModel.prototype || !(targetModel.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.belongsToMany called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const sourceModel = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    options = _.extend(options, _.omit(sourceModel.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    // the id is in the foreign table or in a connecting table\n    const association = new BelongsToMany(sourceModel, targetModel, options);\n    sourceModel.associations[association.associationAccessor] = association;\n\n    association.injectAttributes();\n    association.mixin(sourceModel.prototype);\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return _.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => this.verifyAssociationAlias(association, alias)) || null;\n  },\n\n  verifyAssociationAlias(association, alias) {\n    if (alias) {\n      return association.as === alias;\n    } else {\n      return !association.isAliased;\n    }\n  }\n};\n\n// The logic for hasOne and belongsTo is exactly the same\nfunction singleLinked(Type) {\n  return function(target, options) { // testhint options:none\n    if (!target || !target.prototype || !(target.prototype instanceof this.sequelize.Model)) {\n      throw new Error(this.name + '.' + Utils.lowercaseFirst(Type.toString()) + ' called with something that\\'s not a subclass of Sequelize.Model');\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options = options || {};\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    // the id is in the foreign table\n    const association = new Type(source, target, _.extend(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association.injectAttributes();\n    association.mixin(source.prototype);\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\n\nMixin.belongsTo = singleLinked(BelongsTo);\n\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;\n"]},"metadata":{},"sourceType":"script"}