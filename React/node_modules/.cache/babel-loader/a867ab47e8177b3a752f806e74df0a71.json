{"ast":null,"code":"'use strict';\n\nconst Pool = require('./pool.js');\n\nconst PoolConfig = require('./pool_config.js');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Selector\n */\n\n\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n\n  RANDOM() {\n    return clusterIds => clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n\n      return cb(null, connection);\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n\n    const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n\n    const key = pattern + selector;\n\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({\n          config: new PoolConfig(config)\n        })\n      };\n\n      this._serviceableNodeIds.push(id);\n\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n\n      namespace = this.of(pattern, selector);\n    }\n\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb = callback !== undefined ? callback : err => {\n      if (err) {\n        throw err;\n      }\n    };\n\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n\n    this._closed = true;\n    let calledBack = false;\n    let waitingClose = 0;\n\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n\n      this._nodes[id].pool.end();\n    }\n\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n\n    let foundNodeIds;\n\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id => id.startsWith(keyword));\n    }\n\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n\n        delete this._nodes[node.id];\n\n        this._clearFindCaches();\n\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err); // eslint-disable-next-line no-console\n\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n\n        return cb(err);\n      }\n\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n\n}\n\nmodule.exports = PoolCluster;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/mysql2/lib/pool_cluster.js"],"names":["Pool","require","PoolConfig","EventEmitter","makeSelector","RR","index","clusterIds","length","RANDOM","Math","floor","random","ORDER","PoolNamespace","constructor","cluster","pattern","selector","_cluster","_pattern","_selector","getConnection","cb","clusterNode","_getClusterNode","Error","_getConnection","err","connection","foundNodeIds","_findNodeIds","nodeId","_getNode","PoolCluster","config","_canRetry","canRetry","_removeNodeErrorCount","removeNodeErrorCount","_defaultSelector","defaultSelector","_closed","_lastId","_nodes","_serviceableNodeIds","_namespaces","_findCaches","of","toUpperCase","key","add","id","errorCount","pool","push","_clearFindCaches","namespace","end","callback","undefined","process","nextTick","calledBack","waitingClose","onEnd","indexOf","keyword","substring","filter","startsWith","_increaseErrorCount","node","splice","emit","_decreaseErrorCount","console","warn","_clusterId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Pool = require('./pool.js');\nconst PoolConfig = require('./pool_config.js');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Selector\n */\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n  RANDOM() {\n    return clusterIds =>\n      clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n      return cb(null, connection);\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n    const nodeId =\n      foundNodeIds.length === 1\n        ? foundNodeIds[0]\n        : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry =\n      typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n    const key = pattern + selector;\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({ config: new PoolConfig(config) })\n      };\n      this._serviceableNodeIds.push(id);\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n      namespace = this.of(pattern, selector);\n    }\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb =\n      callback !== undefined\n        ? callback\n        : err => {\n          if (err) {\n            throw err;\n          }\n        };\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this._closed = true;\n\n    let calledBack = false;\n    let waitingClose = 0;\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n      this._nodes[id].pool.end();\n    }\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n    let foundNodeIds;\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id =>\n        id.startsWith(keyword)\n      );\n    }\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n        delete this._nodes[node.id];\n        this._clearFindCaches();\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err);\n          // eslint-disable-next-line no-console\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n        return cb(err);\n      }\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n}\n\nmodule.exports = PoolCluster;\n"]},"metadata":{},"sourceType":"script"}