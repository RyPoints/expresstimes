{"ast":null,"code":"'use strict';\n\nconst Utils = require('../../utils');\n\nconst util = require('util');\n\nconst Transaction = require('../../transaction');\n\nconst _ = require('lodash');\n\nconst MySqlQueryGenerator = require('../mysql/query-generator');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst QueryGenerator = {\n  __proto__: MySqlQueryGenerator,\n  options: {},\n  dialect: 'sqlite',\n\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  },\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = _.values(attributes).filter(definition => _.includes(definition, 'PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (attributes.hasOwnProperty(attr)) {\n        let dataType = attributes[attr];\n\n        const containsAutoIncrement = _.includes(dataType, 'AUTOINCREMENT');\n\n        if (containsAutoIncrement) {\n          dataType = dataType.replace(/BIGINT/, 'INTEGER');\n        }\n\n        let dataTypeString = dataType;\n\n        if (_.includes(dataType, 'PRIMARY KEY')) {\n          if (_.includes(dataType, 'INTEGER')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            dataTypeString = dataType.replace(/PRIMARY KEY/, 'NOT NULL');\n          }\n        }\n\n        attrArray.push(this.quoteIdentifier(attr) + ' ' + dataTypeString);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  },\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  },\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {String}  stmt  The statement to validate\n   * @returns {Boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (!_.isString(stmt)) {\n      return false;\n    } // https://sqlite.org/json1.html\n\n\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error('Invalid json statement: ' + stmt);\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  },\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {String}               column  The JSON column\n   * @param   {String|Array<String>} [path]  The path to extract (optional)\n   * @returns {String}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    const paths = _.toPath(path);\n\n    const pathStr = this.escape(['$'].concat(paths).join('.').replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (_, digit) => `[${digit}]`));\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    return `json_extract(${quotedColumn}, ${pathStr})`;\n  },\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    } else if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n\n    return value;\n  },\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(_.first(condition.path), _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(' AND ');\n      } else if (smth.path) {\n        let str; // Allow specifying conditions using the sqlite json functions\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  },\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, {\n      context: 'addColumn'\n    });\n    const attribute = this.quoteIdentifier(key) + ' ' + fields[key];\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  },\n\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n    const sql = this.insertQuery(tableName, insertValues, model.rawAttributes, options) + ' ' + this.updateQuery(tableName, updateValues, where, options, model.rawAttributes);\n    return sql;\n  },\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n        context: 'UPDATE'\n      }));\n    }\n\n    if (options.limit) {\n      return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, options)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, options)}`;\n    }\n  },\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n\n    _.defaults(options, this.options);\n\n    if (options.truncate === true) {\n      // Truncate does not allow LIMIT and WHERE\n      return `DELETE FROM ${this.quoteTable(tableName)}`;\n    }\n\n    if (_.isUndefined(options.limit)) {\n      options.limit = 1;\n    }\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  },\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (dataType.hasOwnProperty('allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ' DEFAULT ' + this.escape(dataType.defaultValue, dataType);\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ' ON DELETE ' + dataType.onDelete.toUpperCase();\n          }\n\n          if (dataType.onUpdate) {\n            sql += ' ON UPDATE ' + dataType.onUpdate.toUpperCase();\n          }\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  },\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  },\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return sql + ';';\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  },\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  },\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  },\n\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', '); // Temporary table cannot work for foreign keys.\n\n    return this.createTableQuery(backupTableName, attributes) + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};` + `DROP TABLE ${quotedTableName};` + this.createTableQuery(tableName, attributes) + `INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};` + `DROP TABLE ${quotedBackupTableName};`;\n  },\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n    return createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`) + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};` + `DROP TABLE ${quotedTableName};` + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  },\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => attrNameAfter === attr ? this.quoteIdentifier(attrNameBefore) + ' AS ' + this.quoteIdentifier(attr) : this.quoteIdentifier(attr)).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n    return this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE') + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};` + `DROP TABLE ${quotedTableName};` + this.createTableQuery(tableName, attributes) + `INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};` + `DROP TABLE ${quotedBackupTableName};`;\n  },\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name) + ';';\n    }\n\n    return 'BEGIN ' + transaction.options.type + ' TRANSACTION;';\n  },\n\n  setAutocommitQuery() {\n    // SQLite does not support SET autocommit\n    return null;\n  },\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n\n      default:\n        throw new Error('Unknown isolation level: ' + value);\n    }\n  },\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  },\n\n  quoteIdentifier(identifier) {\n    if (identifier === '*') return identifier;\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n\n};\nmodule.exports = QueryGenerator;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/dialects/sqlite/query-generator.js"],"names":["Utils","require","util","Transaction","_","MySqlQueryGenerator","AbstractQueryGenerator","QueryGenerator","__proto__","options","dialect","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","primaryKeys","needsMultiplePrimaryKeys","values","filter","definition","includes","length","attrArray","attr","hasOwnProperty","dataType","containsAutoIncrement","replace","dataTypeString","push","quoteIdentifier","table","quoteTable","attrStr","join","pkString","map","pk","uniqueKeys","each","columns","customIndex","fields","field","sql","replaceBooleanDefaults","booleanValue","value","_checkValidJsonStatement","stmt","isString","jsonFunctionRegex","tokenCaptureRegex","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","indexOf","tokenMatches","capturedToken","Error","jsonPathExtractionQuery","column","path","paths","toPath","pathStr","escape","concat","digit","quotedColumn","isIdentifierQuoted","_toJSONValue","Date","toISOString","Array","isArray","val","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","first","tail","str","shift","format","Cast","test","type","call","addColumnQuery","key","attributesToSQL","context","attribute","showTablesQuery","upsertQuery","insertValues","updateValues","where","model","ignoreDuplicates","insertQuery","rawAttributes","updateQuery","attrValueHash","defaults","removeNullValuesFromHash","omitNull","modelAttributeMap","undefined","limit","whereQuery","deleteQuery","truncate","isUndefined","whereClause","getWhereConditions","result","name","fieldName","isObject","toString","allowNull","defaultValueSchemable","defaultValue","unique","primaryKey","autoIncrement","references","referencesTable","referencesKey","onDelete","toUpperCase","onUpdate","showIndexesQuery","showConstraintsQuery","constraintName","removeIndexQuery","indexNameOrAttributes","indexName","underscore","describeTableQuery","schema","schemaDelimiter","_schema","_schemaDelimiter","addSchema","describeCreateTableQuery","removeColumnQuery","backupTableName","quotedTableName","quotedBackupTableName","attributeNames","Object","keys","_alterConstraintQuery","createTableSql","renameColumnQuery","attrNameBefore","attrNameAfter","attributeNamesImport","attributeNamesExport","startTransactionQuery","transaction","parent","setAutocommitQuery","setIsolationLevelQuery","ISOLATION_LEVELS","REPEATABLE_READ","READ_UNCOMMITTED","READ_COMMITTED","SERIALIZABLE","identifier","addTicks","removeTicks","getForeignKeysQuery","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst QueryGenerator = {\n  __proto__: MySqlQueryGenerator,\n  options: {},\n  dialect: 'sqlite',\n\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  },\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = _.values(attributes).filter(definition => _.includes(definition, 'PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (attributes.hasOwnProperty(attr)) {\n        let dataType = attributes[attr];\n        const containsAutoIncrement = _.includes(dataType, 'AUTOINCREMENT');\n\n        if (containsAutoIncrement) {\n          dataType = dataType.replace(/BIGINT/, 'INTEGER');\n        }\n\n        let dataTypeString = dataType;\n        if (_.includes(dataType, 'PRIMARY KEY')) {\n          if (_.includes(dataType, 'INTEGER')) { // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            dataTypeString = dataType.replace(/PRIMARY KEY/, 'NOT NULL');\n          }\n        }\n        attrArray.push(this.quoteIdentifier(attr) + ' ' + dataTypeString);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  },\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  },\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {String}  stmt  The statement to validate\n   * @returns {Boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (!_.isString(stmt)) {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error('Invalid json statement: ' + stmt);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  },\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {String}               column  The JSON column\n   * @param   {String|Array<String>} [path]  The path to extract (optional)\n   * @returns {String}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    const paths = _.toPath(path);\n    const pathStr = this.escape(['$']\n      .concat(paths)\n      .join('.')\n      .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (_, digit) => `[${digit}]`));\n\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    return `json_extract(${quotedColumn}, ${pathStr})`;\n  },\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    } else if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  },\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(_.first(condition.path), _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      } else if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  },\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = this.quoteIdentifier(key) + ' ' + fields[key];\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  },\n\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.ignoreDuplicates = true;\n\n    const sql = this.insertQuery(tableName, insertValues, model.rawAttributes, options) + ' ' + this.updateQuery(tableName, updateValues, where, options, model.rawAttributes);\n\n    return sql;\n  },\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      values.push(this.quoteIdentifier(key) + '=' + this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }));\n    }\n\n    if (options.limit) {\n      return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, options)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      return `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, options)}`;\n    }\n  },\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    if (options.truncate === true) {\n      // Truncate does not allow LIMIT and WHERE\n      return `DELETE FROM ${this.quoteTable(tableName)}`;\n    }\n\n    if (_.isUndefined(options.limit)) {\n      options.limit = 1;\n    }\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  },\n\n  attributesToSQL(attributes) {\n    const result = {};\n\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (dataType.hasOwnProperty('allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ' DEFAULT ' + this.escape(dataType.defaultValue, dataType);\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ' ON DELETE ' + dataType.onDelete.toUpperCase();\n          }\n\n          if (dataType.onUpdate) {\n            sql += ' ON UPDATE ' + dataType.onUpdate.toUpperCase();\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  },\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  },\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql =  `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return sql + ';';\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  },\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  },\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  },\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return this.createTableQuery(backupTableName, attributes)\n      + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + this.createTableQuery(tableName, attributes)\n      + `INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  },\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  },\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: tableName.tableName + '_backup',\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = tableName + '_backup';\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? this.quoteIdentifier(attrNameBefore) + ' AS ' + this.quoteIdentifier(attr) : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return this.createTableQuery(backupTableName, attributes).replace('CREATE TABLE', 'CREATE TEMPORARY TABLE')\n      + `INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + this.createTableQuery(tableName, attributes)\n      + `INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  },\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return 'SAVEPOINT ' + this.quoteIdentifier(transaction.name) + ';';\n    }\n\n    return 'BEGIN ' + transaction.options.type + ' TRANSACTION;';\n  },\n\n  setAutocommitQuery() {\n    // SQLite does not support SET autocommit\n    return null;\n  },\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n      default:\n        throw new Error('Unknown isolation level: ' + value);\n    }\n  },\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  },\n\n  quoteIdentifier(identifier) {\n    if (identifier === '*') return identifier;\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${tableName})`;\n  }\n};\n\nmodule.exports = QueryGenerator;\n"]},"metadata":{},"sourceType":"script"}