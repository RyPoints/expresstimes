{"ast":null,"code":"var includes = require('lodash/includes');\n\nvar trimEnd = require('lodash/trimEnd');\n\nvar htmlparser = require('htmlparser2');\n\nvar helper = require('./helper');\n\nvar defaultFormat = require('./formatter'); // Which type of tags should not be parsed\n\n\nvar SKIP_TYPES = ['style', 'script'];\n\nfunction htmlToText(html, options) {\n  options = Object.assign({\n    wordwrap: 80,\n    tables: [],\n    preserveNewlines: false,\n    uppercaseHeadings: true,\n    singleNewLineParagraphs: false,\n    hideLinkHrefIfSameAsText: false,\n    linkHrefBaseUrl: null,\n    noLinkBrackets: false,\n    noAnchorUrl: true,\n    baseElement: 'body',\n    returnDomByDefault: true,\n    format: {},\n    decodeOptions: {\n      isAttributeValue: false,\n      strict: false\n    },\n    longWordSplit: {\n      wrapCharacters: [],\n      forceWrapOnLimit: false\n    },\n    unorderedListItemPrefix: ' * '\n  }, options || {});\n  var handler = new htmlparser.DefaultHandler(function (error, dom) {}, {\n    verbose: true\n  });\n  new htmlparser.Parser(handler).parseComplete(html);\n  options.lineCharCount = 0;\n  var result = '';\n  var baseElements = Array.isArray(options.baseElement) ? options.baseElement : [options.baseElement];\n\n  for (var idx = 0; idx < baseElements.length; ++idx) {\n    result += walk(filterBody(handler.dom, options, baseElements[idx]), options);\n  }\n\n  return trimEnd(result);\n}\n\nfunction filterBody(dom, options, baseElement) {\n  var result = null;\n  var splitTag = helper.splitCssSearchTag(baseElement);\n\n  function walk(dom) {\n    if (result) return;\n    dom.forEach(function (elem) {\n      if (result) return;\n\n      if (elem.name === splitTag.element) {\n        var documentClasses = elem.attribs && elem.attribs.class ? elem.attribs.class.split(\" \") : [];\n        var documentIds = elem.attribs && elem.attribs.id ? elem.attribs.id.split(\" \") : [];\n\n        if (splitTag.classes.every(function (val) {\n          return documentClasses.indexOf(val) >= 0;\n        }) && splitTag.ids.every(function (val) {\n          return documentIds.indexOf(val) >= 0;\n        })) {\n          result = [elem];\n          return;\n        }\n      }\n\n      if (elem.children) walk(elem.children);\n    });\n  }\n\n  walk(dom);\n  return options.returnDomByDefault ? result || dom : result;\n}\n\nfunction containsTable(attr, tables) {\n  if (tables === true) return true;\n\n  function removePrefix(key) {\n    return key.substr(1);\n  }\n\n  function checkPrefix(prefix) {\n    return function (key) {\n      return key.startsWith(prefix);\n    };\n  }\n\n  function filterByPrefix(tables, prefix) {\n    return tables.filter(checkPrefix(prefix)).map(removePrefix);\n  }\n\n  var classes = filterByPrefix(tables, '.');\n  var ids = filterByPrefix(tables, '#');\n  return attr && (includes(classes, attr['class']) || includes(ids, attr['id']));\n}\n\nfunction walk(dom, options, result) {\n  if (arguments.length < 3) {\n    result = '';\n  }\n\n  var whiteSpaceRegex = /\\s$/;\n  var format = Object.assign({}, defaultFormat, options.format);\n\n  if (!dom) {\n    return result;\n  }\n\n  dom.forEach(function (elem) {\n    switch (elem.type) {\n      case 'tag':\n        switch (elem.name.toLowerCase()) {\n          case 'img':\n            result += format.image(elem, options);\n            break;\n\n          case 'a':\n            // Inline element needs its leading space to be trimmed if `result`\n            // currently ends with whitespace\n            elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n            result += format.anchor(elem, walk, options);\n            break;\n\n          case 'p':\n            result += format.paragraph(elem, walk, options);\n            break;\n\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            result += format.heading(elem, walk, options);\n            break;\n\n          case 'br':\n            result += format.lineBreak(elem, walk, options);\n            break;\n\n          case 'hr':\n            result += format.horizontalLine(elem, walk, options);\n            break;\n\n          case 'ul':\n            result += format.unorderedList(elem, walk, options);\n            break;\n\n          case 'ol':\n            result += format.orderedList(elem, walk, options);\n            break;\n\n          case 'pre':\n            var newOptions = Object.assign({}, options);\n            newOptions.isInPre = true;\n            result += format.paragraph(elem, walk, newOptions);\n            break;\n\n          case 'table':\n            result = containsTable(elem.attribs, options.tables) ? result + format.table(elem, walk, options) : walk(elem.children || [], options, result);\n            break;\n\n          case 'blockquote':\n            result += format.blockquote(elem, walk, options);\n            break;\n\n          default:\n            result = walk(elem.children || [], options, result);\n        }\n\n        break;\n\n      case 'text':\n        if (elem.data !== '\\r\\n') {\n          // Text needs its leading space to be trimmed if `result`\n          // currently ends with whitespace\n          elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n          result += format.text(elem, options);\n        }\n\n        break;\n\n      default:\n        if (!includes(SKIP_TYPES, elem.type)) {\n          result = walk(elem.children || [], options, result);\n        }\n\n    }\n\n    options.lineCharCount = result.length - (result.lastIndexOf('\\n') + 1);\n  });\n  return result;\n}\n\nexports.fromString = function (str, options) {\n  return htmlToText(str, options || {});\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/html-to-text/lib/html-to-text.js"],"names":["includes","require","trimEnd","htmlparser","helper","defaultFormat","SKIP_TYPES","htmlToText","html","options","Object","assign","wordwrap","tables","preserveNewlines","uppercaseHeadings","singleNewLineParagraphs","hideLinkHrefIfSameAsText","linkHrefBaseUrl","noLinkBrackets","noAnchorUrl","baseElement","returnDomByDefault","format","decodeOptions","isAttributeValue","strict","longWordSplit","wrapCharacters","forceWrapOnLimit","unorderedListItemPrefix","handler","DefaultHandler","error","dom","verbose","Parser","parseComplete","lineCharCount","result","baseElements","Array","isArray","idx","length","walk","filterBody","splitTag","splitCssSearchTag","forEach","elem","name","element","documentClasses","attribs","class","split","documentIds","id","classes","every","val","indexOf","ids","children","containsTable","attr","removePrefix","key","substr","checkPrefix","prefix","startsWith","filterByPrefix","filter","map","arguments","whiteSpaceRegex","type","toLowerCase","image","trimLeadingSpace","test","anchor","paragraph","heading","lineBreak","horizontalLine","unorderedList","orderedList","newOptions","isInPre","table","blockquote","data","text","lastIndexOf","exports","fromString","str"],"mappings":"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","sourcesContent":["var includes = require('lodash/includes');\nvar trimEnd = require('lodash/trimEnd');\nvar htmlparser = require('htmlparser2');\n\nvar helper = require('./helper');\nvar defaultFormat = require('./formatter');\n\n// Which type of tags should not be parsed\nvar SKIP_TYPES = [\n  'style',\n  'script'\n];\n\nfunction htmlToText(html, options) {\n  options = Object.assign({\n    wordwrap: 80,\n    tables: [],\n    preserveNewlines: false,\n    uppercaseHeadings: true,\n    singleNewLineParagraphs: false,\n    hideLinkHrefIfSameAsText: false,\n    linkHrefBaseUrl: null,\n    noLinkBrackets: false,\n    noAnchorUrl: true,\n    baseElement: 'body',\n    returnDomByDefault: true,\n    format: {},\n    decodeOptions: {\n      isAttributeValue: false,\n      strict: false\n    },\n    longWordSplit: {\n      wrapCharacters: [],\n      forceWrapOnLimit: false\n    },\n    unorderedListItemPrefix: ' * '\n  }, options || {});\n\n  var handler = new htmlparser.DefaultHandler(function (error, dom) {\n\n  }, {\n    verbose: true\n  });\n  new htmlparser.Parser(handler).parseComplete(html);\n\n  options.lineCharCount = 0;\n\n  var result = '';\n  var baseElements = Array.isArray(options.baseElement) ? options.baseElement : [options.baseElement];\n  for (var idx = 0; idx < baseElements.length; ++idx) {\n    result += walk(filterBody(handler.dom, options, baseElements[idx]), options);\n  }\n  return trimEnd(result);\n}\n\nfunction filterBody(dom, options, baseElement) {\n  var result = null;\n\n  var splitTag = helper.splitCssSearchTag(baseElement);\n\n  function walk(dom) {\n    if (result) return;\n    dom.forEach(function(elem) {\n      if (result) return;\n      if (elem.name === splitTag.element) {\n        var documentClasses = elem.attribs && elem.attribs.class ? elem.attribs.class.split(\" \") : [];\n        var documentIds = elem.attribs && elem.attribs.id ? elem.attribs.id.split(\" \") : [];\n\n        if ((splitTag.classes.every(function (val) { return documentClasses.indexOf(val) >= 0; })) &&\n          (splitTag.ids.every(function (val) { return documentIds.indexOf(val) >= 0; }))) {\n          result = [elem];\n          return;\n        }\n      }\n      if (elem.children) walk(elem.children);\n    });\n  }\n  walk(dom);\n  return options.returnDomByDefault ? result || dom : result;\n}\n\nfunction containsTable(attr, tables) {\n  if (tables === true) return true;\n\n  function removePrefix(key) {\n    return key.substr(1);\n  }\n  function checkPrefix(prefix) {\n    return function(key) {\n      return key.startsWith(prefix);\n    };\n  }\n  function filterByPrefix(tables, prefix) {\n    return tables\n      .filter(checkPrefix(prefix))\n      .map(removePrefix);\n  }\n  var classes = filterByPrefix(tables, '.');\n  var ids = filterByPrefix(tables, '#');\n  return attr && (includes(classes, attr['class']) || includes(ids, attr['id']));\n}\n\nfunction walk(dom, options, result) {\n  if (arguments.length < 3) {\n    result = '';\n  }\n  var whiteSpaceRegex = /\\s$/;\n  var format = Object.assign({}, defaultFormat, options.format);\n\n  if (!dom) {\n    return result;\n  }\n\n  dom.forEach(function(elem) {\n    switch(elem.type) {\n      case 'tag':\n        switch(elem.name.toLowerCase()) {\n          case 'img':\n            result += format.image(elem, options);\n            break;\n          case 'a':\n            // Inline element needs its leading space to be trimmed if `result`\n            // currently ends with whitespace\n            elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n            result += format.anchor(elem, walk, options);\n            break;\n          case 'p':\n            result += format.paragraph(elem, walk, options);\n            break;\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            result += format.heading(elem, walk, options);\n            break;\n          case 'br':\n            result += format.lineBreak(elem, walk, options);\n            break;\n          case 'hr':\n            result += format.horizontalLine(elem, walk, options);\n            break;\n          case 'ul':\n            result += format.unorderedList(elem, walk, options);\n            break;\n          case 'ol':\n            result += format.orderedList(elem, walk, options);\n            break;\n          case 'pre':\n            var newOptions = Object.assign({}, options);\n            newOptions.isInPre = true;\n            result += format.paragraph(elem, walk, newOptions);\n            break;\n          case 'table':\n            result = containsTable(elem.attribs, options.tables)\n              ? result + format.table(elem, walk, options)\n              : walk(elem.children || [], options, result);\n            break;\n          case 'blockquote':\n            result += format.blockquote(elem, walk, options);\n            break;\n          default:\n            result = walk(elem.children || [], options, result);\n        }\n        break;\n      case 'text':\n        if (elem.data !== '\\r\\n') {\n          // Text needs its leading space to be trimmed if `result`\n          // currently ends with whitespace\n          elem.trimLeadingSpace = whiteSpaceRegex.test(result);\n          result += format.text(elem, options);\n        }\n        break;\n      default:\n        if (!includes(SKIP_TYPES, elem.type)) {\n          result = walk(elem.children || [], options, result);\n        }\n    }\n\n    options.lineCharCount = result.length - (result.lastIndexOf('\\n') + 1);\n  });\n  return result;\n}\n\nexports.fromString = function(str, options) {\n  return htmlToText(str, options || {});\n};\n"]},"metadata":{},"sourceType":"script"}