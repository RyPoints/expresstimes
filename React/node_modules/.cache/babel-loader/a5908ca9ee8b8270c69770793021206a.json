{"ast":null,"code":"'use strict';\n\nconst Utils = require('./../utils');\n\nconst Helpers = require('./helpers');\n\nconst _ = require('lodash');\n\nconst Association = require('./base');\n\nconst Op = require('../operators');\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.\n *\n * @see {@link Model.hasOne}\n */\n\n\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = 'HasOne';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([Utils.singularize(this.options.as || this.source.name), this.source.primaryKeyAttribute].join('_'));\n    }\n\n    if (this.options.sourceKey && !this.source.rawAttributes[this.options.sourceKey]) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    } // Get singular name, trying to uppercase the first letter, unless the model forbids it\n\n\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  } // the id is in the target table\n\n\n  _injectAttributes() {\n    const newAttributes = {};\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {Object}         [options] find options\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n\n\n  get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map(instance => instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n\n        for (const instance of instances) {\n          result[instance.get(this.sourceKey, {\n            raw: true\n          })] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(this.foreignKey, {\n            raw: true\n          })] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options] Options passed to getAssociation and `target.save`\n   *\n   * @returns {Promise}\n   */\n\n\n  set(sourceInstance, associatedInstance, options) {\n    let alreadyAssociated;\n    options = Object.assign({}, options, {\n      scope: false\n    });\n    return sourceInstance[this.accessors.get](options).then(oldInstance => {\n      // TODO Use equals method once #5605 is resolved\n      alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute => oldInstance.get(attribute, {\n        raw: true\n      }) === (associatedInstance.get ? associatedInstance.get(attribute, {\n        raw: true\n      }) : associatedInstance));\n\n      if (oldInstance && !alreadyAssociated) {\n        oldInstance[this.foreignKey] = null;\n        return oldInstance.save(Object.assign({}, options, {\n          fields: [this.foreignKey],\n          allowNull: [this.foreignKey],\n          association: true\n        }));\n      }\n    }).then(() => {\n      if (associatedInstance && !alreadyAssociated) {\n        if (!(associatedInstance instanceof this.target)) {\n          const tmpInstance = {};\n          tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n          associatedInstance = this.target.build(tmpInstance, {\n            isNewRecord: false\n          });\n        }\n\n        Object.assign(associatedInstance, this.scope);\n        associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n        return associatedInstance.save(options);\n      }\n\n      return null;\n    });\n  }\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Object} [values={}] values to create associated model instance with\n   * @param {Object} [options] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create} for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n\n\n  create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n\n    return this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n\n}\n\nmodule.exports = HasOne;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/associations/has-one.js"],"names":["Utils","require","Helpers","_","Association","Op","HasOne","constructor","source","target","options","associationType","isSingleAssociation","foreignKeyAttribute","as","isAliased","name","singular","isObject","foreignKey","fieldName","camelize","singularize","primaryKeyAttribute","join","sourceKey","rawAttributes","Error","sourceKeyAttribute","sourceKeyField","field","sourceKeyIsPrimary","associationAccessor","useHooks","identifierField","upperFirst","accessors","get","set","create","_injectAttributes","newAttributes","defaults","type","keyType","allowNull","constraints","onDelete","onUpdate","addForeignKeyConstraints","mergeDefaults","refreshAttributes","checkNamingCollision","mixin","obj","methods","mixinMethods","instances","where","Target","instance","cloneDeep","Object","prototype","hasOwnProperty","call","scope","unscoped","schema","schemaDelimiter","Array","isArray","undefined","in","map","assign","and","findAll","then","results","result","raw","findOne","sourceInstance","associatedInstance","alreadyAssociated","oldInstance","primaryKeyAttributes","every","attribute","save","fields","association","tmpInstance","build","isNewRecord","values","keys","push","verifyAssociationAlias","alias","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.\n *\n * @see {@link Model.hasOne}\n */\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasOne';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          Utils.singularize(this.options.as || this.source.name),\n          this.source.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    if (\n      this.options.sourceKey\n      && !this.source.rawAttributes[this.options.sourceKey]\n    ) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  // the id is in the target table\n  _injectAttributes() {\n    const newAttributes = {};\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.target.refreshAttributes();\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {Object}         [options] find options\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  get(instances, options) {\n    const where = {};\n\n    let Target = this.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map(instance => instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n        for (const instance of instances) {\n          result[instance.get(this.sourceKey, { raw: true })] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(this.foreignKey, { raw: true })] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options] Options passed to getAssociation and `target.save`\n   *\n   * @returns {Promise}\n   */\n  set(sourceInstance, associatedInstance, options) {\n    let alreadyAssociated;\n\n    options = Object.assign({}, options, {\n      scope: false\n    });\n\n    return sourceInstance[this.accessors.get](options).then(oldInstance => {\n      // TODO Use equals method once #5605 is resolved\n      alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every(attribute =>\n        oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance)\n      );\n\n      if (oldInstance && !alreadyAssociated) {\n        oldInstance[this.foreignKey] = null;\n        return oldInstance.save(Object.assign({}, options, {\n          fields: [this.foreignKey],\n          allowNull: [this.foreignKey],\n          association: true\n        }));\n      }\n    }).then(() => {\n      if (associatedInstance && !alreadyAssociated) {\n        if (!(associatedInstance instanceof this.target)) {\n          const tmpInstance = {};\n          tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n          associatedInstance = this.target.build(tmpInstance, {\n            isNewRecord: false\n          });\n        }\n\n        Object.assign(associatedInstance, this.scope);\n        associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n\n        return associatedInstance.save(options);\n      }\n\n      return null;\n    });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Object} [values={}] values to create associated model instance with\n   * @param {Object} [options] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create} for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n  create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n\n    return this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = HasOne;\n"]},"metadata":{},"sourceType":"script"}