{"ast":null,"code":"'use strict'; // connection mixins\n// implementation of http://dev.mysql.com/doc/internals/en/compression.html\n\nconst zlib = require('zlib');\n\nconst PacketParser = require('./packet_parser.js');\n\nfunction handleCompressedPacket(packet) {\n  // eslint-disable-next-line consistent-this, no-invalid-this\n  const connection = this;\n  const deflatedLength = packet.readInt24();\n  const body = packet.readBuffer();\n\n  if (deflatedLength !== 0) {\n    connection.inflateQueue.push(task => {\n      zlib.inflate(body, (err, data) => {\n        if (err) {\n          connection._handleNetworkError(err);\n\n          return;\n        }\n\n        connection._bumpCompressedSequenceId(packet.numPackets);\n\n        connection._inflatedPacketsParser.execute(data);\n\n        task.done();\n      });\n    });\n  } else {\n    connection.inflateQueue.push(task => {\n      connection._bumpCompressedSequenceId(packet.numPackets);\n\n      connection._inflatedPacketsParser.execute(body);\n\n      task.done();\n    });\n  }\n}\n\nfunction writeCompressed(buffer) {\n  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html\n  // note: sending a MySQL Packet of the size 2^24−5 to 2^24−1 via compression\n  // leads to at least one extra compressed packet.\n  // (this is because \"length of the packet before compression\" need to fit\n  // into 3 byte unsigned int. \"length of the packet before compression\" includes\n  // 4 byte packet header, hence 2^24−5)\n  const MAX_COMPRESSED_LENGTH = 16777210;\n  let start;\n\n  if (buffer.length > MAX_COMPRESSED_LENGTH) {\n    for (start = 0; start < buffer.length; start += MAX_COMPRESSED_LENGTH) {\n      writeCompressed.call( // eslint-disable-next-line no-invalid-this\n      this, buffer.slice(start, start + MAX_COMPRESSED_LENGTH));\n    }\n\n    return;\n  } // eslint-disable-next-line no-invalid-this, consistent-this\n\n\n  const connection = this;\n  let packetLen = buffer.length;\n  const compressHeader = Buffer.allocUnsafe(7); // seqqueue is used here because zlib async execution is routed via thread pool\n  // internally and when we have multiple compressed packets arriving we need\n  // to assemble uncompressed result sequentially\n\n  (function (seqId) {\n    connection.deflateQueue.push(task => {\n      zlib.deflate(buffer, (err, compressed) => {\n        if (err) {\n          connection._handleFatalError(err);\n\n          return;\n        }\n\n        let compressedLength = compressed.length;\n\n        if (compressedLength < packetLen) {\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\n          compressHeader.writeUInt8(seqId, 3);\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\n          connection.writeUncompressed(compressHeader);\n          connection.writeUncompressed(compressed);\n        } else {\n          // http://dev.mysql.com/doc/internals/en/uncompressed-payload.html\n          // To send an uncompressed payload:\n          //   - set length of payload before compression to 0\n          //   - the compressed payload contains the uncompressed payload instead.\n          compressedLength = packetLen;\n          packetLen = 0;\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\n          compressHeader.writeUInt8(seqId, 3);\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\n          connection.writeUncompressed(compressHeader);\n          connection.writeUncompressed(buffer);\n        }\n\n        task.done();\n      });\n    });\n  })(connection.compressedSequenceId);\n\n  connection._bumpCompressedSequenceId(1);\n}\n\nfunction enableCompression(connection) {\n  connection._lastWrittenPacketId = 0;\n  connection._lastReceivedPacketId = 0;\n  connection._handleCompressedPacket = handleCompressedPacket;\n  connection._inflatedPacketsParser = new PacketParser(p => {\n    connection.handlePacket(p);\n  }, 4);\n  connection._inflatedPacketsParser._lastPacket = 0;\n  connection.packetParser = new PacketParser(packet => {\n    connection._handleCompressedPacket(packet);\n  }, 7);\n  connection.writeUncompressed = connection.write;\n  connection.write = writeCompressed;\n\n  const seqqueue = require('seq-queue');\n\n  connection.inflateQueue = seqqueue.createQueue();\n  connection.deflateQueue = seqqueue.createQueue();\n}\n\nmodule.exports = {\n  enableCompression: enableCompression\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/mysql2/lib/compressed_protocol.js"],"names":["zlib","require","PacketParser","handleCompressedPacket","packet","connection","deflatedLength","readInt24","body","readBuffer","inflateQueue","push","task","inflate","err","data","_handleNetworkError","_bumpCompressedSequenceId","numPackets","_inflatedPacketsParser","execute","done","writeCompressed","buffer","MAX_COMPRESSED_LENGTH","start","length","call","slice","packetLen","compressHeader","Buffer","allocUnsafe","seqId","deflateQueue","deflate","compressed","_handleFatalError","compressedLength","writeUInt8","writeUInt16LE","writeUncompressed","compressedSequenceId","enableCompression","_lastWrittenPacketId","_lastReceivedPacketId","_handleCompressedPacket","p","handlePacket","_lastPacket","packetParser","write","seqqueue","createQueue","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// connection mixins\n// implementation of http://dev.mysql.com/doc/internals/en/compression.html\n\nconst zlib = require('zlib');\nconst PacketParser = require('./packet_parser.js');\n\nfunction handleCompressedPacket(packet) {\n  // eslint-disable-next-line consistent-this, no-invalid-this\n  const connection = this;\n  const deflatedLength = packet.readInt24();\n  const body = packet.readBuffer();\n\n  if (deflatedLength !== 0) {\n    connection.inflateQueue.push(task => {\n      zlib.inflate(body, (err, data) => {\n        if (err) {\n          connection._handleNetworkError(err);\n          return;\n        }\n        connection._bumpCompressedSequenceId(packet.numPackets);\n        connection._inflatedPacketsParser.execute(data);\n        task.done();\n      });\n    });\n  } else {\n    connection.inflateQueue.push(task => {\n      connection._bumpCompressedSequenceId(packet.numPackets);\n      connection._inflatedPacketsParser.execute(body);\n      task.done();\n    });\n  }\n}\n\nfunction writeCompressed(buffer) {\n  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html\n  // note: sending a MySQL Packet of the size 2^24−5 to 2^24−1 via compression\n  // leads to at least one extra compressed packet.\n  // (this is because \"length of the packet before compression\" need to fit\n  // into 3 byte unsigned int. \"length of the packet before compression\" includes\n  // 4 byte packet header, hence 2^24−5)\n  const MAX_COMPRESSED_LENGTH = 16777210;\n  let start;\n  if (buffer.length > MAX_COMPRESSED_LENGTH) {\n    for (start = 0; start < buffer.length; start += MAX_COMPRESSED_LENGTH) {\n      writeCompressed.call(\n        // eslint-disable-next-line no-invalid-this\n        this,\n        buffer.slice(start, start + MAX_COMPRESSED_LENGTH)\n      );\n    }\n    return;\n  }\n\n  // eslint-disable-next-line no-invalid-this, consistent-this\n  const connection = this;\n\n  let packetLen = buffer.length;\n  const compressHeader = Buffer.allocUnsafe(7);\n\n  // seqqueue is used here because zlib async execution is routed via thread pool\n  // internally and when we have multiple compressed packets arriving we need\n  // to assemble uncompressed result sequentially\n  (function(seqId) {\n    connection.deflateQueue.push(task => {\n      zlib.deflate(buffer, (err, compressed) => {\n        if (err) {\n          connection._handleFatalError(err);\n          return;\n        }\n        let compressedLength = compressed.length;\n\n        if (compressedLength < packetLen) {\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\n          compressHeader.writeUInt8(seqId, 3);\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\n          connection.writeUncompressed(compressHeader);\n          connection.writeUncompressed(compressed);\n        } else {\n          // http://dev.mysql.com/doc/internals/en/uncompressed-payload.html\n          // To send an uncompressed payload:\n          //   - set length of payload before compression to 0\n          //   - the compressed payload contains the uncompressed payload instead.\n          compressedLength = packetLen;\n          packetLen = 0;\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\n          compressHeader.writeUInt8(seqId, 3);\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\n          connection.writeUncompressed(compressHeader);\n          connection.writeUncompressed(buffer);\n        }\n        task.done();\n      });\n    });\n  })(connection.compressedSequenceId);\n  connection._bumpCompressedSequenceId(1);\n}\n\nfunction enableCompression(connection) {\n  connection._lastWrittenPacketId = 0;\n  connection._lastReceivedPacketId = 0;\n\n  connection._handleCompressedPacket = handleCompressedPacket;\n  connection._inflatedPacketsParser = new PacketParser(p => {\n    connection.handlePacket(p);\n  }, 4);\n  connection._inflatedPacketsParser._lastPacket = 0;\n  connection.packetParser = new PacketParser(packet => {\n    connection._handleCompressedPacket(packet);\n  }, 7);\n\n  connection.writeUncompressed = connection.write;\n  connection.write = writeCompressed;\n\n  const seqqueue = require('seq-queue');\n  connection.inflateQueue = seqqueue.createQueue();\n  connection.deflateQueue = seqqueue.createQueue();\n}\n\nmodule.exports = {\n  enableCompression: enableCompression\n};\n"]},"metadata":{},"sourceType":"script"}