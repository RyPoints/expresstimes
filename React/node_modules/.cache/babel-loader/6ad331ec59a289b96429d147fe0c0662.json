{"ast":null,"code":"'use strict';\n\nconst Utils = require('./../utils');\n\nconst Helpers = require('./helpers');\n\nconst _ = require('lodash');\n\nconst Association = require('./base');\n\nconst Op = require('../operators');\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.\n *\n * @see {@link Model.hasOne}\n */\n\n\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = 'HasOne';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelizeIf([Utils.underscoredIf(Utils.singularize(this.options.as || this.source.name), this.target.options.underscored), this.source.primaryKeyAttribute].join('_'), !this.source.options.underscored);\n    }\n\n    this.sourceIdentifier = this.source.primaryKeyAttribute;\n    this.sourceKey = this.source.primaryKeyAttribute;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    } // Get singular name, trying to uppercase the first letter, unless the model forbids it\n\n\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n    this.accessors = {\n      get: 'get' + singular,\n      set: 'set' + singular,\n      create: 'create' + singular\n    };\n  } // the id is in the target table\n\n\n  injectAttributes() {\n    const newAttributes = {};\n    const keyType = this.source.rawAttributes[this.source.primaryKeyAttribute].type;\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || keyType,\n      allowNull: true\n    });\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(this.target.rawAttributes[this.foreignKey], this.source, this.target, this.options); // Sync attributes and setters/getters to Model prototype\n\n    this.target.refreshAttributes();\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  /**\n   * Get the associated instance.\n   *\n   * @param {Object} [options]\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findOne} for a full explanation of options\n   * @return {Promise<Model>}\n   */\n\n\n  get(instances, options) {\n    const association = this;\n    const where = {};\n    let Target = association.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[association.foreignKey] = {\n        [Op.in]: instances.map(instance => instance.get(association.sourceKey))\n      };\n    } else {\n      where[association.foreignKey] = instance.get(association.sourceKey);\n    }\n\n    if (association.scope) {\n      _.assign(where, association.scope);\n    }\n\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n\n        for (const instance of instances) {\n          result[instance.get(association.sourceKey, {\n            raw: true\n          })] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(association.foreignKey, {\n            raw: true\n          })] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n  /**\n   * Set the associated model.\n   *\n   * @param {Model|String|Number} [newAssociation] An persisted instance or the primary key of a persisted instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options] Options passed to getAssociation and `target.save`\n   * @return {Promise}\n   */\n\n\n  set(sourceInstance, associatedInstance, options) {\n    const association = this;\n    let alreadyAssociated;\n    options = _.assign({}, options, {\n      scope: false\n    });\n    return sourceInstance[association.accessors.get](options).then(oldInstance => {\n      // TODO Use equals method once #5605 is resolved\n      alreadyAssociated = oldInstance && associatedInstance && _.every(association.target.primaryKeyAttributes, attribute => oldInstance.get(attribute, {\n        raw: true\n      }) === (associatedInstance.get ? associatedInstance.get(attribute, {\n        raw: true\n      }) : associatedInstance));\n\n      if (oldInstance && !alreadyAssociated) {\n        oldInstance[association.foreignKey] = null;\n        return oldInstance.save(_.extend({}, options, {\n          fields: [association.foreignKey],\n          allowNull: [association.foreignKey],\n          association: true\n        }));\n      }\n    }).then(() => {\n      if (associatedInstance && !alreadyAssociated) {\n        if (!(associatedInstance instanceof association.target)) {\n          const tmpInstance = {};\n          tmpInstance[association.target.primaryKeyAttribute] = associatedInstance;\n          associatedInstance = association.target.build(tmpInstance, {\n            isNewRecord: false\n          });\n        }\n\n        _.assign(associatedInstance, association.scope);\n\n        associatedInstance.set(association.foreignKey, sourceInstance.get(association.sourceIdentifier));\n        return associatedInstance.save(options);\n      }\n\n      return null;\n    });\n  }\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to `target.create` and setAssociation.\n   * @see {@link Model#create} for a full explanation of options\n   * @return {Promise}\n   */\n\n\n  create(sourceInstance, values, options) {\n    const association = this;\n    values = values || {};\n    options = options || {};\n\n    if (association.scope) {\n      for (const attribute of Object.keys(association.scope)) {\n        values[attribute] = association.scope[attribute];\n\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[association.foreignKey] = sourceInstance.get(association.sourceIdentifier);\n\n    if (options.fields) {\n      options.fields.push(association.foreignKey);\n    }\n\n    return association.target.create(values, options);\n  }\n\n}\n\nmodule.exports = HasOne;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/associations/has-one.js"],"names":["Utils","require","Helpers","_","Association","Op","HasOne","constructor","source","target","options","associationType","isSingleAssociation","foreignKeyAttribute","as","isAliased","name","singular","isObject","foreignKey","fieldName","camelizeIf","underscoredIf","singularize","underscored","primaryKeyAttribute","join","sourceIdentifier","sourceKey","sourceKeyIsPrimary","associationAccessor","useHooks","rawAttributes","identifierField","field","uppercaseFirst","accessors","get","set","create","injectAttributes","newAttributes","keyType","type","defaults","allowNull","mergeDefaults","constraints","onDelete","onUpdate","addForeignKeyConstraints","refreshAttributes","checkNamingCollision","mixin","obj","methods","mixinMethods","instances","association","where","Target","instance","cloneDeep","hasOwnProperty","scope","unscoped","schema","schemaDelimiter","Array","isArray","undefined","in","map","assign","and","findAll","then","results","result","raw","findOne","sourceInstance","associatedInstance","alreadyAssociated","oldInstance","every","primaryKeyAttributes","attribute","save","extend","fields","tmpInstance","build","isNewRecord","values","Object","keys","push","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasOne(Project)` the getter will be `user.getProject()`.\n * This is almost the same as `belongsTo` with one exception - The foreign key will be defined on the target model.\n *\n * @see {@link Model.hasOne}\n */\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasOne';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelizeIf(\n        [\n          Utils.underscoredIf(Utils.singularize(this.options.as || this.source.name), this.target.options.underscored),\n          this.source.primaryKeyAttribute\n        ].join('_'),\n        !this.source.options.underscored\n      );\n    }\n\n    this.sourceIdentifier = this.source.primaryKeyAttribute;\n    this.sourceKey = this.source.primaryKeyAttribute;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: 'get' + singular,\n      set: 'set' + singular,\n      create: 'create' + singular\n    };\n  }\n\n  // the id is in the target table\n  injectAttributes() {\n    const newAttributes = {};\n    const keyType = this.source.rawAttributes[this.source.primaryKeyAttribute].type;\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || keyType,\n      allowNull: true\n    });\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(this.target.rawAttributes[this.foreignKey], this.source, this.target, this.options);\n\n    // Sync attributes and setters/getters to Model prototype\n    this.target.refreshAttributes();\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Object} [options]\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findOne} for a full explanation of options\n   * @return {Promise<Model>}\n   */\n  get(instances, options) {\n    const association = this;\n    const where = {};\n    let Target = association.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[association.foreignKey] = {\n        [Op.in]: instances.map(instance => instance.get(association.sourceKey))\n      };\n    } else {\n      where[association.foreignKey] = instance.get(association.sourceKey);\n    }\n\n    if (association.scope) {\n      _.assign(where, association.scope);\n    }\n\n    options.where = options.where ?\n      {[Op.and]: [where, options.where]} :\n      where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n        for (const instance of instances) {\n          result[instance.get(association.sourceKey, {raw: true})] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(association.foreignKey, {raw: true})] = instance;\n        }\n\n        return result;\n      });\n    }\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model|String|Number} [newAssociation] An persisted instance or the primary key of a persisted instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options] Options passed to getAssociation and `target.save`\n   * @return {Promise}\n   */\n  set(sourceInstance, associatedInstance, options) {\n    const association = this;\n\n    let alreadyAssociated;\n\n    options = _.assign({}, options, {\n      scope: false\n    });\n\n    return sourceInstance[association.accessors.get](options).then(oldInstance => {\n      // TODO Use equals method once #5605 is resolved\n      alreadyAssociated = oldInstance && associatedInstance && _.every(association.target.primaryKeyAttributes, attribute =>\n        oldInstance.get(attribute, {raw: true}) === (associatedInstance.get ? associatedInstance.get(attribute, {raw: true}) : associatedInstance)\n      );\n\n      if (oldInstance && !alreadyAssociated) {\n        oldInstance[association.foreignKey] = null;\n        return oldInstance.save(_.extend({}, options, {\n          fields: [association.foreignKey],\n          allowNull: [association.foreignKey],\n          association: true\n        }));\n      }\n    }).then(() => {\n      if (associatedInstance && !alreadyAssociated) {\n        if (!(associatedInstance instanceof association.target)) {\n          const tmpInstance = {};\n          tmpInstance[association.target.primaryKeyAttribute] = associatedInstance;\n          associatedInstance = association.target.build(tmpInstance, {\n            isNewRecord: false\n          });\n        }\n\n        _.assign(associatedInstance, association.scope);\n        associatedInstance.set(association.foreignKey, sourceInstance.get(association.sourceIdentifier));\n\n        return associatedInstance.save(options);\n      }\n\n      return null;\n    });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to `target.create` and setAssociation.\n   * @see {@link Model#create} for a full explanation of options\n   * @return {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    values = values || {};\n    options = options || {};\n\n    if (association.scope) {\n      for (const attribute of Object.keys(association.scope)) {\n        values[attribute] = association.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n\n    values[association.foreignKey] = sourceInstance.get(association.sourceIdentifier);\n    if (options.fields) {\n      options.fields.push(association.foreignKey);\n    }\n\n    return association.target.create(values, options);\n  }\n}\n\nmodule.exports = HasOne;\n"]},"metadata":{},"sourceType":"script"}