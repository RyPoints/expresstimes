{"ast":null,"code":"'use strict';\n\nconst validator = require('./utils/validator-extras').validator;\n\nconst Utils = require('./utils');\n\nconst sequelizeError = require('./errors');\n\nconst Promise = require('./promise');\n\nconst DataTypes = require('./data-types');\n\nconst _ = require('lodash');\n/**\n * The Main Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {Object} options A dict with options.\n * @constructor\n * @private\n */\n\n\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = _.clone(options) || {};\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } // assign defined and default options\n\n\n    this.options = _.defaults(options, {\n      skip: [],\n      hooks: true\n    });\n    this.modelInstance = modelInstance;\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     * @name validator\n     * @private\n     */\n\n    this.validator = validator;\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n\n    this.errors = [];\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n\n    this.inProgress = false;\n  }\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @return {Promise}\n   * @private\n   */\n\n\n  _validate() {\n    if (this.inProgress) {\n      throw new Error('Validations already in progress.');\n    }\n\n    this.inProgress = true;\n    return Promise.all([this._builtinValidators(), this._customValidators()].map(promise => promise.reflect())).then(() => {\n      if (this.errors.length) {\n        throw new sequelizeError.ValidationError(null, this.errors);\n      }\n    });\n  }\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @return {Promise}\n   * @private\n   */\n\n\n  validate() {\n    return this.options.hooks ? this._validateAndRunHooks() : this._validate();\n  }\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @return {Promise}\n   * @private\n   */\n\n\n  _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    return runHooks('beforeValidate', this.modelInstance, this.options).then(() => this._validate().catch(error => runHooks('validationFailed', this.modelInstance, this.options, error).then(newError => {\n      throw newError || error;\n    }))).then(() => runHooks('afterValidate', this.modelInstance, this.options)).return(this.modelInstance);\n  }\n  /**\n   * Will run all the built-in validators.\n   *\n   * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n   * @private\n   */\n\n\n  _builtinValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.indexOf(field) >= 0) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (this.modelInstance.validators.hasOwnProperty(field)) {\n        validators.push(this._builtinAttrValidate.call(this, value, field).reflect());\n      }\n    });\n\n    return Promise.all(validators);\n  }\n  /**\n   * Will run all the custom validators.\n   *\n   * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n   * @private\n   */\n\n\n  _customValidators() {\n    const validators = [];\n\n    _.each(this.modelInstance._modelOptions.validate, (validator, validatorType) => {\n      if (this.options.skip.indexOf(validatorType) >= 0) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType) // errors are handled in settling, stub this\n      .catch(() => {}).reflect();\n\n      validators.push(valprom);\n    });\n\n    return Promise.all(validators);\n  }\n  /**\n   * Validate a single attribute with all the defined built-in validators.\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @return {Promise} A promise, will always resolve,\n   *   auto populates error on this.error local object.\n   * @private\n   */\n\n\n  _builtinAttrValidate(value, field) {\n    // check if value is null (if null not allowed the Schema pass will capture it)\n    if (value === null || typeof value === 'undefined') {\n      return Promise.resolve();\n    } // Promisify each validator\n\n\n    const validators = [];\n\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n      if (['isUrl', 'isURL', 'isEmail'].indexOf(validatorType) !== -1) {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      } // Check for custom validator.\n\n\n      if (typeof test === 'function') {\n        return validators.push(this._invokeCustomValidator(test, validatorType, true, value, field).reflect());\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field); // errors are handled in settling, stub this\n\n\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise.reflect());\n    });\n\n    return Promise.all(validators).then(results => this._handleReflectedResult(field, value, results));\n  }\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean=} optAttrDefined Set to true if custom validator was defined\n   *   from the Attribute\n   * @return {Promise} A promise.\n   * @private\n   */\n\n\n  _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let validatorFunction = null; // the validation function to call\n\n    let isAsync = false;\n    const validatorArity = validator.length; // check if validator is async and requires a callback\n\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      if (optAttrDefined) {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));\n      } else {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance));\n      }\n\n      return validatorFunction().catch(e => this._pushError(false, errorKey, e, optValue, validatorType));\n    } else {\n      return Promise.try(() => validator.call(this.modelInstance, invokeArgs)).catch(e => this._pushError(false, errorKey, e, optValue, validatorType));\n    }\n  }\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   * @return {Object} An object with specific keys to invoke the validator.\n   * @private\n   */\n\n\n  _invokeBuiltinValidator(value, test, validatorType, field) {\n    return Promise.try(() => {\n      // Cast value as string to pass new Validator.js string requirement\n      const valueString = String(value); // check if Validator knows that kind of validation test\n\n      if (typeof validator[validatorType] !== 'function') {\n        throw new Error('Invalid validator function: ' + validatorType);\n      }\n\n      const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n      if (!validator[validatorType].apply(validator, [valueString].concat(validatorArgs))) {\n        throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), {\n          validatorName: validatorType,\n          validatorArgs\n        });\n      }\n    });\n  }\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   * @private\n   */\n\n\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n\n    return validatorArgs;\n  }\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {Object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   * @private\n   */\n\n\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const validators = this.modelInstance.validators[field];\n\n      const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n      this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, 'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n      field, value, this.modelInstance, 'is_null'));\n    }\n\n    if (rawAttribute.type === DataTypes.STRING || rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type === DataTypes.TEXT || rawAttribute.type instanceof DataTypes.TEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, 'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n        field, value, this.modelInstance, 'not_a_string'));\n      }\n    }\n  }\n  /**\n   * Handles the returned result of a Promise.reflect.\n   *\n   * If errors are found it populates this.error.\n   *\n   * @param {string} field The attribute name.\n   * @param {string|number} value The data value.\n   * @param {Array.<Promise.PromiseInspection>} Promise inspection objects.\n   * @private\n   */\n\n\n  _handleReflectedResult(field, value, promiseInspections) {\n    for (const promiseInspection of promiseInspections) {\n      if (promiseInspection.isRejected()) {\n        const rejection = promiseInspection.error();\n        const isBuiltIn = !!rejection.validatorName;\n\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      }\n    }\n  }\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {Boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {String}        errorKey    - name of invalid attribute.\n   * @param {Error|String}  rawError    - The original error.\n   * @param {String|Number} value       - The data that triggered the error.\n   * @param {String}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n\n\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(message, 'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n    errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : undefined, isBuiltin ? fnArgs : undefined);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n    this.errors.push(error);\n  }\n\n}\n/**\n * @define {string} The error key for arguments as passed by custom validators\n * @private\n */\n\n\nInstanceValidator.RAW_KEY_NAME = '__raw';\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/instance-validator.js"],"names":["validator","require","Utils","sequelizeError","Promise","DataTypes","_","InstanceValidator","constructor","modelInstance","options","clone","fields","skip","difference","Object","keys","rawAttributes","defaults","hooks","errors","inProgress","_validate","Error","all","_builtinValidators","_customValidators","map","promise","reflect","then","length","ValidationError","validate","_validateAndRunHooks","runHooks","bind","catch","error","newError","return","validators","forIn","rawAttribute","field","indexOf","value","dataValues","_autoGenerated","autoIncrement","_validateSchema","hasOwnProperty","push","_builtinAttrValidate","call","each","_modelOptions","validatorType","valprom","_invokeCustomValidator","resolve","test","msg","validatorPromise","_invokeBuiltinValidator","results","_handleReflectedResult","optAttrDefined","optValue","optField","validatorFunction","isAsync","validatorArity","asyncArity","errorKey","invokeArgs","promisify","e","_pushError","try","valueString","String","validatorArgs","_extractValidatorArgs","apply","concat","assign","validatorName","args","isLocalizedValidator","Array","isArray","slice","allowNull","undefined","errMsg","get","name","ValidationErrorItem","type","STRING","TEXT","isObject","SequelizeMethod","Buffer","isBuffer","promiseInspections","promiseInspection","isRejected","rejection","isBuiltIn","isBuiltin","rawError","fnName","fnArgs","message","RAW_KEY_NAME","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst validator = require('./utils/validator-extras').validator;\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst Promise = require('./promise');\nconst DataTypes = require('./data-types');\nconst _ = require('lodash');\n\n/**\n * The Main Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {Object} options A dict with options.\n * @constructor\n * @private\n */\nclass InstanceValidator {\n\n  constructor(modelInstance, options) {\n    options = _.clone(options) || {};\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    }\n\n    // assign defined and default options\n    this.options = _.defaults(options, {\n      skip: [],\n      hooks: true\n    });\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @return {Promise}\n   * @private\n   */\n  _validate() {\n    if (this.inProgress) {\n      throw new Error('Validations already in progress.');\n    }\n    this.inProgress = true;\n\n    return Promise.all(\n      [this._builtinValidators(), this._customValidators()].map(promise => promise.reflect())\n    ).then(() => {\n      if (this.errors.length) {\n        throw new sequelizeError.ValidationError(null, this.errors);\n      }\n    });\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @return {Promise}\n   * @private\n   */\n  validate() {\n    return this.options.hooks ? this._validateAndRunHooks() : this._validate();\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @return {Promise}\n   * @private\n   */\n  _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    return runHooks('beforeValidate', this.modelInstance, this.options)\n      .then(() =>\n        this._validate()\n          .catch(error => runHooks('validationFailed', this.modelInstance, this.options, error)\n            .then(newError => { throw newError || error; }))\n      )\n      .then(() => runHooks('afterValidate', this.modelInstance, this.options))\n      .return(this.modelInstance);\n  }\n\n  /**\n   * Will run all the built-in validators.\n   *\n   * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n   * @private\n   */\n  _builtinValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.indexOf(field) >= 0) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (this.modelInstance.validators.hasOwnProperty(field)) {\n        validators.push(this._builtinAttrValidate.call(this, value, field).reflect());\n      }\n    });\n\n    return Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators.\n   *\n   * @return {Promise(Array.<Promise.PromiseInspection>)} A promise from .reflect().\n   * @private\n   */\n  _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance._modelOptions.validate, (validator, validatorType) => {\n      if (this.options.skip.indexOf(validatorType) >= 0) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {})\n        .reflect();\n\n      validators.push(valprom);\n    });\n\n    return Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators.\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @return {Promise} A promise, will always resolve,\n   *   auto populates error on this.error local object.\n   * @private\n   */\n  _builtinAttrValidate(value, field) {\n    // check if value is null (if null not allowed the Schema pass will capture it)\n    if (value === null || typeof value === 'undefined') {\n      return Promise.resolve();\n    }\n\n    // Promisify each validator\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (['isUrl', 'isURL', 'isEmail'].indexOf(validatorType) !== -1) {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Check for custom validator.\n      if (typeof test === 'function') {\n        return validators.push(this._invokeCustomValidator(test, validatorType, true, value, field).reflect());\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise.reflect());\n    });\n\n    return Promise\n      .all(validators)\n      .then(results => this._handleReflectedResult(field, value, results));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean=} optAttrDefined Set to true if custom validator was defined\n   *   from the Attribute\n   * @return {Promise} A promise.\n   * @private\n   */\n  _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let validatorFunction = null;  // the validation function to call\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      if (optAttrDefined) {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));\n      } else {\n        validatorFunction = Promise.promisify(validator.bind(this.modelInstance));\n      }\n      return validatorFunction()\n        .catch(e => this._pushError(false, errorKey, e, optValue, validatorType));\n    } else {\n      return Promise\n        .try(() => validator.call(this.modelInstance, invokeArgs))\n        .catch(e => this._pushError(false, errorKey, e, optValue, validatorType));\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   * @return {Object} An object with specific keys to invoke the validator.\n   * @private\n   */\n  _invokeBuiltinValidator(value, test, validatorType, field) {\n    return Promise.try(() => {\n      // Cast value as string to pass new Validator.js string requirement\n      const valueString = String(value);\n      // check if Validator knows that kind of validation test\n      if (typeof validator[validatorType] !== 'function') {\n        throw new Error('Invalid validator function: ' + validatorType);\n      }\n\n      const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n      if (!validator[validatorType].apply(validator, [valueString].concat(validatorArgs))) {\n        throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n      }\n    });\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {Object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const validators = this.modelInstance.validators[field];\n      const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n      this.errors.push(new sequelizeError.ValidationErrorItem(\n        errMsg,\n        'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n        field,\n        value,\n        this.modelInstance,\n        'is_null'\n      ));\n    }\n\n    if (rawAttribute.type === DataTypes.STRING || rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type === DataTypes.TEXT || rawAttribute.type instanceof DataTypes.TEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          `${field} cannot be an array or an object`,\n          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'not_a_string'\n        ));\n      }\n    }\n  }\n\n\n  /**\n   * Handles the returned result of a Promise.reflect.\n   *\n   * If errors are found it populates this.error.\n   *\n   * @param {string} field The attribute name.\n   * @param {string|number} value The data value.\n   * @param {Array.<Promise.PromiseInspection>} Promise inspection objects.\n   * @private\n   */\n  _handleReflectedResult(field, value, promiseInspections) {\n    for (const promiseInspection of promiseInspections) {\n      if (promiseInspection.isRejected()) {\n        const rejection = promiseInspection.error();\n        const isBuiltIn = !!rejection.validatorName;\n\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {Boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {String}        errorKey    - name of invalid attribute.\n   * @param {Error|String}  rawError    - The original error.\n   * @param {String|Number} value       - The data that triggered the error.\n   * @param {String}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * @define {string} The error key for arguments as passed by custom validators\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = '__raw';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n"]},"metadata":{},"sourceType":"script"}