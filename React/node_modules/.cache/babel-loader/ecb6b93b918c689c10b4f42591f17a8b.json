{"ast":null,"code":"/****\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Gustavo Henke and Aaron Trent\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n ****/\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"Toposort\", [\"exports\", \"module\"], factory);\n  } else if (typeof exports !== \"undefined\" && typeof module !== \"undefined\") {\n    factory(exports, module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, mod);\n    global.Toposort = mod.exports;\n  }\n})(this, function (exports, module) {\n  \"use strict\";\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var Toposort = function () {\n    function Toposort() {\n      _classCallCheck(this, Toposort);\n\n      this.edges = [];\n      this.Toposort = Toposort;\n    }\n    /**\n     * Adds dependency edges.\n     *\n     * @since   0.1.0\n     * @param   {String} item               An dependent name. Must be an string and not empty\n     * @param   {String[]|String} [deps]    An dependency or array of dependencies\n     * @returns {Toposort}                  The Toposort instance\n     */\n\n\n    Toposort.prototype.add = function add(item, deps) {\n      if (typeof item !== \"string\" || !item) {\n        throw new TypeError(\"Dependent name must be given as a not empty string\");\n      }\n\n      deps = Array.isArray(deps) ? deps : [deps];\n\n      if (deps.length > 0) {\n        for (var _iterator = deps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) {\n              break;\n            }\n\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n\n            if (_i.done) {\n              break;\n            }\n\n            _ref = _i.value;\n          }\n\n          var dep = _ref;\n\n          if (typeof dep !== \"string\" || !dep) {\n            throw new TypeError(\"Dependency name must be given as a not empty string\");\n          }\n\n          this.edges.push([item, dep]);\n        }\n      } else {\n        this.edges.push([item]);\n      }\n\n      return this;\n    };\n    /**\n     * Runs the toposorting and return an ordered array of strings\n     *\n     * @since   0.1.0\n     * @returns {String[]}  The list of items topologically sorted.\n     */\n\n\n    Toposort.prototype.sort = function sort() {\n      var _this = this;\n\n      var nodes = []; //accumulate unique nodes into a large list\n\n      for (var _iterator2 = this.edges, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) {\n            break;\n          }\n\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n\n          if (_i2.done) {\n            break;\n          }\n\n          _ref2 = _i2.value;\n        }\n\n        var edge = _ref2;\n\n        for (var _iterator3 = edge, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n          var _ref3;\n\n          if (_isArray3) {\n            if (_i3 >= _iterator3.length) {\n              break;\n            }\n\n            _ref3 = _iterator3[_i3++];\n          } else {\n            _i3 = _iterator3.next();\n\n            if (_i3.done) {\n              break;\n            }\n\n            _ref3 = _i3.value;\n          }\n\n          var node = _ref3;\n\n          if (nodes.indexOf(node) === -1) {\n            nodes.push(node);\n          }\n        }\n      } //initialize the placement of nodes into the sorted array at the end\n\n\n      var place = nodes.length; //initialize the sorted array with the same length as the unique nodes array\n\n      var sorted = new Array(nodes.length); //define a visitor function that recursively traverses dependencies.\n\n      var visit = function visit(node, predecessors) {\n        //check if a node is dependent of itself\n        if (predecessors.length !== 0 && predecessors.indexOf(node) !== -1) {\n          throw new Error(\"Cyclic dependency found. \" + node + \" is dependent of itself.\\nDependency chain: \" + predecessors.join(\" -> \") + \" => \" + node);\n        }\n\n        var index = nodes.indexOf(node); //if the node still exists, traverse its dependencies\n\n        if (index !== -1) {\n          var copy = false; //mark the node as false to exclude it from future iterations\n\n          nodes[index] = false; //loop through all edges and follow dependencies of the current node\n\n          for (var _iterator4 = _this.edges, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n            var _ref4;\n\n            if (_isArray4) {\n              if (_i4 >= _iterator4.length) {\n                break;\n              }\n\n              _ref4 = _iterator4[_i4++];\n            } else {\n              _i4 = _iterator4.next();\n\n              if (_i4.done) {\n                break;\n              }\n\n              _ref4 = _i4.value;\n            }\n\n            var edge = _ref4;\n\n            if (edge[0] === node) {\n              //lazily create a copy of predecessors with the current node concatenated onto it\n              copy = copy || predecessors.concat([node]); //recurse to node dependencies\n\n              visit(edge[1], copy);\n            }\n          } //add the node to the next place in the sorted array\n\n\n          sorted[--place] = node;\n        }\n      };\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i]; //ignore nodes that have been excluded\n\n        if (node !== false) {\n          //mark the node as false to exclude it from future iterations\n          nodes[i] = false; //loop through all edges and follow dependencies of the current node\n\n          for (var _iterator5 = this.edges, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n            var _ref5;\n\n            if (_isArray5) {\n              if (_i5 >= _iterator5.length) {\n                break;\n              }\n\n              _ref5 = _iterator5[_i5++];\n            } else {\n              _i5 = _iterator5.next();\n\n              if (_i5.done) {\n                break;\n              }\n\n              _ref5 = _i5.value;\n            }\n\n            var edge = _ref5;\n\n            if (edge[0] === node) {\n              //recurse to node dependencies\n              visit(edge[1], [node]);\n            }\n          } //add the node to the next place in the sorted array\n\n\n          sorted[--place] = node;\n        }\n      }\n\n      return sorted;\n    };\n    /**\n     * Clears edges\n     *\n     * @since   0.4.0\n     * @returns {Toposort}                  The Toposort instance\n     */\n\n\n    Toposort.prototype.clear = function clear() {\n      this.edges = [];\n      return this;\n    };\n\n    return Toposort;\n  }();\n\n  module.exports = Toposort;\n});","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/toposort-class/build/toposort.js"],"names":["global","factory","define","amd","exports","module","mod","Toposort","_classCallCheck","instance","Constructor","TypeError","edges","prototype","add","item","deps","Array","isArray","length","_iterator","_isArray","_i","Symbol","iterator","_ref","next","done","value","dep","push","sort","_this","nodes","_iterator2","_isArray2","_i2","_ref2","edge","_iterator3","_isArray3","_i3","_ref3","node","indexOf","place","sorted","visit","predecessors","Error","join","index","copy","_iterator4","_isArray4","_i4","_ref4","concat","i","_iterator5","_isArray5","_i5","_ref5","clear"],"mappings":"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","sourcesContent":["/****\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Gustavo Henke and Aaron Trent\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n ****/\n(function( global, factory ) {\n    if( typeof define === \"function\" && define.amd ) {\n        define( \"Toposort\", [\"exports\", \"module\"], factory );\n    } else if( typeof exports !== \"undefined\" && typeof module !== \"undefined\" ) {\n        factory( exports, module );\n    } else {\n        var mod = {\n            exports: {}\n        };\n        factory( mod.exports, mod );\n        global.Toposort = mod.exports;\n    }\n})( this, function( exports, module ) {\n    \"use strict\";\n\n    function _classCallCheck( instance, Constructor ) {\n        if( !(instance instanceof Constructor) ) {\n            throw new TypeError( \"Cannot call a class as a function\" );\n        }\n    }\n\n    var Toposort = (function() {\n        function Toposort() {\n            _classCallCheck( this, Toposort );\n\n            this.edges = [];\n            this.Toposort = Toposort;\n        }\n\n        /**\n         * Adds dependency edges.\n         *\n         * @since   0.1.0\n         * @param   {String} item               An dependent name. Must be an string and not empty\n         * @param   {String[]|String} [deps]    An dependency or array of dependencies\n         * @returns {Toposort}                  The Toposort instance\n         */\n\n        Toposort.prototype.add = function add( item, deps ) {\n            if( typeof item !== \"string\" || !item ) {\n                throw new TypeError( \"Dependent name must be given as a not empty string\" );\n            }\n\n            deps = Array.isArray( deps ) ? deps : [deps];\n\n            if( deps.length > 0 ) {\n                for( var _iterator = deps, _isArray = Array.isArray( _iterator ), _i = 0, _iterator = _isArray ?\n                                                                                                      _iterator :\n                                                                                                      _iterator[Symbol.iterator](); ; ) {\n                    var _ref;\n\n                    if( _isArray ) {\n                        if( _i >= _iterator.length ) {\n                            break;\n                        }\n                        _ref = _iterator[_i++];\n                    } else {\n                        _i = _iterator.next();\n                        if( _i.done ) {\n                            break;\n                        }\n                        _ref = _i.value;\n                    }\n\n                    var dep = _ref;\n\n                    if( typeof dep !== \"string\" || !dep ) {\n                        throw new TypeError( \"Dependency name must be given as a not empty string\" );\n                    }\n\n                    this.edges.push( [item, dep] );\n                }\n            } else {\n                this.edges.push( [item] );\n            }\n\n            return this;\n        };\n\n        /**\n         * Runs the toposorting and return an ordered array of strings\n         *\n         * @since   0.1.0\n         * @returns {String[]}  The list of items topologically sorted.\n         */\n\n        Toposort.prototype.sort = function sort() {\n            var _this = this;\n\n            var nodes = [];\n\n            //accumulate unique nodes into a large list\n            for( var _iterator2 = this.edges, _isArray2 = Array.isArray( _iterator2 ), _i2 = 0, _iterator2 = _isArray2 ?\n                                                                                                             _iterator2 :\n                                                                                                             _iterator2[Symbol.iterator](); ; ) {\n                var _ref2;\n\n                if( _isArray2 ) {\n                    if( _i2 >= _iterator2.length ) {\n                        break;\n                    }\n                    _ref2 = _iterator2[_i2++];\n                } else {\n                    _i2 = _iterator2.next();\n                    if( _i2.done ) {\n                        break;\n                    }\n                    _ref2 = _i2.value;\n                }\n\n                var edge = _ref2;\n\n                for( var _iterator3 = edge, _isArray3 = Array.isArray( _iterator3 ), _i3 = 0, _iterator3 = _isArray3 ?\n                                                                                                           _iterator3 :\n                                                                                                           _iterator3[Symbol.iterator](); ; ) {\n                    var _ref3;\n\n                    if( _isArray3 ) {\n                        if( _i3 >= _iterator3.length ) {\n                            break;\n                        }\n                        _ref3 = _iterator3[_i3++];\n                    } else {\n                        _i3 = _iterator3.next();\n                        if( _i3.done ) {\n                            break;\n                        }\n                        _ref3 = _i3.value;\n                    }\n\n                    var node = _ref3;\n\n                    if( nodes.indexOf( node ) === -1 ) {\n                        nodes.push( node );\n                    }\n                }\n            }\n\n            //initialize the placement of nodes into the sorted array at the end\n            var place = nodes.length;\n\n            //initialize the sorted array with the same length as the unique nodes array\n            var sorted = new Array( nodes.length );\n\n            //define a visitor function that recursively traverses dependencies.\n            var visit = function visit( node, predecessors ) {\n                //check if a node is dependent of itself\n                if( predecessors.length !== 0 && predecessors.indexOf( node ) !== -1 ) {\n                    throw new Error( \"Cyclic dependency found. \" + node + \" is dependent of itself.\\nDependency chain: \"\n                                     + predecessors.join( \" -> \" ) + \" => \" + node );\n                }\n\n                var index = nodes.indexOf( node );\n\n                //if the node still exists, traverse its dependencies\n                if( index !== -1 ) {\n                    var copy = false;\n\n                    //mark the node as false to exclude it from future iterations\n                    nodes[index] = false;\n\n                    //loop through all edges and follow dependencies of the current node\n                    for( var _iterator4 = _this.edges, _isArray4 = Array.isArray( _iterator4 ), _i4 = 0, _iterator4 = _isArray4 ?\n                                                                                                                      _iterator4 :\n                                                                                                                      _iterator4[Symbol.iterator](); ; ) {\n                        var _ref4;\n\n                        if( _isArray4 ) {\n                            if( _i4 >= _iterator4.length ) {\n                                break;\n                            }\n                            _ref4 = _iterator4[_i4++];\n                        } else {\n                            _i4 = _iterator4.next();\n                            if( _i4.done ) {\n                                break;\n                            }\n                            _ref4 = _i4.value;\n                        }\n\n                        var edge = _ref4;\n\n                        if( edge[0] === node ) {\n                            //lazily create a copy of predecessors with the current node concatenated onto it\n                            copy = copy || predecessors.concat( [node] );\n\n                            //recurse to node dependencies\n                            visit( edge[1], copy );\n                        }\n                    }\n\n                    //add the node to the next place in the sorted array\n                    sorted[--place] = node;\n                }\n            };\n\n            for( var i = 0; i < nodes.length; i++ ) {\n                var node = nodes[i];\n\n                //ignore nodes that have been excluded\n                if( node !== false ) {\n                    //mark the node as false to exclude it from future iterations\n                    nodes[i] = false;\n\n                    //loop through all edges and follow dependencies of the current node\n                    for( var _iterator5 = this.edges, _isArray5 = Array.isArray( _iterator5 ), _i5 = 0, _iterator5 = _isArray5 ?\n                                                                                                                     _iterator5 :\n                                                                                                                     _iterator5[Symbol.iterator](); ; ) {\n                        var _ref5;\n\n                        if( _isArray5 ) {\n                            if( _i5 >= _iterator5.length ) {\n                                break;\n                            }\n                            _ref5 = _iterator5[_i5++];\n                        } else {\n                            _i5 = _iterator5.next();\n                            if( _i5.done ) {\n                                break;\n                            }\n                            _ref5 = _i5.value;\n                        }\n\n                        var edge = _ref5;\n\n                        if( edge[0] === node ) {\n                            //recurse to node dependencies\n                            visit( edge[1], [node] );\n                        }\n                    }\n\n                    //add the node to the next place in the sorted array\n                    sorted[--place] = node;\n                }\n            }\n\n            return sorted;\n        };\n\n        /**\n         * Clears edges\n         *\n         * @since   0.4.0\n         * @returns {Toposort}                  The Toposort instance\n         */\n\n        Toposort.prototype.clear = function clear() {\n            this.edges = [];\n\n            return this;\n        };\n\n        return Toposort;\n    })();\n\n    module.exports = Toposort;\n} );\n"]},"metadata":{},"sourceType":"script"}