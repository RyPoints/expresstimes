{"ast":null,"code":"'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst ResourceLock = require('./resource-lock');\n\nconst Promise = require('../../promise');\n\nconst Utils = require('../../utils');\n\nconst debug = Utils.getLogger().debugContext('connection:mssql');\nconst debugTedious = Utils.getLogger().debugContext('connection:mssql:tedious');\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('mssql');\n\nconst _ = require('lodash');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1433;\n\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath);\n      } else {\n        this.lib = require('tedious');\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install tedious package manually');\n      }\n\n      throw err;\n    }\n  } // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  connect(config) {\n    const connectionConfig = {\n      userName: config.username,\n      password: config.password,\n      server: config.host,\n      options: {\n        port: config.port,\n        database: config.database\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (config.dialectOptions.instanceName) {\n        delete connectionConfig.options.port;\n      } // The 'tedious' driver needs domain property to be in the main Connection config object\n\n\n      if (config.dialectOptions.domain) {\n        connectionConfig.domain = config.dialectOptions.domain;\n      }\n\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig.options[key] = config.dialectOptions[key];\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      const connection = new this.lib.Connection(connectionConfig);\n      connection.lib = this.lib;\n      const resourceLock = new ResourceLock(connection);\n      connection.on('end', () => {\n        reject(new sequelizeErrors.ConnectionError('Connection was closed by remote server'));\n      });\n      connection.on('connect', err => {\n        if (!err) {\n          debug('connection acquired');\n          return resolve(resourceLock);\n        }\n\n        if (!err.code) {\n          reject(new sequelizeErrors.ConnectionError(err));\n          return;\n        }\n\n        switch (err.code) {\n          case 'ESOCKET':\n            if (_.includes(err.message, 'connect EHOSTUNREACH')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'connect ENETUNREACH')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'connect EADDRNOTAVAIL')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'getaddrinfo ENOTFOUND')) {\n              reject(new sequelizeErrors.HostNotFoundError(err));\n            } else if (_.includes(err.message, 'connect ECONNREFUSED')) {\n              reject(new sequelizeErrors.ConnectionRefusedError(err));\n            } else {\n              reject(new sequelizeErrors.ConnectionError(err));\n            }\n\n            break;\n\n          case 'ER_ACCESS_DENIED_ERROR':\n          case 'ELOGIN':\n            reject(new sequelizeErrors.AccessDeniedError(err));\n            break;\n\n          case 'EINVAL':\n            reject(new sequelizeErrors.InvalidConnectionError(err));\n            break;\n\n          default:\n            reject(new sequelizeErrors.ConnectionError(err));\n            break;\n        }\n      });\n\n      if (config.dialectOptions && config.dialectOptions.debug) {\n        connection.on('debug', debugTedious);\n      }\n\n      if (config.pool.handleDisconnects) {\n        connection.on('error', err => {\n          switch (err.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(resourceLock).catch(/Resource not currently part of this pool/, () => {});\n          }\n        });\n      }\n    });\n  }\n\n  disconnect(connectionLock) {\n    /**\n     * Abstract connection may try to disconnect raw connection used for fetching version\n     */\n    const connection = connectionLock.unwrap ? connectionLock.unwrap() : connectionLock; // Dont disconnect a connection that is already disconnected\n\n    if (connection.closed) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connectionLock) {\n    /**\n     * Abstract connection may try to validate raw connection used for fetching version\n     */\n    const connection = connectionLock.unwrap ? connectionLock.unwrap() : connectionLock;\n    return connection && connection.loggedIn;\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/dialects/mssql/connection-manager.js"],"names":["AbstractConnectionManager","require","ResourceLock","Promise","Utils","debug","getLogger","debugContext","debugTedious","sequelizeErrors","parserStore","_","ConnectionManager","constructor","dialect","sequelize","config","port","dialectModulePath","lib","err","code","Error","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connect","connectionConfig","userName","username","password","server","host","options","database","dialectOptions","instanceName","domain","key","Object","keys","resolve","reject","connection","Connection","resourceLock","on","ConnectionError","includes","message","HostNotReachableError","HostNotFoundError","ConnectionRefusedError","AccessDeniedError","InvalidConnectionError","pool","handleDisconnects","destroy","catch","disconnect","connectionLock","unwrap","closed","close","validate","loggedIn","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst ResourceLock = require('./resource-lock');\nconst Promise = require('../../promise');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('connection:mssql');\nconst debugTedious = Utils.getLogger().debugContext('connection:mssql:tedious');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('mssql');\nconst _ = require('lodash');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1433;\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath);\n      } else {\n        this.lib = require('tedious');\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install tedious package manually');\n      }\n      throw err;\n    }\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  connect(config) {\n    const connectionConfig = {\n      userName: config.username,\n      password: config.password,\n      server: config.host,\n      options: {\n        port: config.port,\n        database: config.database\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (config.dialectOptions.instanceName) {\n        delete connectionConfig.options.port;\n      }\n\n      // The 'tedious' driver needs domain property to be in the main Connection config object\n      if (config.dialectOptions.domain) {\n        connectionConfig.domain = config.dialectOptions.domain;\n      }\n\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig.options[key] = config.dialectOptions[key];\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      const connection = new this.lib.Connection(connectionConfig);\n      connection.lib = this.lib;\n      const resourceLock = new ResourceLock(connection);\n\n      connection.on('end', () => {\n        reject(new sequelizeErrors.ConnectionError('Connection was closed by remote server'));\n      });\n\n      connection.on('connect', err => {\n        if (!err) {\n          debug('connection acquired');\n          return resolve(resourceLock);\n        }\n\n        if (!err.code) {\n          reject(new sequelizeErrors.ConnectionError(err));\n          return;\n        }\n\n        switch (err.code) {\n          case 'ESOCKET':\n            if (_.includes(err.message, 'connect EHOSTUNREACH')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'connect ENETUNREACH')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'connect EADDRNOTAVAIL')) {\n              reject(new sequelizeErrors.HostNotReachableError(err));\n            } else if (_.includes(err.message, 'getaddrinfo ENOTFOUND')) {\n              reject(new sequelizeErrors.HostNotFoundError(err));\n            } else if (_.includes(err.message, 'connect ECONNREFUSED')) {\n              reject(new sequelizeErrors.ConnectionRefusedError(err));\n            } else {\n              reject(new sequelizeErrors.ConnectionError(err));\n            }\n            break;\n          case 'ER_ACCESS_DENIED_ERROR':\n          case 'ELOGIN':\n            reject(new sequelizeErrors.AccessDeniedError(err));\n            break;\n          case 'EINVAL':\n            reject(new sequelizeErrors.InvalidConnectionError(err));\n            break;\n          default:\n            reject(new sequelizeErrors.ConnectionError(err));\n            break;\n        }\n      });\n\n      if (config.dialectOptions && config.dialectOptions.debug) {\n        connection.on('debug', debugTedious);\n      }\n\n      if (config.pool.handleDisconnects) {\n        connection.on('error', err => {\n          switch (err.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(resourceLock)\n                .catch(/Resource not currently part of this pool/, () => {});\n          }\n        });\n      }\n    });\n  }\n\n  disconnect(connectionLock) {\n    /**\n     * Abstract connection may try to disconnect raw connection used for fetching version\n     */\n    const connection = connectionLock.unwrap\n      ? connectionLock.unwrap()\n      : connectionLock;\n\n    // Dont disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connectionLock) {\n    /**\n     * Abstract connection may try to validate raw connection used for fetching version\n     */\n    const connection = connectionLock.unwrap\n      ? connectionLock.unwrap()\n      : connectionLock;\n\n    return connection && connection.loggedIn;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}