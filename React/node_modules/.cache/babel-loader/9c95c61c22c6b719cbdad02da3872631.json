{"ast":null,"code":"'use strict';\n\nconst Utils = require('./../utils');\n\nconst Helpers = require('./helpers');\n\nconst _ = require('lodash');\n\nconst Association = require('./base');\n\nconst BelongsTo = require('./belongs-to');\n\nconst HasMany = require('./has-many');\n\nconst HasOne = require('./has-one');\n\nconst AssociationError = require('../errors').AssociationError;\n\nconst EmptyResultError = require('../errors').EmptyResultError;\n\nconst Op = require('../operators');\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(project => {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(projects => {\n   *   let p1 = projects[0]\n   *   p1.UserProjects.started // Is this project started yet?\n   * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\n\n\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = Object.assign({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    /*\n    * Find paired association (if exists)\n    */\n\n\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n    /*\n    * Default/generated source/target keys\n    */\n\n\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n\n    this._createForeignAndOtherKeys();\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [],\n          //we don't want indexes here (as referenced in #2416)\n          paranoid: false,\n          // A paranoid join table does not make sense\n          validate: {} // Don't propagate model-level validations\n\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    this.options = Object.assign(this.options, _.pick(this.through.model.options, ['timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid']));\n\n    if (this.paired) {\n      let needInjectPaired = false;\n\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n\n        this._createForeignAndOtherKeys();\n      }\n\n      if (this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n\n          this.paired._createForeignAndOtherKeys();\n\n          needInjectPaired = true;\n        }\n      }\n\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n    this.associationAccessor = this.as; // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n\n    const plural = _.upperFirst(this.options.name.plural);\n\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize([this.source.options.name.singular, this.sourceKey].join('_'));\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize([this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular, this.targetKey].join('_'));\n    }\n  } // the id is in the target table\n  // or in an extra table which connects two tables\n\n\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey; // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        } else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n\n    const sourceAttribute = _.defaults({}, this.foreignKeyAttribute, {\n      type: sourceKeyType\n    });\n\n    const targetAttribute = _.defaults({}, this.otherKeyAttribute, {\n      type: targetKeyType\n    });\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      }; // For the source attribute the passed option is the priority\n\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      }; // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    this.through.model.rawAttributes[this.foreignKey] = Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    this.through.model.rawAttributes[this.otherKey] = Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n    this.through.model.refreshAttributes();\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      as: this.through.model.name\n    });\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @see\n   * {@link Model} for a full explanation of options\n   *\n   * @param {Model} instance instance\n   * @param {Object} [options] find options\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n\n\n  get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (this.scope) {\n      scopeWhere = _.clone(this.scope);\n    }\n\n    options.where = {\n      [Op.and]: [scopeWhere, options.where]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      } //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n\n\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        where: throughWhere\n      });\n    }\n\n    let model = this.target;\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model} instance instance\n   * @param {Object} [options] find options\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n\n\n  count(instance, options) {\n    const sequelize = this.target.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [[sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n    return this.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model} sourceInstance source instance to check for an association with\n   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n   * @param {Object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise<boolean>}\n   */\n\n\n  has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = Object.assign({\n      raw: true\n    }, options, {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n\n      return {\n        [this.targetKey]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [{\n        [Op.or]: instancePrimaryKeys\n      }, options.where]\n    };\n    return this.get(sourceInstance, options).then(associatedObjects => _.differenceWith(instancePrimaryKeys, associatedObjects, (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0);\n  }\n  /**\n   * Set the associated models by passing an array of instances or their primary keys.\n   * Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {Object} [options.validate] Run validation for the join model\n   * @param {Object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n\n\n  set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    let where = {};\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n\n    where[identifier] = sourceInstance.get(sourceKey);\n    where = Object.assign(where, this.through.scope);\n\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n      const unassociatedObjects = newAssociatedObjects.filter(obj => !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey)));\n\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name]; // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (Object.keys(attributes).length) {\n            promises.push(this.through.model.update(attributes, Object.assign(options, {\n              where: {\n                [identifier]: sourceInstance.get(sourceKey),\n                [foreignIdentifier]: newObj.get(targetKey)\n              }\n            })));\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        const where = Object.assign({\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier])\n        }, this.through.scope);\n        promises.push(this.through.model.destroy(_.defaults({\n          where\n        }, options)));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          let attributes = {};\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          attributes = _.defaults(attributes, unassociatedObject[this.through.model.name], defaultAttributes);\n          Object.assign(attributes, this.through.scope);\n          attributes = Object.assign(attributes, this.through.scope);\n          return attributes;\n        });\n        promises.push(this.through.model.bulkCreate(bulk, Object.assign({\n          validate: true\n        }, options)));\n      }\n\n      return Utils.Promise.all(promises);\n    };\n\n    return this.through.model.findAll(_.defaults({\n      where,\n      raw: true\n    }, options)).then(currentRows => updateAssociations(currentRows)).catch(error => {\n      if (error instanceof EmptyResultError) return updateAssociations([]);\n      throw error;\n    });\n  }\n  /**\n   * Associate one or several rows with source instance. It will not un-associate any already associated instance\n   * that may be missing from `newInstances`.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {Object} [options.validate] Run validation for the join model.\n   * @param {Object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n\n\n  add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Utils.Promise.resolve();\n    options = _.clone(options) || {};\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n    newInstances = association.toInstanceArray(newInstances);\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey))\n    };\n    Object.assign(where, association.through.scope);\n\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          Object.assign(attributes, association.through.scope);\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, Object.assign({\n          validate: true\n        }, options)));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n\n        const attributes = _.defaults({}, throughAttributes, defaultAttributes); // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        const where = {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        };\n        promises.push(association.through.model.update(attributes, Object.assign(options, {\n          where\n        })));\n      }\n\n      return Utils.Promise.all(promises);\n    };\n\n    return association.through.model.findAll(_.defaults({\n      where,\n      raw: true\n    }, options)).then(currentRows => updateAssociations(currentRows)).then(([associations]) => associations).catch(error => {\n      if (error instanceof EmptyResultError) return updateAssociations();\n      throw error;\n    });\n  }\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {Object} [options] Options passed to `through.destroy`\n   *\n   * @returns {Promise}\n   */\n\n\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n    options = options || {};\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n    return association.through.model.destroy(_.defaults({\n      where\n    }, options));\n  }\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {Object} [values] values for target model\n   * @param {Object} [options] Options passed to create and add\n   * @param {Object} [options.through] Additional attributes for the join table\n   *\n   * @returns {Promise}\n   */\n\n\n  create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      Object.assign(values, association.scope);\n\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    } // Create the related model instance\n\n\n    return association.target.create(values, options).then(newAssociatedObject => sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject));\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/associations/belongs-to-many.js"],"names":["Utils","require","Helpers","_","Association","BelongsTo","HasMany","HasOne","AssociationError","EmptyResultError","Op","BelongsToMany","constructor","source","target","options","through","undefined","name","model","associationType","targetAssociation","sequelize","Object","assign","isMultiAssociation","doubleLinked","as","isSelfAssociation","isAliased","isPlainObject","plural","singular","singularize","combinedTableName","combineTableNames","tableName","each","associations","association","paired","sourceKey","primaryKeyAttribute","sourceKeyField","rawAttributes","field","targetKey","targetKeyField","targetKeyDefault","_createForeignAndOtherKeys","isDefined","define","indexes","paranoid","validate","pick","needInjectPaired","otherKey","otherKeyDefault","foreignKey","_injectAttributes","throughModel","combinedName","associationAccessor","upperFirst","accessors","get","set","addMultiple","add","create","remove","removeMultiple","hasSingle","hasAll","count","isObject","foreignKeyAttribute","fieldName","camelize","join","otherKeyAttribute","identifier","foreignIdentifier","attribute","attributeName","primaryKey","_autoGenerated","primaryKeyDeleted","sourceKeyType","type","targetKeyType","sourceAttribute","defaults","targetAttribute","unique","uniqueKey","constraints","references","getTableName","key","onDelete","onUpdate","refreshAttributes","identifierField","foreignIdentifierField","toSource","manyFromSource","oneFromSource","toTarget","manyFromTarget","oneFromTarget","checkNamingCollision","mixin","obj","methods","aliases","mixinMethods","instance","cloneDeep","scopeWhere","throughWhere","scope","clone","where","and","include","push","attributes","joinTableAttributes","required","prototype","hasOwnProperty","call","unscoped","schema","schemaDelimiter","findAll","fn","col","raw","plain","then","result","parseInt","has","sourceInstance","instances","Array","isArray","instancePrimaryKeys","map","or","associatedObjects","differenceWith","a","b","isEqual","length","newAssociatedObjects","toInstanceArray","updateAssociations","currentRows","obsoleteAssociations","promises","defaultAttributes","unassociatedObjects","filter","some","currentRow","newObj","find","throughAttributes","keys","update","obsoleteAssociation","destroy","bulk","unassociatedObject","bulkCreate","Promise","all","catch","error","newInstances","resolve","newInstance","changedAssociations","existingAssociation","current","assoc","oldAssociatedObjects","values","fields","concat","newAssociatedObject","omit","return","verifyAssociationAlias","alias","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\nconst EmptyResultError = require('../errors').EmptyResultError;\nconst Op = require('../operators');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(project => {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(projects => {\n   *   let p1 = projects[0]\n   *   p1.UserProjects.started // Is this project started yet?\n   * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = Object.assign({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    /*\n    * Default/generated source/target keys\n    */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n\n    this._createForeignAndOtherKeys();\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: false, // A paranoid join table does not make sense\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    this.options = Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      let needInjectPaired = false;\n\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.sourceKey\n        ].join('_')\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize(\n        [\n          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n          this.targetKey\n        ].join('_')\n      );\n    }\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = _.defaults({}, this.foreignKeyAttribute, { type: sourceKeyType });\n    const targetAttribute = _.defaults({}, this.otherKeyAttribute, { type: targetKeyType });\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    this.through.model.rawAttributes[this.foreignKey] = Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    this.through.model.rawAttributes[this.otherKey] = Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.through.model.refreshAttributes();\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @see\n   * {@link Model} for a full explanation of options\n   *\n   * @param {Model} instance instance\n   * @param {Object} [options] find options\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (this.scope) {\n      scopeWhere = _.clone(this.scope);\n    }\n\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        where: throughWhere\n      });\n    }\n\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model} instance instance\n   * @param {Object} [options] find options\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  count(instance, options) {\n    const sequelize = this.target.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    return this.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model} sourceInstance source instance to check for an association with\n   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n   * @param {Object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise<boolean>}\n   */\n  has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = Object.assign({\n      raw: true\n    }, options, {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n\n    return this.get(sourceInstance, options).then(associatedObjects =>\n      _.differenceWith(instancePrimaryKeys, associatedObjects,\n        (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0\n    );\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys.\n   * Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {Object} [options.validate] Run validation for the join model\n   * @param {Object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    let where = {};\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n\n    where[identifier] = sourceInstance.get(sourceKey);\n    where = Object.assign(where, this.through.scope);\n\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (Object.keys(attributes).length) {\n            promises.push(\n              this.through.model.update(attributes, Object.assign(options, {\n                where: {\n                  [identifier]: sourceInstance.get(sourceKey),\n                  [foreignIdentifier]: newObj.get(targetKey)\n                }\n              }\n              ))\n            );\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        const where = Object.assign({\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier])\n        }, this.through.scope);\n        promises.push(\n          this.through.model.destroy(_.defaults({\n            where\n          }, options))\n        );\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          let attributes = {};\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          attributes = _.defaults(attributes, unassociatedObject[this.through.model.name], defaultAttributes);\n\n          Object.assign(attributes, this.through.scope);\n          attributes = Object.assign(attributes, this.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(this.through.model.bulkCreate(bulk, Object.assign({ validate: true }, options)));\n      }\n\n      return Utils.Promise.all(promises);\n    };\n\n    return this.through.model.findAll(_.defaults({ where, raw: true }, options))\n      .then(currentRows => updateAssociations(currentRows))\n      .catch(error => {\n        if (error instanceof EmptyResultError) return updateAssociations([]);\n        throw error;\n      });\n  }\n\n  /**\n   * Associate one or several rows with source instance. It will not un-associate any already associated instance\n   * that may be missing from `newInstances`.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {Object} [options.validate] Run validation for the join model.\n   * @param {Object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Utils.Promise.resolve();\n\n    options = _.clone(options) || {};\n\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey))\n    };\n\n    Object.assign(where, association.through.scope);\n\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, Object.assign({ validate: true }, options)));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n        const where = {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        };\n\n\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where })));\n      }\n\n      return Utils.Promise.all(promises);\n    };\n\n    return association.through.model.findAll(_.defaults({ where, raw: true }, options))\n      .then(currentRows => updateAssociations(currentRows))\n      .then(([associations]) => associations)\n      .catch(error => {\n        if (error instanceof EmptyResultError) return updateAssociations();\n        throw error;\n      });\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {Object} [options] Options passed to `through.destroy`\n   *\n   * @returns {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n\n    return association.through.model.destroy(_.defaults({ where }, options));\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {Object} [values] values for target model\n   * @param {Object} [options] Options passed to create and add\n   * @param {Object} [options.through] Additional attributes for the join table\n   *\n   * @returns {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    return association.target.create(values, options).then(newAssociatedObject =>\n      sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject)\n    );\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n"]},"metadata":{},"sourceType":"script"}