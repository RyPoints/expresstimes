{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar constants = require('./constants');\n\nvar CacheDriver = require('./cache-driver');\n\nvar Logger = require('./log').Logger;\n\nvar Mex = require('./mex');\n\nvar OAuth2Client = require('./oauth2client');\n\nvar SelfSignedJwt = require('./self-signed-jwt');\n\nvar UserRealm = require('./user-realm');\n\nvar WSTrustRequest = require('./wstrust-request');\n\nvar OAuth2Parameters = constants.OAuth2.Parameters;\nvar TokenResponseFields = constants.TokenResponseFields;\nvar OAuth2GrantType = constants.OAuth2.GrantType;\nvar OAuth2Scope = constants.OAuth2.Scope;\nvar Saml = constants.Saml;\nvar AccountType = constants.UserRealm.AccountType;\nvar WSTrustVersion = constants.WSTrustVersion;\nvar DeviceCodeResponseParameters = constants.UserCodeResponseFields;\n/**\r\n * Constructs a new TokenRequest object.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {AuthenticationContext} authenticationContext\r\n * @param {string} resource\r\n * @param {string} clientId\r\n * @param {string} redirectUri\r\n */\n\nfunction TokenRequest(callContext, authenticationContext, clientId, resource, redirectUri) {\n  this._log = new Logger('TokenRequest', callContext._logContext);\n  this._callContext = callContext;\n  this._authenticationContext = authenticationContext;\n  this._resource = resource;\n  this._clientId = clientId;\n  this._redirectUri = redirectUri; // This should be set at the beginning of getToken\n  // functions that have a userId.\n\n  this._userId = null;\n  this._userRealm = null;\n  this._pollingClient = {};\n}\n\nTokenRequest.prototype._createUserRealmRequest = function (username) {\n  return new UserRealm(this._callContext, username, this._authenticationContext.authority);\n};\n\nTokenRequest.prototype._createMex = function (mexEndpoint) {\n  return new Mex(this._callContext, mexEndpoint);\n};\n\nTokenRequest.prototype._createWSTrustRequest = function (wstrustEndpoint, appliesTo, wstrustEndpointVersion) {\n  return new WSTrustRequest(this._callContext, wstrustEndpoint, appliesTo, wstrustEndpointVersion);\n};\n\nTokenRequest.prototype._createOAuth2Client = function () {\n  return new OAuth2Client(this._callContext, this._authenticationContext._authority);\n};\n\nTokenRequest.prototype._createSelfSignedJwt = function () {\n  return new SelfSignedJwt(this._callContext, this._authenticationContext._authority, this._clientId);\n};\n\nTokenRequest.prototype._oauthGetToken = function (oauthParameters, callback) {\n  var client = this._createOAuth2Client();\n\n  client.getToken(oauthParameters, callback);\n};\n\nTokenRequest.prototype._oauthGetTokenByPolling = function (oauthParameters, refresh_interval, expires_in, callback) {\n  var client = this._createOAuth2Client();\n\n  client.getTokenWithPolling(oauthParameters, refresh_interval, expires_in, callback);\n  this._pollingClient = client;\n};\n\nTokenRequest.prototype._createCacheDriver = function () {\n  return new CacheDriver(this._callContext, this._authenticationContext.authority, this._resource, this._clientId, this._authenticationContext.cache, this._getTokenWithTokenResponse.bind(this));\n};\n/**\r\n * Used by the cache driver to refresh tokens.\r\n * @param  {TokenResponse}   entry    A token response to refresh.\r\n * @param  {string}   resource The resource for which to get the token.\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype._getTokenWithTokenResponse = function (entry, resource, callback) {\n  this._log.verbose('Called to refresh a token from the cache.');\n\n  var refreshToken = entry[TokenResponseFields.REFRESH_TOKEN];\n\n  this._getTokenWithRefreshToken(refreshToken, resource, null, callback);\n};\n\nTokenRequest.prototype._createCacheQuery = function () {\n  var query = {\n    clientId: this._clientId\n  };\n\n  if (this._userId) {\n    query.userId = this._userId;\n  } else {\n    this._log.verbose('No userId passed for cache query.');\n  }\n\n  return query;\n};\n\nTokenRequest.prototype._getTokenWithCacheWrapper = function (callback, getTokenFunc) {\n  var self = this;\n  this._cacheDriver = this._createCacheDriver();\n\n  var cacheQuery = this._createCacheQuery();\n\n  this._cacheDriver.find(cacheQuery, function (err, token) {\n    if (err) {\n      self._log.warn('Attempt to look for token in cahce resulted in Error');\n\n      self._log.warn('Attempt to look for token in cache resulted in Error: ' + err.stack, true);\n    }\n\n    if (!token) {\n      self._log.verbose('No appropriate cached token found.');\n\n      getTokenFunc.call(self, function (err, tokenResponse) {\n        if (err) {\n          self._log.verbose('getTokenFunc returned with err');\n\n          callback(err, tokenResponse);\n          return;\n        }\n\n        self._log.verbose('Successfully retrieved token from authority');\n\n        self._cacheDriver.add(tokenResponse, function () {\n          callback(null, tokenResponse);\n        });\n      });\n    } else {\n      self._log.info('Returning cached token.');\n\n      callback(err, token);\n    }\n  });\n};\n/**\r\n * Store token into cache.\r\n * @param {object} tokenResponse Token response to be added into the cache.\r\n */\n\n\nTokenRequest.prototype._addTokenIntoCache = function (tokenResponse, callback) {\n  this._cacheDriver = this._createCacheDriver();\n\n  this._log.verbose('Storing retrieved token into cache');\n\n  this._cacheDriver.add(tokenResponse, function (err) {\n    callback(err, tokenResponse);\n  });\n};\n/**\r\n * Adds an OAuth parameter to the paramters object if the parameter is\r\n * not null or undefined.\r\n * @private\r\n * @param {object} parameters  OAuth parameters object.\r\n * @param {string} key         A member of the OAuth2Parameters constants.\r\n * @param {object} value\r\n */\n\n\nfunction _addParameterIfAvailable(parameters, key, value) {\n  if (value) {\n    parameters[key] = value;\n  }\n}\n/**\r\n * Creates a set of basic, common, OAuthParameters based on values that the TokenRequest\r\n * was created with.\r\n * @private\r\n * @param  {string} grantType  A member of the OAuth2GrantType constants.\r\n * @return {object}\r\n */\n\n\nTokenRequest.prototype._createOAuthParameters = function (grantType) {\n  var oauthParameters = {};\n  oauthParameters[OAuth2Parameters.GRANT_TYPE] = grantType;\n\n  if (OAuth2GrantType.AUTHORIZATION_CODE !== grantType && OAuth2GrantType.CLIENT_CREDENTIALS !== grantType && OAuth2GrantType.DEVICE_CODE != grantType) {\n    oauthParameters[OAuth2Parameters.SCOPE] = OAuth2Scope.OPENID;\n  }\n\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.CLIENT_ID, this._clientId);\n\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.RESOURCE, this._resource);\n\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.REDIRECT_URI, this._redirectUri);\n\n  return oauthParameters;\n};\n/**\r\n * Get's a token from AAD using a username and password\r\n * @private\r\n * @param  {string}   username\r\n * @param  {string}   password\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype._getTokenUsernamePasswordManaged = function (username, password, callback) {\n  this._log.verbose('Acquiring token with username password for managed user');\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.PASSWORD);\n\n  oauthParameters[OAuth2Parameters.PASSWORD] = password;\n  oauthParameters[OAuth2Parameters.USERNAME] = username;\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Determines the OAuth SAML grant type to use based on the passed in TokenType\r\n * that was returned from a RSTR.\r\n * @param  {string} wstrustResponse RSTR token type.\r\n * @return {string}                 An OAuth grant type.\r\n */\n\n\nTokenRequest.prototype._getSamlGrantType = function (wstrustResponse) {\n  var tokenType = wstrustResponse.tokenType;\n\n  switch (tokenType) {\n    case Saml.TokenTypeV1:\n      return OAuth2GrantType.SAML1;\n\n    case Saml.TokenTypeV2:\n      return OAuth2GrantType.SAML2;\n\n    default:\n      throw this._log.createError('RSTR returned unknown token type: ' + tokenType);\n  }\n};\n/**\r\n * Performs an OAuth SAML Assertion grant type exchange.  Uses a SAML token as the credential for getting\r\n * an OAuth access token.\r\n * @param  {WSTrustResponse}   wstrustResponse A response from a WSTrustRequest\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._performWSTrustAssertionOAuthExchange = function (wstrustResponse, callback) {\n  this._log.verbose('Performing OAuth assertion grant type exchange.');\n\n  var oauthParameters;\n\n  try {\n    var grantType = this._getSamlGrantType(wstrustResponse);\n\n    var assertion = new Buffer(wstrustResponse.token).toString('base64');\n    oauthParameters = this._createOAuthParameters(grantType);\n    oauthParameters[OAuth2Parameters.ASSERTION] = assertion;\n  } catch (err) {\n    callback(err);\n    return;\n  }\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Exchange a username and password for a SAML token from an ADFS instance via WSTrust.\r\n * @param  {string}   wstrustEndpoint An url of an ADFS WSTrust endpoint.\r\n * @param  {string}   wstrustEndpointVersion The version of the wstrust endpoint.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._performWSTrustExchange = function (wstrustEndpoint, wstrustEndpointVersion, username, password, callback) {\n  var self = this;\n\n  var wstrust = this._createWSTrustRequest(wstrustEndpoint, 'urn:federation:MicrosoftOnline', wstrustEndpointVersion);\n\n  wstrust.acquireToken(username, password, function (rstErr, response) {\n    if (rstErr) {\n      callback(rstErr);\n      return;\n    }\n\n    if (!response.token) {\n      var rstrErr = self._log.createError('Unsucessful RSTR.\\n\\terror code: ' + response.errorCode + '\\n\\tfaultMessage: ' + response.faultMessage, true);\n\n      callback(rstrErr);\n      return;\n    }\n\n    callback(null, response);\n  });\n};\n/**\r\n * Given a username and password this method invokes a WSTrust and OAuth exchange to get an access token.\r\n * @param  {string}   wstrustEndpoint An url of an ADFS WSTrust endpoint.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._performUsernamePasswordForAccessTokenExchange = function (wstrustEndpoint, wstrustEndpointVersion, username, password, callback) {\n  var self = this;\n\n  this._performWSTrustExchange(wstrustEndpoint, wstrustEndpointVersion, username, password, function (err, wstrustResponse) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self._performWSTrustAssertionOAuthExchange(wstrustResponse, callback);\n  });\n};\n/**\r\n * Returns an Error object indicating that AAD did not return a WSTrust endpoint.\r\n * @return {Error}\r\n */\n\n\nTokenRequest.prototype._createADWSTrustEndpointError = function () {\n  return this._log.createError('AAD did not return a WSTrust endpoint.  Unable to proceed.');\n};\n/**\r\n * Gets an OAuth access token using a username and password via a federated ADFS instance.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._getTokenUsernamePasswordFederated = function (username, password, callback) {\n  this._log.verbose('Acquiring token with username password for federated user');\n\n  var self = this;\n\n  if (!this._userRealm.federationMetadataUrl) {\n    this._log.warn('Unable to retrieve federationMetadataUrl from AAD.  Attempting fallback to AAD supplied endpoint.');\n\n    if (!this._userRealm.federationActiveAuthUrl) {\n      callback(this._createADWSTrustEndpointError());\n      return;\n    }\n\n    var wstrustVersion = this._parseWStrustVersionFromFederationActiveAuthUrl(this._userRealm.federationActiveAuthUrl);\n\n    this._log.verbose('Wstrust endpoint version is: ' + wstrustVersion);\n\n    this._performUsernamePasswordForAccessTokenExchange(this._userRealm.federationActiveAuthUrl, wstrustVersion, username, password, callback);\n\n    return;\n  } else {\n    var mexEndpoint = this._userRealm.federationMetadataUrl;\n\n    this._log.verbose('Attempting mex');\n\n    this._log.verbose('Attempting mex at: ' + mexEndpoint, true);\n\n    var mex = this._createMex(mexEndpoint);\n\n    mex.discover(function (mexErr) {\n      var wstrustEndpoint;\n      wstrustVersion = WSTrustVersion.UNDEFINED;\n\n      if (mexErr) {\n        self._log.warn('MEX exchange failed.  Attempting fallback to AAD supplied endpoint.');\n\n        wstrustEndpoint = self._userRealm.federationActiveAuthUrl;\n        wstrustVersion = self._parseWStrustVersionFromFederationActiveAuthUrl(self._userRealm.federationActiveAuthUrl);\n\n        if (!wstrustEndpoint) {\n          callback(self._createADWSTrustEndpointError());\n          return;\n        }\n      } else {\n        wstrustEndpoint = mex.usernamePasswordPolicy.url;\n        wstrustVersion = mex.usernamePasswordPolicy.version;\n      }\n\n      self._performUsernamePasswordForAccessTokenExchange(wstrustEndpoint, wstrustVersion, username, password, callback);\n\n      return;\n    });\n  }\n};\n/**\r\n * Gets wstrust endpoint version from the federation active auth url.\r\n * @private\r\n * @param  {string}   federationActiveAuthUrl  federationActiveAuthUrl\r\n * @return {object}   The wstrust endpoint version.\r\n */\n\n\nTokenRequest.prototype._parseWStrustVersionFromFederationActiveAuthUrl = function (federationActiveAuthUrl) {\n  var wstrust2005Regex = /[/trust]?[2005][/usernamemixed]?/;\n  var wstrust13Regex = /[/trust]?[13][/usernamemixed]?/;\n\n  if (wstrust2005Regex.exec(federationActiveAuthUrl)) {\n    return WSTrustVersion.WSTRUST2005;\n  } else if (wstrust13Regex.exec(federationActiveAuthUrl)) {\n    return WSTrustVersion.WSTRUST13;\n  }\n\n  return WSTrustVersion.UNDEFINED;\n};\n/**\r\n * Decides whether the username represents a managed or a federated user and then\r\n * obtains a token using the appropriate protocol flow.\r\n * @private\r\n * @param  {string}   username\r\n * @param  {string}   password\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithUsernamePassword = function (username, password, callback) {\n  this._log.info('Acquiring token with username password');\n\n  this._userId = username;\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    var self = this;\n\n    if (this._authenticationContext._authority._isAdfsAuthority) {\n      this._log.info('Skipping user realm discovery for ADFS authority');\n\n      self._getTokenUsernamePasswordManaged(username, password, getTokenCompleteCallback);\n\n      return;\n    }\n\n    this._userRealm = this._createUserRealmRequest(username);\n\n    this._userRealm.discover(function (err) {\n      if (err) {\n        getTokenCompleteCallback(err);\n        return;\n      }\n\n      switch (self._userRealm.accountType) {\n        case AccountType.Managed:\n          self._getTokenUsernamePasswordManaged(username, password, getTokenCompleteCallback);\n\n          return;\n\n        case AccountType.Federated:\n          self._getTokenUsernamePasswordFederated(username, password, getTokenCompleteCallback);\n\n          return;\n\n        default:\n          getTokenCompleteCallback(self._log.createError('Server returned an unknown AccountType: ' + self._userRealm.AccountType));\n      }\n    });\n  });\n};\n/**\r\n * Obtains a token using client credentials\r\n * @private\r\n * @param  {string}   clientSecret\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithClientCredentials = function (clientSecret, callback) {\n  this._log.info('Getting token with client credentials.');\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    var oauthParameters = this._createOAuthParameters(OAuth2GrantType.CLIENT_CREDENTIALS);\n\n    oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\n\n    this._oauthGetToken(oauthParameters, getTokenCompleteCallback);\n  });\n};\n/**\r\n * Obtains a token using an authorization code.\r\n * @private\r\n * @param  {string}   authorizationCode\r\n * @param  {string}   clientSecret\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithAuthorizationCode = function (authorizationCode, clientSecret, callback) {\n  this._log.info('Getting token with auth code.');\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.AUTHORIZATION_CODE);\n\n  oauthParameters[OAuth2Parameters.CODE] = authorizationCode;\n  oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Obtains a token using a refresh token.\r\n * @param  {string}   refreshToken\r\n * @param  {string}   resource\r\n * @param  {string}   [clientSecret]\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype._getTokenWithRefreshToken = function (refreshToken, resource, clientSecret, callback) {\n  this._log.info('Getting a new token from a refresh token.');\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.REFRESH_TOKEN);\n\n  if (resource) {\n    oauthParameters[OAuth2Parameters.RESOURCE] = resource;\n  }\n\n  if (clientSecret) {\n    oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\n  }\n\n  oauthParameters[OAuth2Parameters.REFRESH_TOKEN] = refreshToken;\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Obtains a token using a refresh token.\r\n * @param  {string}   refreshToken\r\n * @param  {string}   [clientSecret]\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithRefreshToken = function (refreshToken, clientSecret, callback) {\n  this._getTokenWithRefreshToken(refreshToken, null, clientSecret, callback);\n};\n/**\r\n * Obtains a token from the cache, refreshing it or using a MRRT if necessary.\r\n * @param {string}  [userId] The user associated with the cached token.\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenFromCacheWithRefresh = function (userId, callback) {\n  var self = this;\n\n  this._log.info('Getting token from cache with refresh if necessary.');\n\n  this._userId = userId;\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    // If this method was called then no cached entry was found.  Since\n    // this particular version of acquireToken can only retrieve tokens\n    // from the cache, return an error.\n    getTokenCompleteCallback(self._log.createError('Entry not found in cache.'));\n  });\n};\n/**\r\n * Creates a self signed jwt.\r\n * @param  {string} authorityUrl\r\n * @param  {string} certificate  A PEM encoded certificate private key.\r\n * @param  {string} thumbprint\r\n * @return {string}              A self signed JWT\r\n */\n\n\nTokenRequest.prototype._createJwt = function (authorityUrl, certificate, thumbprint) {\n  var jwt;\n\n  var ssj = this._createSelfSignedJwt();\n\n  jwt = ssj.create(certificate, thumbprint);\n\n  if (!jwt) {\n    throw this._log.createError('Failed to create JWT');\n  }\n\n  return jwt;\n};\n/**\r\n * Obtains a token via a certificate.  The certificate is used to generate a self signed\r\n * JWT token that is passed as a client_assertion.\r\n * @param  {string}                 certificate   A PEM encoded certificate private key.\r\n * @param  {string}                 thumbprint    A hex encoded thumbprint of the certificate.\r\n * @param  {AcquireTokenCallback}   callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithCertificate = function (certificate, thumbprint, callback) {\n  this._log.info('Getting a token via certificate.');\n\n  var authorityUrl = this._authenticationContext._authority;\n  var jwt;\n\n  try {\n    jwt = this._createJwt(authorityUrl, certificate, thumbprint);\n  } catch (err) {\n    callback(err);\n    return;\n  }\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.CLIENT_CREDENTIALS);\n\n  oauthParameters[OAuth2Parameters.CLIENT_ASSERTION_TYPE] = OAuth2GrantType.JWT_BEARER;\n  oauthParameters[OAuth2Parameters.CLIENT_ASSERTION] = jwt;\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    this._oauthGetToken(oauthParameters, getTokenCompleteCallback);\n  });\n};\n\nTokenRequest.prototype.getTokenWithDeviceCode = function (userCodeInfo, callback) {\n  this._log.info('Getting a token via device code');\n\n  var self = this;\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.DEVICE_CODE);\n\n  oauthParameters[OAuth2Parameters.CODE] = userCodeInfo[DeviceCodeResponseParameters.DEVICE_CODE];\n  var interval = userCodeInfo[DeviceCodeResponseParameters.INTERVAL];\n  var expires_in = userCodeInfo[DeviceCodeResponseParameters.EXPIRES_IN];\n\n  if (interval <= 0) {\n    callback(new Error('invalid refresh interval'));\n  }\n\n  this._oauthGetTokenByPolling(oauthParameters, interval, expires_in, function (err, tokenResponse) {\n    if (err) {\n      self._log.verbose('Token polling request returend with err.');\n\n      callback(err, tokenResponse);\n    } else {\n      self._addTokenIntoCache(tokenResponse, callback);\n    }\n  });\n};\n\nTokenRequest.prototype.cancelTokenRequestWithDeviceCode = function () {\n  this._pollingClient.cancelPollingRequest();\n};\n\nmodule.exports = TokenRequest;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/adal-node/lib/token-request.js"],"names":["constants","require","CacheDriver","Logger","Mex","OAuth2Client","SelfSignedJwt","UserRealm","WSTrustRequest","OAuth2Parameters","OAuth2","Parameters","TokenResponseFields","OAuth2GrantType","GrantType","OAuth2Scope","Scope","Saml","AccountType","WSTrustVersion","DeviceCodeResponseParameters","UserCodeResponseFields","TokenRequest","callContext","authenticationContext","clientId","resource","redirectUri","_log","_logContext","_callContext","_authenticationContext","_resource","_clientId","_redirectUri","_userId","_userRealm","_pollingClient","prototype","_createUserRealmRequest","username","authority","_createMex","mexEndpoint","_createWSTrustRequest","wstrustEndpoint","appliesTo","wstrustEndpointVersion","_createOAuth2Client","_authority","_createSelfSignedJwt","_oauthGetToken","oauthParameters","callback","client","getToken","_oauthGetTokenByPolling","refresh_interval","expires_in","getTokenWithPolling","_createCacheDriver","cache","_getTokenWithTokenResponse","bind","entry","verbose","refreshToken","REFRESH_TOKEN","_getTokenWithRefreshToken","_createCacheQuery","query","userId","_getTokenWithCacheWrapper","getTokenFunc","self","_cacheDriver","cacheQuery","find","err","token","warn","stack","call","tokenResponse","add","info","_addTokenIntoCache","_addParameterIfAvailable","parameters","key","value","_createOAuthParameters","grantType","GRANT_TYPE","AUTHORIZATION_CODE","CLIENT_CREDENTIALS","DEVICE_CODE","SCOPE","OPENID","CLIENT_ID","RESOURCE","REDIRECT_URI","_getTokenUsernamePasswordManaged","password","PASSWORD","USERNAME","_getSamlGrantType","wstrustResponse","tokenType","TokenTypeV1","SAML1","TokenTypeV2","SAML2","createError","_performWSTrustAssertionOAuthExchange","assertion","Buffer","toString","ASSERTION","_performWSTrustExchange","wstrust","acquireToken","rstErr","response","rstrErr","errorCode","faultMessage","_performUsernamePasswordForAccessTokenExchange","_createADWSTrustEndpointError","_getTokenUsernamePasswordFederated","federationMetadataUrl","federationActiveAuthUrl","wstrustVersion","_parseWStrustVersionFromFederationActiveAuthUrl","mex","discover","mexErr","UNDEFINED","usernamePasswordPolicy","url","version","wstrust2005Regex","wstrust13Regex","exec","WSTRUST2005","WSTRUST13","getTokenWithUsernamePassword","getTokenCompleteCallback","_isAdfsAuthority","accountType","Managed","Federated","getTokenWithClientCredentials","clientSecret","CLIENT_SECRET","getTokenWithAuthorizationCode","authorizationCode","CODE","getTokenWithRefreshToken","getTokenFromCacheWithRefresh","_createJwt","authorityUrl","certificate","thumbprint","jwt","ssj","create","getTokenWithCertificate","CLIENT_ASSERTION_TYPE","JWT_BEARER","CLIENT_ASSERTION","getTokenWithDeviceCode","userCodeInfo","interval","INTERVAL","EXPIRES_IN","Error","cancelTokenRequestWithDeviceCode","cancelPollingRequest","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n'use strict';\r\n\r\nvar constants = require('./constants');\r\nvar CacheDriver = require('./cache-driver');\r\nvar Logger = require('./log').Logger;\r\nvar Mex = require('./mex');\r\nvar OAuth2Client = require('./oauth2client');\r\nvar SelfSignedJwt = require('./self-signed-jwt');\r\nvar UserRealm = require('./user-realm');\r\nvar WSTrustRequest = require('./wstrust-request');\r\n\r\nvar OAuth2Parameters = constants.OAuth2.Parameters;\r\nvar TokenResponseFields = constants.TokenResponseFields;\r\nvar OAuth2GrantType = constants.OAuth2.GrantType;\r\nvar OAuth2Scope = constants.OAuth2.Scope;\r\nvar Saml = constants.Saml;\r\nvar AccountType = constants.UserRealm.AccountType;\r\nvar WSTrustVersion = constants.WSTrustVersion;\r\nvar DeviceCodeResponseParameters = constants.UserCodeResponseFields;\r\n\r\n/**\r\n * Constructs a new TokenRequest object.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {AuthenticationContext} authenticationContext\r\n * @param {string} resource\r\n * @param {string} clientId\r\n * @param {string} redirectUri\r\n */\r\nfunction TokenRequest(callContext, authenticationContext, clientId, resource, redirectUri) {\r\n  this._log = new Logger('TokenRequest', callContext._logContext);\r\n  this._callContext = callContext;\r\n  this._authenticationContext = authenticationContext;\r\n  this._resource = resource;\r\n  this._clientId = clientId;\r\n  this._redirectUri = redirectUri;\r\n\r\n  // This should be set at the beginning of getToken\r\n  // functions that have a userId.\r\n  this._userId = null;\r\n\r\n  this._userRealm = null;\r\n  this._pollingClient = {};\r\n}\r\n\r\nTokenRequest.prototype._createUserRealmRequest = function(username) {\r\n  return new UserRealm(this._callContext, username, this._authenticationContext.authority);\r\n};\r\n\r\nTokenRequest.prototype._createMex = function(mexEndpoint) {\r\n  return new Mex(this._callContext, mexEndpoint);\r\n};\r\n\r\nTokenRequest.prototype._createWSTrustRequest = function(wstrustEndpoint, appliesTo, wstrustEndpointVersion) {\r\n  return new WSTrustRequest(this._callContext, wstrustEndpoint, appliesTo, wstrustEndpointVersion);\r\n};\r\n\r\nTokenRequest.prototype._createOAuth2Client = function() {\r\n  return new OAuth2Client(this._callContext, this._authenticationContext._authority);\r\n};\r\n\r\nTokenRequest.prototype._createSelfSignedJwt = function() {\r\n  return new SelfSignedJwt(this._callContext, this._authenticationContext._authority, this._clientId);\r\n};\r\n\r\nTokenRequest.prototype._oauthGetToken = function(oauthParameters, callback) {\r\n  var client = this._createOAuth2Client();\r\n  client.getToken(oauthParameters, callback);\r\n};\r\n\r\nTokenRequest.prototype._oauthGetTokenByPolling = function(oauthParameters, refresh_interval, expires_in, callback){\r\n  var client = this._createOAuth2Client();\r\n  client.getTokenWithPolling(oauthParameters, refresh_interval, expires_in, callback);\r\n  this._pollingClient = client;\r\n}\r\n\r\nTokenRequest.prototype._createCacheDriver = function() {\r\n  return new CacheDriver(\r\n    this._callContext,\r\n    this._authenticationContext.authority,\r\n    this._resource,\r\n    this._clientId,\r\n    this._authenticationContext.cache,\r\n    this._getTokenWithTokenResponse.bind(this)\r\n    );\r\n};\r\n\r\n/**\r\n * Used by the cache driver to refresh tokens.\r\n * @param  {TokenResponse}   entry    A token response to refresh.\r\n * @param  {string}   resource The resource for which to get the token.\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype._getTokenWithTokenResponse = function(entry, resource, callback) {\r\n  this._log.verbose('Called to refresh a token from the cache.');\r\n  var refreshToken = entry[TokenResponseFields.REFRESH_TOKEN];\r\n  this._getTokenWithRefreshToken(refreshToken, resource, null, callback);\r\n};\r\n\r\nTokenRequest.prototype._createCacheQuery = function() {\r\n  var query = {\r\n    clientId : this._clientId\r\n  };\r\n\r\n  if (this._userId) {\r\n    query.userId = this._userId;\r\n  } else {\r\n    this._log.verbose('No userId passed for cache query.');\r\n  }\r\n\r\n  return query;\r\n};\r\n\r\n\r\nTokenRequest.prototype._getTokenWithCacheWrapper = function(callback, getTokenFunc) {\r\n  var self = this;\r\n  this._cacheDriver = this._createCacheDriver();\r\n  var cacheQuery = this._createCacheQuery();\r\n  this._cacheDriver.find(cacheQuery, function(err, token) {\r\n    if (err) {\r\n      self._log.warn('Attempt to look for token in cahce resulted in Error');\r\n      self._log.warn('Attempt to look for token in cache resulted in Error: ' + err.stack, true);\r\n    }\r\n\r\n    if (!token) {\r\n      self._log.verbose('No appropriate cached token found.');\r\n      getTokenFunc.call(self, function(err, tokenResponse) {\r\n        if (err) {\r\n          self._log.verbose('getTokenFunc returned with err');\r\n          callback(err, tokenResponse);\r\n          return;\r\n        }\r\n\r\n        self._log.verbose('Successfully retrieved token from authority');\r\n        self._cacheDriver.add(tokenResponse, function() {\r\n          callback(null, tokenResponse);\r\n        });\r\n      });\r\n    } else {\r\n      self._log.info('Returning cached token.');\r\n      callback(err, token);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Store token into cache.\r\n * @param {object} tokenResponse Token response to be added into the cache.\r\n */\r\nTokenRequest.prototype._addTokenIntoCache = function(tokenResponse, callback) {\r\n    this._cacheDriver = this._createCacheDriver();\r\n    this._log.verbose('Storing retrieved token into cache');\r\n    this._cacheDriver.add(tokenResponse, function(err) {\r\n      callback(err, tokenResponse);\r\n    });\r\n};\r\n\r\n/**\r\n * Adds an OAuth parameter to the paramters object if the parameter is\r\n * not null or undefined.\r\n * @private\r\n * @param {object} parameters  OAuth parameters object.\r\n * @param {string} key         A member of the OAuth2Parameters constants.\r\n * @param {object} value\r\n */\r\nfunction _addParameterIfAvailable(parameters, key, value) {\r\n  if (value) {\r\n    parameters[key] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a set of basic, common, OAuthParameters based on values that the TokenRequest\r\n * was created with.\r\n * @private\r\n * @param  {string} grantType  A member of the OAuth2GrantType constants.\r\n * @return {object}\r\n */\r\nTokenRequest.prototype._createOAuthParameters = function(grantType) {\r\n  var oauthParameters = {};\r\n  oauthParameters[OAuth2Parameters.GRANT_TYPE] = grantType;\r\n\r\n  if (OAuth2GrantType.AUTHORIZATION_CODE !== grantType &&\r\n    OAuth2GrantType.CLIENT_CREDENTIALS !== grantType &&\r\n    OAuth2GrantType.DEVICE_CODE != grantType) {\r\n    oauthParameters[OAuth2Parameters.SCOPE] = OAuth2Scope.OPENID;\r\n  }\r\n\r\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.CLIENT_ID, this._clientId);\r\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.RESOURCE, this._resource);\r\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.REDIRECT_URI, this._redirectUri);\r\n\r\n  return oauthParameters;\r\n};\r\n\r\n/**\r\n * Get's a token from AAD using a username and password\r\n * @private\r\n * @param  {string}   username\r\n * @param  {string}   password\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype._getTokenUsernamePasswordManaged = function(username, password, callback) {\r\n  this._log.verbose('Acquiring token with username password for managed user');\r\n\r\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.PASSWORD);\r\n\r\n  oauthParameters[OAuth2Parameters.PASSWORD] = password;\r\n  oauthParameters[OAuth2Parameters.USERNAME] = username;\r\n\r\n  this._oauthGetToken(oauthParameters, callback);\r\n};\r\n\r\n/**\r\n * Determines the OAuth SAML grant type to use based on the passed in TokenType\r\n * that was returned from a RSTR.\r\n * @param  {string} wstrustResponse RSTR token type.\r\n * @return {string}                 An OAuth grant type.\r\n */\r\nTokenRequest.prototype._getSamlGrantType = function(wstrustResponse) {\r\n  var tokenType = wstrustResponse.tokenType;\r\n  switch (tokenType) {\r\n    case Saml.TokenTypeV1:\r\n      return OAuth2GrantType.SAML1;\r\n    case Saml.TokenTypeV2:\r\n      return OAuth2GrantType.SAML2;\r\n    default:\r\n      throw this._log.createError('RSTR returned unknown token type: ' + tokenType);\r\n  }\r\n};\r\n\r\n/**\r\n * Performs an OAuth SAML Assertion grant type exchange.  Uses a SAML token as the credential for getting\r\n * an OAuth access token.\r\n * @param  {WSTrustResponse}   wstrustResponse A response from a WSTrustRequest\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\r\nTokenRequest.prototype._performWSTrustAssertionOAuthExchange = function(wstrustResponse, callback) {\r\n  this._log.verbose('Performing OAuth assertion grant type exchange.');\r\n\r\n  var oauthParameters;\r\n  try {\r\n    var grantType = this._getSamlGrantType(wstrustResponse);\r\n    var assertion = new Buffer(wstrustResponse.token).toString('base64');\r\n    oauthParameters = this._createOAuthParameters(grantType);\r\n    oauthParameters[OAuth2Parameters.ASSERTION] = assertion;\r\n  } catch (err) {\r\n    callback(err);\r\n    return;\r\n  }\r\n\r\n  this._oauthGetToken(oauthParameters, callback);\r\n};\r\n\r\n/**\r\n * Exchange a username and password for a SAML token from an ADFS instance via WSTrust.\r\n * @param  {string}   wstrustEndpoint An url of an ADFS WSTrust endpoint.\r\n * @param  {string}   wstrustEndpointVersion The version of the wstrust endpoint.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\r\nTokenRequest.prototype._performWSTrustExchange = function(wstrustEndpoint, wstrustEndpointVersion, username, password, callback) {\r\n  var self = this;\r\n  var wstrust = this._createWSTrustRequest(wstrustEndpoint, 'urn:federation:MicrosoftOnline', wstrustEndpointVersion);\r\n  wstrust.acquireToken(username, password, function(rstErr, response) {\r\n    if (rstErr) {\r\n      callback(rstErr);\r\n      return;\r\n    }\r\n\r\n    if (!response.token) {\r\n      var rstrErr = self._log.createError('Unsucessful RSTR.\\n\\terror code: ' + response.errorCode + '\\n\\tfaultMessage: ' + response.faultMessage, true);\r\n      callback(rstrErr);\r\n      return;\r\n    }\r\n\r\n    callback(null, response);\r\n  });\r\n};\r\n\r\n/**\r\n * Given a username and password this method invokes a WSTrust and OAuth exchange to get an access token.\r\n * @param  {string}   wstrustEndpoint An url of an ADFS WSTrust endpoint.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\r\nTokenRequest.prototype._performUsernamePasswordForAccessTokenExchange = function(wstrustEndpoint, wstrustEndpointVersion, username, password, callback) {\r\n  var self = this;\r\n  this._performWSTrustExchange(wstrustEndpoint, wstrustEndpointVersion, username, password, function(err, wstrustResponse) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    self._performWSTrustAssertionOAuthExchange(wstrustResponse, callback);\r\n  });\r\n};\r\n\r\n/**\r\n * Returns an Error object indicating that AAD did not return a WSTrust endpoint.\r\n * @return {Error}\r\n */\r\nTokenRequest.prototype._createADWSTrustEndpointError = function() {\r\n  return this._log.createError('AAD did not return a WSTrust endpoint.  Unable to proceed.');\r\n};\r\n\r\n/**\r\n * Gets an OAuth access token using a username and password via a federated ADFS instance.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\r\nTokenRequest.prototype._getTokenUsernamePasswordFederated = function(username, password, callback) {\r\n  this._log.verbose('Acquiring token with username password for federated user');\r\n\r\n  var self = this;\r\n  if (!this._userRealm.federationMetadataUrl) {\r\n    this._log.warn('Unable to retrieve federationMetadataUrl from AAD.  Attempting fallback to AAD supplied endpoint.');\r\n\r\n    if (!this._userRealm.federationActiveAuthUrl) {\r\n      callback(this._createADWSTrustEndpointError());\r\n      return;\r\n    }\r\n\r\n    var wstrustVersion = this._parseWStrustVersionFromFederationActiveAuthUrl(this._userRealm.federationActiveAuthUrl);\r\n    this._log.verbose('Wstrust endpoint version is: ' + wstrustVersion);\r\n    this._performUsernamePasswordForAccessTokenExchange(this._userRealm.federationActiveAuthUrl, wstrustVersion, username, password, callback);\r\n    return;\r\n  } else {\r\n    var mexEndpoint = this._userRealm.federationMetadataUrl;\r\n    this._log.verbose('Attempting mex');\r\n    this._log.verbose('Attempting mex at: ' + mexEndpoint, true);\r\n    var mex = this._createMex(mexEndpoint);\r\n    mex.discover(function(mexErr) {\r\n      var wstrustEndpoint;\r\n      wstrustVersion = WSTrustVersion.UNDEFINED;\r\n      if (mexErr) {\r\n        self._log.warn('MEX exchange failed.  Attempting fallback to AAD supplied endpoint.');\r\n\r\n        wstrustEndpoint = self._userRealm.federationActiveAuthUrl;\r\n        wstrustVersion = self._parseWStrustVersionFromFederationActiveAuthUrl(self._userRealm.federationActiveAuthUrl);\r\n        if (!wstrustEndpoint) {\r\n          callback(self._createADWSTrustEndpointError());\r\n          return;\r\n        }\r\n      } else {\r\n        wstrustEndpoint = mex.usernamePasswordPolicy.url;\r\n        wstrustVersion = mex.usernamePasswordPolicy.version;\r\n      }\r\n\r\n      self._performUsernamePasswordForAccessTokenExchange(wstrustEndpoint, wstrustVersion, username, password, callback);\r\n      return;\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Gets wstrust endpoint version from the federation active auth url.\r\n * @private\r\n * @param  {string}   federationActiveAuthUrl  federationActiveAuthUrl\r\n * @return {object}   The wstrust endpoint version.\r\n */\r\nTokenRequest.prototype._parseWStrustVersionFromFederationActiveAuthUrl = function(federationActiveAuthUrl) {\r\n    var wstrust2005Regex = /[/trust]?[2005][/usernamemixed]?/;\r\n    var wstrust13Regex = /[/trust]?[13][/usernamemixed]?/;\r\n\r\n    if (wstrust2005Regex.exec(federationActiveAuthUrl)) {\r\n        return WSTrustVersion.WSTRUST2005;\r\n    }\r\n    else if (wstrust13Regex.exec(federationActiveAuthUrl)) {\r\n        return WSTrustVersion.WSTRUST13;\r\n    }\r\n\r\n    return WSTrustVersion.UNDEFINED;\r\n};\r\n\r\n/**\r\n * Decides whether the username represents a managed or a federated user and then\r\n * obtains a token using the appropriate protocol flow.\r\n * @private\r\n * @param  {string}   username\r\n * @param  {string}   password\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype.getTokenWithUsernamePassword = function(username, password, callback) {\r\n  this._log.info('Acquiring token with username password');\r\n  this._userId = username;\r\n\r\n  this._getTokenWithCacheWrapper(callback, function(getTokenCompleteCallback) {\r\n    var self = this;\r\n\r\n      if(this._authenticationContext._authority._isAdfsAuthority) {\r\n        this._log.info('Skipping user realm discovery for ADFS authority');\r\n\r\n        self._getTokenUsernamePasswordManaged(username, password, getTokenCompleteCallback);\r\n        return;\r\n      }\r\n\r\n    this._userRealm = this._createUserRealmRequest(username);\r\n    this._userRealm.discover(function(err) {\r\n      if (err) {\r\n        getTokenCompleteCallback(err);\r\n        return;\r\n      }\r\n\r\n      switch(self._userRealm.accountType) {\r\n        case AccountType.Managed:\r\n          self._getTokenUsernamePasswordManaged(username, password, getTokenCompleteCallback);\r\n          return;\r\n        case AccountType.Federated:\r\n          self._getTokenUsernamePasswordFederated(username, password, getTokenCompleteCallback);\r\n          return;\r\n        default:\r\n          getTokenCompleteCallback(self._log.createError('Server returned an unknown AccountType: ' + self._userRealm.AccountType));\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Obtains a token using client credentials\r\n * @private\r\n * @param  {string}   clientSecret\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype.getTokenWithClientCredentials = function(clientSecret, callback) {\r\n  this._log.info('Getting token with client credentials.');\r\n\r\n  this._getTokenWithCacheWrapper(callback, function(getTokenCompleteCallback) {\r\n    var oauthParameters = this._createOAuthParameters(OAuth2GrantType.CLIENT_CREDENTIALS);\r\n\r\n    oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\r\n\r\n    this._oauthGetToken(oauthParameters, getTokenCompleteCallback);\r\n  });\r\n};\r\n\r\n/**\r\n * Obtains a token using an authorization code.\r\n * @private\r\n * @param  {string}   authorizationCode\r\n * @param  {string}   clientSecret\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype.getTokenWithAuthorizationCode = function(authorizationCode, clientSecret, callback) {\r\n  this._log.info('Getting token with auth code.');\r\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.AUTHORIZATION_CODE);\r\n\r\n  oauthParameters[OAuth2Parameters.CODE] = authorizationCode;\r\n  oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\r\n\r\n  this._oauthGetToken(oauthParameters, callback);\r\n};\r\n\r\n/**\r\n * Obtains a token using a refresh token.\r\n * @param  {string}   refreshToken\r\n * @param  {string}   resource\r\n * @param  {string}   [clientSecret]\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype._getTokenWithRefreshToken = function(refreshToken, resource, clientSecret, callback) {\r\n  this._log.info('Getting a new token from a refresh token.');\r\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.REFRESH_TOKEN);\r\n\r\n  if (resource) {\r\n    oauthParameters[OAuth2Parameters.RESOURCE] = resource;\r\n  }\r\n\r\n  if (clientSecret) {\r\n    oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\r\n  }\r\n\r\n  oauthParameters[OAuth2Parameters.REFRESH_TOKEN] = refreshToken;\r\n\r\n  this._oauthGetToken(oauthParameters, callback);\r\n};\r\n\r\n/**\r\n * Obtains a token using a refresh token.\r\n * @param  {string}   refreshToken\r\n * @param  {string}   [clientSecret]\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype.getTokenWithRefreshToken = function(refreshToken, clientSecret, callback) {\r\n  this._getTokenWithRefreshToken(refreshToken, null, clientSecret, callback);\r\n};\r\n\r\n/**\r\n * Obtains a token from the cache, refreshing it or using a MRRT if necessary.\r\n * @param {string}  [userId] The user associated with the cached token.\r\n * @param  {AcquireTokenCallback} callback\r\n */\r\nTokenRequest.prototype.getTokenFromCacheWithRefresh = function(userId, callback) {\r\n  var self = this;\r\n  this._log.info('Getting token from cache with refresh if necessary.');\r\n\r\n  this._userId = userId;\r\n  this._getTokenWithCacheWrapper(callback, function(getTokenCompleteCallback) {\r\n    // If this method was called then no cached entry was found.  Since\r\n    // this particular version of acquireToken can only retrieve tokens\r\n    // from the cache, return an error.\r\n    getTokenCompleteCallback(self._log.createError('Entry not found in cache.'));\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a self signed jwt.\r\n * @param  {string} authorityUrl\r\n * @param  {string} certificate  A PEM encoded certificate private key.\r\n * @param  {string} thumbprint\r\n * @return {string}              A self signed JWT\r\n */\r\nTokenRequest.prototype._createJwt = function(authorityUrl, certificate, thumbprint) {\r\n  var jwt;\r\n  var ssj = this._createSelfSignedJwt();\r\n  jwt = ssj.create(certificate, thumbprint);\r\n  if (!jwt) {\r\n    throw this._log.createError('Failed to create JWT');\r\n  }\r\n\r\n  return jwt;\r\n};\r\n\r\n/**\r\n * Obtains a token via a certificate.  The certificate is used to generate a self signed\r\n * JWT token that is passed as a client_assertion.\r\n * @param  {string}                 certificate   A PEM encoded certificate private key.\r\n * @param  {string}                 thumbprint    A hex encoded thumbprint of the certificate.\r\n * @param  {AcquireTokenCallback}   callback\r\n */\r\nTokenRequest.prototype.getTokenWithCertificate = function(certificate, thumbprint, callback) {\r\n\r\n  this._log.info('Getting a token via certificate.');\r\n\r\n  var authorityUrl = this._authenticationContext._authority;\r\n\r\n  var jwt;\r\n  try {\r\n    jwt = this._createJwt(authorityUrl, certificate, thumbprint);\r\n  } catch (err) {\r\n    callback(err);\r\n    return;\r\n  }\r\n\r\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.CLIENT_CREDENTIALS);\r\n  oauthParameters[OAuth2Parameters.CLIENT_ASSERTION_TYPE] = OAuth2GrantType.JWT_BEARER;\r\n  oauthParameters[OAuth2Parameters.CLIENT_ASSERTION] = jwt;\r\n\r\n  this._getTokenWithCacheWrapper(callback, function(getTokenCompleteCallback) {\r\n    this._oauthGetToken(oauthParameters, getTokenCompleteCallback);\r\n  });\r\n};\r\n\r\nTokenRequest.prototype.getTokenWithDeviceCode = function(userCodeInfo, callback) {\r\n   this._log.info('Getting a token via device code');\r\n   var self = this;\r\n\r\n   var oauthParameters = this._createOAuthParameters(OAuth2GrantType.DEVICE_CODE);\r\n   oauthParameters[OAuth2Parameters.CODE] = userCodeInfo[DeviceCodeResponseParameters.DEVICE_CODE];\r\n\r\n   var interval = userCodeInfo[DeviceCodeResponseParameters.INTERVAL];\r\n   var expires_in = userCodeInfo[DeviceCodeResponseParameters.EXPIRES_IN];\r\n\r\n   if (interval <= 0) {\r\n     callback(new Error('invalid refresh interval'));\r\n   }\r\n\r\n   this._oauthGetTokenByPolling(oauthParameters, interval, expires_in, function(err, tokenResponse) {\r\n     if (err) {\r\n       self._log.verbose('Token polling request returend with err.');\r\n       callback(err, tokenResponse);\r\n     }\r\n     else {\r\n       self._addTokenIntoCache(tokenResponse, callback);\r\n     }\r\n   });\r\n};\r\n\r\nTokenRequest.prototype.cancelTokenRequestWithDeviceCode = function() {\r\n    this._pollingClient.cancelPollingRequest();\r\n};\r\n\r\nmodule.exports = TokenRequest;\r\n"]},"metadata":{},"sourceType":"script"}