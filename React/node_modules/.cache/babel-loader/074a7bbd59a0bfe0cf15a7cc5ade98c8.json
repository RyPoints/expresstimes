{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar request = require('request');\n\nvar url = require('url');\n\nvar DOMParser = require('xmldom').DOMParser;\n\nvar _ = require('underscore');\n\nvar Logger = require('./log').Logger;\n\nvar util = require('./util');\n\nvar xmlutil = require('./xmlutil');\n\nvar select = xmlutil.xpathSelect;\n\nvar Namespaces = require('./constants').XmlNamespaces;\n\nvar WSTrustVersion = require('./constants').WSTrustVersion;\n/**\r\n * Create a new Mex object.\r\n * @private\r\n * @constructor\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} url  The url of the mex endpoint.\r\n */\n\n\nfunction Mex(callContext, url) {\n  this._log = new Logger('MEX', callContext._logContext);\n  this._callContext = callContext;\n  this._url = url;\n  this._dom = null;\n  this._mexDoc = null;\n  this._usernamePasswordPolicy = {};\n\n  this._log.verbose('Mex created');\n\n  this._log.verbose('Mex created with url: ' + url, true);\n}\n/**\r\n* Returns the policy containing IDP url and wstrust version from which a username passwowrd can be exchanged for a token.\r\n* @instance\r\n* @memberOf Mex\r\n* @name usernamePasswordPolicy\r\n*/\n\n\nObject.defineProperty(Mex.prototype, 'usernamePasswordPolicy', {\n  get: function () {\n    return this._usernamePasswordPolicy;\n  }\n});\n/**\r\n* @callback DiscoverCallback\r\n* @memberOf Mex\r\n* @param {object} error\r\n*/\n\n/**\r\n* Performs Mex discovery.  This method will retrieve the mex document, parse it, and extract\r\n* the username password ws-trust endpoint.\r\n* @private\r\n* @param {Mex.DiscoverCallback}  callback  Called when discover is complete.\r\n*/\n\nMex.prototype.discover = function (callback) {\n  this._log.verbose('Retrieving mex');\n\n  this._log.verbose('Retrieving mex at: ' + this._url);\n\n  var self = this;\n  var options = util.createRequestOptions(self, {\n    headers: {\n      'Content-Type': 'application/soap+xml'\n    }\n  });\n  request.get(this._url, options, util.createRequestHandler('Mex Get', this._log, callback, function (response, body) {\n    try {\n      self._mexDoc = body;\n      var options = {\n        errorHandler: self._log.error\n      };\n      self._dom = new DOMParser(options).parseFromString(self._mexDoc);\n\n      self._parse(callback);\n\n      return;\n    } catch (err) {\n      self._log.error('Failed to parse mex response in to DOM', err, true);\n\n      callback(err);\n    }\n  }));\n};\n\nvar TRANSPORT_BINDING_XPATH = 'wsp:ExactlyOne/wsp:All/sp:TransportBinding';\nvar TRANSPORT_BINDING_2005_XPATH = 'wsp:ExactlyOne/wsp:All/sp2005:TransportBinding';\n/**\r\n* Checks a DOM policy node that is a potentialy appplicable username password policy\r\n* to ensure that it has the correct transport.\r\n* @private\r\n* @param {object} policyNode  The policy node to check.\r\n* @returns {string} If the policy matches the desired transport then the id of the policy is returned.\r\n*                   If not then null is returned.\r\n*/\n\nMex.prototype._checkPolicy = function (policyNode) {\n  var policyId = null;\n  var id = policyNode.getAttributeNS(Namespaces.wsu, 'Id');\n  var transportBindingNodes = select(policyNode, TRANSPORT_BINDING_XPATH);\n\n  if (0 === transportBindingNodes.length) {\n    transportBindingNodes = select(policyNode, TRANSPORT_BINDING_2005_XPATH);\n  }\n\n  if (0 !== transportBindingNodes.length) {\n    if (id) {\n      policyId = id;\n    }\n  }\n\n  if (policyId) {\n    this._log.verbose('found matching policy id');\n\n    this._log.verbose('found matching policy id: ' + policyId, true);\n  } else {\n    if (!id) {\n      id = '<no id>';\n    }\n\n    this._log.verbose('potential policy did not match required transport binding');\n\n    this._log.verbose('potential policy did not match required transport binding: ' + id, true);\n  }\n\n  return policyId;\n};\n/**\r\n* Finds all username password policies within the mex document.\r\n* @private\r\n* @param xpath The xpath expression for selecting username token nodes. \r\n* @returns {object} A map object that contains objects containing the id of username password polices.\r\n*/\n\n\nMex.prototype._selectUsernamePasswordPolicies = function (xpath) {\n  var policies = {};\n  var usernameTokenNodes = select(this._dom, xpath);\n\n  if (!usernameTokenNodes.length) {\n    this._log.warn('no username token policy nodes found');\n\n    return;\n  }\n\n  for (var i = 0; i < usernameTokenNodes.length; i++) {\n    var policyNode = usernameTokenNodes[i].parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode;\n\n    var id = this._checkPolicy(policyNode);\n\n    if (id) {\n      var idRef = '#' + id;\n      policies[idRef] = {\n        id: idRef\n      };\n    }\n  }\n\n  return _.isEmpty(policies) ? null : policies;\n};\n\nvar SOAP_ACTION_XPATH = 'wsdl:operation/soap12:operation/@soapAction';\nvar RST_SOAP_ACTION_13 = 'http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue';\nvar RST_SOAP_ACTION_2005 = 'http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue';\nvar SOAP_TRANSPORT_XPATH = 'soap12:binding/@transport';\nvar SOAP_HTTP_TRANSPORT_VALUE = 'http://schemas.xmlsoap.org/soap/http';\n/**\r\n* Given a DOM binding node determines whether it matches the correct soap action and transport.\r\n* @private\r\n* @param {object} bindingNode   The DOM node to check.\r\n* @returns {bool}\r\n*/\n\nMex.prototype._checkSoapActionAndTransport = function (bindingNode) {\n  var soapTransportAttributes;\n  var soapAction;\n  var soapTransport;\n  var bindingName = bindingNode.getAttribute('name');\n  var soapActionAttributes = select(bindingNode, SOAP_ACTION_XPATH);\n\n  if (soapActionAttributes.length) {\n    soapAction = soapActionAttributes[0].value;\n    soapTransportAttributes = select(bindingNode, SOAP_TRANSPORT_XPATH);\n  }\n\n  if (soapTransportAttributes.length) {\n    soapTransport = soapTransportAttributes[0].value;\n  }\n\n  if (soapTransport === SOAP_HTTP_TRANSPORT_VALUE) {\n    if (soapAction === RST_SOAP_ACTION_13) {\n      this._log.verbose('foud binding matching Action and Transport: ' + bindingName);\n\n      return WSTrustVersion.WSTRUST13;\n    } else if (soapAction === RST_SOAP_ACTION_2005) {\n      this._log.verbose('found binding matching Action and Transport: ' + bindingName);\n\n      return WSTrustVersion.WSTRUST2005;\n    }\n  }\n\n  this._log.verbose('binding node did not match soap Action or Transport: ' + bindingName);\n\n  return WSTrustVersion.UNDEFINED;\n};\n/**\r\n* Given a map with policy id keys, finds the bindings in the mex document that are linked to thos policies.\r\n* @private\r\n* @param {object}   policies  A map with policy id keys.\r\n* @returns {object} a map of bindings id's to policy id's.\r\n*/\n\n\nMex.prototype._getMatchingBindings = function (policies) {\n  var bindings = {};\n  var bindingPolicyRefNodes = select(this._dom, '//wsdl:definitions/wsdl:binding/wsp:PolicyReference');\n\n  for (var i = 0; i < bindingPolicyRefNodes.length; i++) {\n    var node = bindingPolicyRefNodes[i];\n    var uri = node.getAttribute('URI');\n    var policy = policies[uri];\n\n    if (policy) {\n      var bindingNode = node.parentNode;\n      var bindingName = bindingNode.getAttribute('name');\n\n      var version = this._checkSoapActionAndTransport(bindingNode);\n\n      if (version !== WSTrustVersion.UNDEFINED) {\n        var bindingPolicy = {};\n        bindingPolicy.url = uri;\n        bindingPolicy.version = version;\n        bindings[bindingName] = bindingPolicy;\n      }\n    }\n  }\n\n  return _.isEmpty(bindings) ? null : bindings;\n};\n/**\r\n* Ensures that a url points to an SSL endpoint.\r\n* @private\r\n* @param {string} endpointUrl   The url to check.\r\n* @returns {bool}\r\n*/\n\n\nMex.prototype._urlIsSecure = function (endpointUrl) {\n  var parsedUrl = url.parse(endpointUrl);\n  return parsedUrl.protocol === 'https:';\n};\n\nvar PORT_XPATH = '//wsdl:definitions/wsdl:service/wsdl:port';\nvar ADDRESS_XPATH = 'wsa10:EndpointReference/wsa10:Address';\n/**\r\n* Finds all of the wsdl ports in the mex document that are associated with username password policies.  Augments\r\n* the passed in bindings with the endpoint url of the correct port.\r\n* @private\r\n* @param {object} bindings  A map of binding id's to policy id's.\r\n*/\n\nMex.prototype._getPortsForPolicyBindings = function (bindings, policies) {\n  var portNodes = select(this._dom, PORT_XPATH);\n\n  if (0 === portNodes.length) {\n    this._log.warning('no ports found');\n  }\n\n  for (var i = 0; i < portNodes.length; i++) {\n    var portNode = portNodes[i];\n    var bindingId = portNode.getAttribute('binding'); // Clear any prefix\n\n    var bindingIdParts = bindingId.split(':');\n    bindingId = bindingIdParts[bindingIdParts.length - 1];\n    var trustPolicy = bindings[bindingId];\n\n    if (trustPolicy) {\n      var bindingPolicy = policies[trustPolicy.url];\n\n      if (bindingPolicy && !bindingPolicy.url) {\n        bindingPolicy.version = trustPolicy.version;\n        var addressNode = select(portNode, ADDRESS_XPATH);\n\n        if (0 === addressNode) {\n          throw this._log.createError('no address nodes on port.');\n        }\n\n        var address = xmlutil.findElementText(addressNode[0]);\n\n        if (this._urlIsSecure(address)) {\n          bindingPolicy.url = address;\n        } else {\n          this._log.warn('skipping insecure endpoint: ' + address);\n        }\n      }\n    }\n  }\n};\n/**\r\n* Given a list of username password policies chooses one of them at random as the policy chosen by this Mex instance.\r\n* @private\r\n* @param {object} policies  A map of policy id's to an object containing username password ws-trust endpoint addresses.\r\n*/\n\n\nMex.prototype._selectSingleMatchingPolicy = function (policies) {\n  // if both wstrust13 and wstrust2005 policy exists, then choose wstrust13, otherwise choose whatever exists.\n  var matchingPolicies = _.filter(policies, function (policy) {\n    return policy.url ? true : false;\n  });\n\n  if (!matchingPolicies) {\n    this._log.warn('no policies found with an url');\n\n    return;\n  }\n\n  var wstrust13Policy = null,\n      wstrust2005Policy = null;\n\n  for (var i = 0; i < matchingPolicies.length; ++i) {\n    var matchingPolicy = matchingPolicies[i];\n\n    if (WSTrustVersion.WSTRUST13 === matchingPolicy.version) {\n      wstrust13Policy = matchingPolicy;\n    } else if (WSTrustVersion.WSTRUST2005 === matchingPolicy.version) {\n      wstrust2005Policy = matchingPolicy;\n    }\n  }\n\n  if (!wstrust13Policy && !wstrust2005Policy) {\n    this._log.warn('no policies found with an url');\n\n    this._usernamePasswordPolicy = null;\n    return;\n  }\n\n  this._usernamePasswordPolicy = wstrust13Policy ? wstrust13Policy : wstrust2005Policy;\n};\n/**\r\n* Parses the mex document previously retrieved.\r\n* @private\r\n* @param {Mex.DiscoverCallback} callback\r\n*/\n\n\nMex.prototype._parse = function (callback) {\n  var self = this;\n  var xpathExpression = '//wsdl:definitions/wsp:Policy/wsp:ExactlyOne/wsp:All/sp:SignedEncryptedSupportingTokens/wsp:Policy/sp:UsernameToken/wsp:Policy/sp:WssUsernameToken10';\n\n  var policies = self._selectUsernamePasswordPolicies(xpathExpression);\n\n  xpathExpression = '//wsdl:definitions/wsp:Policy/wsp:ExactlyOne/wsp:All/sp2005:SignedSupportingTokens/wsp:Policy/sp2005:UsernameToken/wsp:Policy/sp2005:WssUsernameToken10';\n\n  if (policies) {\n    _.extend(policies, self._selectUsernamePasswordPolicies(xpathExpression));\n  } else {\n    policies = self._selectUsernamePasswordPolicies(xpathExpression);\n  }\n\n  if (!policies) {\n    callback(self._log.createError('No matching policies'));\n    return;\n  }\n\n  var bindings = self._getMatchingBindings(policies);\n\n  if (!bindings) {\n    callback(self._log.createError('No matching bindings'));\n    return;\n  }\n\n  self._getPortsForPolicyBindings(bindings, policies);\n\n  self._selectSingleMatchingPolicy(policies);\n\n  var err = this._url ? undefined : this._log.createError('No ws-trust endpoints match requirements.');\n  callback(err);\n};\n\nmodule.exports = Mex;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/adal-node/lib/mex.js"],"names":["request","require","url","DOMParser","_","Logger","util","xmlutil","select","xpathSelect","Namespaces","XmlNamespaces","WSTrustVersion","Mex","callContext","_log","_logContext","_callContext","_url","_dom","_mexDoc","_usernamePasswordPolicy","verbose","Object","defineProperty","prototype","get","discover","callback","self","options","createRequestOptions","headers","createRequestHandler","response","body","errorHandler","error","parseFromString","_parse","err","TRANSPORT_BINDING_XPATH","TRANSPORT_BINDING_2005_XPATH","_checkPolicy","policyNode","policyId","id","getAttributeNS","wsu","transportBindingNodes","length","_selectUsernamePasswordPolicies","xpath","policies","usernameTokenNodes","warn","i","parentNode","idRef","isEmpty","SOAP_ACTION_XPATH","RST_SOAP_ACTION_13","RST_SOAP_ACTION_2005","SOAP_TRANSPORT_XPATH","SOAP_HTTP_TRANSPORT_VALUE","_checkSoapActionAndTransport","bindingNode","soapTransportAttributes","soapAction","soapTransport","bindingName","getAttribute","soapActionAttributes","value","WSTRUST13","WSTRUST2005","UNDEFINED","_getMatchingBindings","bindings","bindingPolicyRefNodes","node","uri","policy","version","bindingPolicy","_urlIsSecure","endpointUrl","parsedUrl","parse","protocol","PORT_XPATH","ADDRESS_XPATH","_getPortsForPolicyBindings","portNodes","warning","portNode","bindingId","bindingIdParts","split","trustPolicy","addressNode","createError","address","findElementText","_selectSingleMatchingPolicy","matchingPolicies","filter","wstrust13Policy","wstrust2005Policy","matchingPolicy","xpathExpression","extend","undefined","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n'use strict';\r\nvar request = require('request');\r\nvar url = require('url');\r\nvar DOMParser = require('xmldom').DOMParser;\r\nvar _ = require('underscore');\r\nvar Logger = require('./log').Logger;\r\nvar util = require('./util');\r\n\r\nvar xmlutil = require('./xmlutil');\r\nvar select = xmlutil.xpathSelect;\r\n\r\nvar Namespaces = require('./constants').XmlNamespaces;\r\n\r\nvar WSTrustVersion = require('./constants').WSTrustVersion;\r\n\r\n/**\r\n * Create a new Mex object.\r\n * @private\r\n * @constructor\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} url  The url of the mex endpoint.\r\n */\r\nfunction Mex(callContext, url) {\r\n  this._log = new Logger('MEX', callContext._logContext);\r\n  this._callContext = callContext;\r\n  this._url = url;\r\n  this._dom = null;\r\n  this._mexDoc = null;\r\n  this._usernamePasswordPolicy = {};\r\n  this._log.verbose('Mex created');\r\n  this._log.verbose('Mex created with url: ' + url, true);\r\n}\r\n\r\n/**\r\n* Returns the policy containing IDP url and wstrust version from which a username passwowrd can be exchanged for a token.\r\n* @instance\r\n* @memberOf Mex\r\n* @name usernamePasswordPolicy\r\n*/\r\nObject.defineProperty(Mex.prototype, 'usernamePasswordPolicy', {\r\n  get: function() {\r\n    return this._usernamePasswordPolicy;\r\n  }\r\n});\r\n\r\n/**\r\n* @callback DiscoverCallback\r\n* @memberOf Mex\r\n* @param {object} error\r\n*/\r\n\r\n/**\r\n* Performs Mex discovery.  This method will retrieve the mex document, parse it, and extract\r\n* the username password ws-trust endpoint.\r\n* @private\r\n* @param {Mex.DiscoverCallback}  callback  Called when discover is complete.\r\n*/\r\nMex.prototype.discover = function (callback) {\r\n  this._log.verbose('Retrieving mex');\r\n  this._log.verbose('Retrieving mex at: ' + this._url);\r\n  var self = this;\r\n  var options = util.createRequestOptions(self, { headers : { 'Content-Type' : 'application/soap+xml'} });\r\n  request.get(this._url, options, util.createRequestHandler('Mex Get', this._log, callback,\r\n    function(response, body) {\r\n      try {\r\n        self._mexDoc = body;\r\n        var options = {\r\n          errorHandler : self._log.error\r\n        };\r\n        self._dom = new DOMParser(options).parseFromString(self._mexDoc);\r\n        self._parse(callback);\r\n        return;\r\n      } catch (err) {\r\n        self._log.error('Failed to parse mex response in to DOM', err, true);\r\n        callback(err);\r\n      }\r\n    })\r\n  );\r\n};\r\n\r\nvar TRANSPORT_BINDING_XPATH = 'wsp:ExactlyOne/wsp:All/sp:TransportBinding';\r\nvar TRANSPORT_BINDING_2005_XPATH = 'wsp:ExactlyOne/wsp:All/sp2005:TransportBinding';\r\n/**\r\n* Checks a DOM policy node that is a potentialy appplicable username password policy\r\n* to ensure that it has the correct transport.\r\n* @private\r\n* @param {object} policyNode  The policy node to check.\r\n* @returns {string} If the policy matches the desired transport then the id of the policy is returned.\r\n*                   If not then null is returned.\r\n*/\r\nMex.prototype._checkPolicy = function(policyNode) {\r\n  var policyId = null;\r\n  var id = policyNode.getAttributeNS(Namespaces.wsu, 'Id');\r\n  var transportBindingNodes = select(policyNode, TRANSPORT_BINDING_XPATH);\r\n  if (0 === transportBindingNodes.length) {\r\n    transportBindingNodes = select(policyNode, TRANSPORT_BINDING_2005_XPATH);\r\n  }\r\n  if (0 !== transportBindingNodes.length) {\r\n    if (id) {\r\n      policyId = id;\r\n    }\r\n  }\r\n  if (policyId) {\r\n    this._log.verbose('found matching policy id');\r\n    this._log.verbose('found matching policy id: ' + policyId, true);\r\n  } else {\r\n    if (!id) {\r\n      id = '<no id>';\r\n    }\r\n    this._log.verbose('potential policy did not match required transport binding');\r\n    this._log.verbose('potential policy did not match required transport binding: ' + id, true);\r\n  }\r\n  return policyId;\r\n};\r\n\r\n/**\r\n* Finds all username password policies within the mex document.\r\n* @private\r\n* @param xpath The xpath expression for selecting username token nodes. \r\n* @returns {object} A map object that contains objects containing the id of username password polices.\r\n*/\r\nMex.prototype._selectUsernamePasswordPolicies = function(xpath) {\r\n  var policies = {};\r\n  var usernameTokenNodes = select(this._dom, xpath);\r\n  if (!usernameTokenNodes.length) {\r\n    this._log.warn('no username token policy nodes found');\r\n    return;\r\n  }\r\n  for (var i=0; i < usernameTokenNodes.length; i++) {\r\n    var policyNode = usernameTokenNodes[i].parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode;\r\n    var id = this._checkPolicy(policyNode);\r\n    if (id) {\r\n      var idRef = '#' + id;\r\n      policies[idRef] = { id : idRef };\r\n    }\r\n  }\r\n  return _.isEmpty(policies) ? null : policies;\r\n};\r\n\r\nvar SOAP_ACTION_XPATH = 'wsdl:operation/soap12:operation/@soapAction';\r\nvar RST_SOAP_ACTION_13 = 'http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue';\r\nvar RST_SOAP_ACTION_2005 = 'http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue';\r\nvar SOAP_TRANSPORT_XPATH = 'soap12:binding/@transport';\r\nvar SOAP_HTTP_TRANSPORT_VALUE = 'http://schemas.xmlsoap.org/soap/http';\r\n/**\r\n* Given a DOM binding node determines whether it matches the correct soap action and transport.\r\n* @private\r\n* @param {object} bindingNode   The DOM node to check.\r\n* @returns {bool}\r\n*/\r\nMex.prototype._checkSoapActionAndTransport = function(bindingNode) {\r\n  var soapTransportAttributes;\r\n  var soapAction;\r\n  var soapTransport;\r\n  var bindingName = bindingNode.getAttribute('name');\r\n  var soapActionAttributes = select(bindingNode, SOAP_ACTION_XPATH);\r\n  if (soapActionAttributes.length) {\r\n    soapAction = soapActionAttributes[0].value;\r\n    soapTransportAttributes = select(bindingNode, SOAP_TRANSPORT_XPATH);\r\n  }\r\n  if (soapTransportAttributes.length) {\r\n    soapTransport = soapTransportAttributes[0].value;\r\n  }\r\n\r\n  if (soapTransport === SOAP_HTTP_TRANSPORT_VALUE) {\r\n    if (soapAction === RST_SOAP_ACTION_13) {\r\n      this._log.verbose('foud binding matching Action and Transport: ' + bindingName);\r\n      return WSTrustVersion.WSTRUST13;\r\n    }\r\n    else if (soapAction === RST_SOAP_ACTION_2005) {\r\n      this._log.verbose('found binding matching Action and Transport: ' + bindingName);\r\n      return WSTrustVersion.WSTRUST2005;\r\n    }\r\n  }\r\n\r\n  this._log.verbose('binding node did not match soap Action or Transport: ' + bindingName);\r\n  return WSTrustVersion.UNDEFINED;\r\n};\r\n\r\n/**\r\n* Given a map with policy id keys, finds the bindings in the mex document that are linked to thos policies.\r\n* @private\r\n* @param {object}   policies  A map with policy id keys.\r\n* @returns {object} a map of bindings id's to policy id's.\r\n*/\r\nMex.prototype._getMatchingBindings = function(policies) {\r\n  var bindings = {};\r\n  var bindingPolicyRefNodes = select(this._dom, '//wsdl:definitions/wsdl:binding/wsp:PolicyReference');\r\n  for (var i=0; i < bindingPolicyRefNodes.length; i++) {\r\n    var node = bindingPolicyRefNodes[i];\r\n    var uri = node.getAttribute('URI');\r\n    var policy = policies[uri];\r\n    if (policy) {\r\n      var bindingNode = node.parentNode;\r\n      var bindingName = bindingNode.getAttribute('name');\r\n      var version = this._checkSoapActionAndTransport(bindingNode);\r\n      if (version !== WSTrustVersion.UNDEFINED) {\r\n         var bindingPolicy = {};\r\n         bindingPolicy.url = uri;\r\n         bindingPolicy.version = version;\r\n\r\n         bindings[bindingName] = bindingPolicy;\r\n      }\r\n    }\r\n  }\r\n  return _.isEmpty(bindings) ? null : bindings;\r\n};\r\n\r\n/**\r\n* Ensures that a url points to an SSL endpoint.\r\n* @private\r\n* @param {string} endpointUrl   The url to check.\r\n* @returns {bool}\r\n*/\r\nMex.prototype._urlIsSecure = function(endpointUrl) {\r\n  var parsedUrl = url.parse(endpointUrl);\r\n  return parsedUrl.protocol === 'https:';\r\n};\r\n\r\nvar PORT_XPATH = '//wsdl:definitions/wsdl:service/wsdl:port';\r\nvar ADDRESS_XPATH = 'wsa10:EndpointReference/wsa10:Address';\r\n/**\r\n* Finds all of the wsdl ports in the mex document that are associated with username password policies.  Augments\r\n* the passed in bindings with the endpoint url of the correct port.\r\n* @private\r\n* @param {object} bindings  A map of binding id's to policy id's.\r\n*/\r\nMex.prototype._getPortsForPolicyBindings = function(bindings, policies) {\r\n  var portNodes = select(this._dom, PORT_XPATH);\r\n  if (0 === portNodes.length) {\r\n    this._log.warning('no ports found');\r\n  }\r\n  for (var i=0; i < portNodes.length; i++) {\r\n    var portNode = portNodes[i];\r\n    var bindingId = portNode.getAttribute('binding');\r\n\r\n    // Clear any prefix\r\n    var bindingIdParts = bindingId.split(':');\r\n    bindingId = bindingIdParts[bindingIdParts.length - 1];\r\n\r\n    var trustPolicy = bindings[bindingId];\r\n    if (trustPolicy) {\r\n      var bindingPolicy = policies[trustPolicy.url];\r\n\r\n      if (bindingPolicy && !bindingPolicy.url) {\r\n        bindingPolicy.version = trustPolicy.version;\r\n        var addressNode = select(portNode, ADDRESS_XPATH);\r\n        if (0 === addressNode) {\r\n          throw this._log.createError('no address nodes on port.');\r\n        }\r\n        var address = xmlutil.findElementText(addressNode[0]);\r\n        if (this._urlIsSecure(address)) {\r\n          bindingPolicy.url = address;\r\n        } else {\r\n          this._log.warn('skipping insecure endpoint: ' + address);\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n* Given a list of username password policies chooses one of them at random as the policy chosen by this Mex instance.\r\n* @private\r\n* @param {object} policies  A map of policy id's to an object containing username password ws-trust endpoint addresses.\r\n*/\r\nMex.prototype._selectSingleMatchingPolicy = function(policies) {\r\n  // if both wstrust13 and wstrust2005 policy exists, then choose wstrust13, otherwise choose whatever exists.\r\n  var matchingPolicies = _.filter(policies, function(policy) { return policy.url ? true : false; });\r\n  if (!matchingPolicies) {\r\n    this._log.warn('no policies found with an url');\r\n    return;\r\n  }\r\n\r\n  var wstrust13Policy = null, wstrust2005Policy = null;\r\n  for(var i = 0; i < matchingPolicies.length; ++i) {\r\n    var matchingPolicy = matchingPolicies[i];\r\n    if (WSTrustVersion.WSTRUST13 === matchingPolicy.version) {\r\n      wstrust13Policy = matchingPolicy;\r\n    }\r\n    else if (WSTrustVersion.WSTRUST2005 === matchingPolicy.version) {\r\n      wstrust2005Policy = matchingPolicy;\r\n    }\r\n  }\r\n\r\n  if (!wstrust13Policy && !wstrust2005Policy) {\r\n    this._log.warn('no policies found with an url');\r\n    this._usernamePasswordPolicy = null;\r\n    return;\r\n  }\r\n\r\n  this._usernamePasswordPolicy = wstrust13Policy ? wstrust13Policy : wstrust2005Policy;\r\n};\r\n\r\n/**\r\n* Parses the mex document previously retrieved.\r\n* @private\r\n* @param {Mex.DiscoverCallback} callback\r\n*/\r\nMex.prototype._parse = function(callback) {\r\n  var self = this;\r\n  var xpathExpression = '//wsdl:definitions/wsp:Policy/wsp:ExactlyOne/wsp:All/sp:SignedEncryptedSupportingTokens/wsp:Policy/sp:UsernameToken/wsp:Policy/sp:WssUsernameToken10'; \r\n  var policies = self._selectUsernamePasswordPolicies(xpathExpression);\r\n\r\n  xpathExpression = '//wsdl:definitions/wsp:Policy/wsp:ExactlyOne/wsp:All/sp2005:SignedSupportingTokens/wsp:Policy/sp2005:UsernameToken/wsp:Policy/sp2005:WssUsernameToken10';\r\n\r\n  if (policies) {\r\n    _.extend(policies, self._selectUsernamePasswordPolicies(xpathExpression));\r\n  }\r\n  else {\r\n    policies = self._selectUsernamePasswordPolicies(xpathExpression);\r\n  }\r\n\r\n  if (!policies) {\r\n    callback(self._log.createError('No matching policies'));\r\n    return;\r\n  }\r\n  var bindings = self._getMatchingBindings(policies);\r\n  if (!bindings) {\r\n    callback(self._log.createError('No matching bindings'));\r\n    return;\r\n  }\r\n  self._getPortsForPolicyBindings(bindings, policies);\r\n  self._selectSingleMatchingPolicy(policies);\r\n  var err = this._url ? undefined : this._log.createError('No ws-trust endpoints match requirements.');\r\n  callback(err);\r\n};\r\n\r\nmodule.exports = Mex;"]},"metadata":{},"sourceType":"script"}