{"ast":null,"code":"var zip = require('lodash/zip');\n\nvar trimEnd = require('lodash/trimEnd'); // Split a long word up to fit within the word wrap limit.  Use either a\n// character to split looking back from the word wrap limit, or\n// truncate to the word wrap limit.\n\n\nfunction splitLongWord(word, options) {\n  var wrapCharacters = options.longWordSplit.wrapCharacters || [];\n  var forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\n  var max = options.wordwrap;\n  var fuseWord = [];\n  var idx = 0;\n\n  while (word.length > max) {\n    var firstLine = word.substr(0, max);\n    var remainingChars = word.substr(max);\n    var splitIndex = firstLine.lastIndexOf(wrapCharacters[idx]);\n\n    if (splitIndex > -1) {\n      // We've found a character to split on, store before the split then check if we\n      // need to split again\n      word = firstLine.substr(splitIndex + 1) + remainingChars;\n      fuseWord.push(firstLine.substr(0, splitIndex + 1));\n    } else {\n      idx++;\n\n      if (idx >= wrapCharacters.length) {\n        // Cannot split on character, so either split at 'max' or preserve length\n        if (forceWrapOnLimit) {\n          fuseWord.push(firstLine);\n          word = remainingChars;\n\n          if (word.length > max) {\n            continue;\n          }\n        } else {\n          word = firstLine + remainingChars;\n\n          if (!options.preserveNewlines) {\n            word += '\\n';\n          }\n        }\n\n        break;\n      } else {\n        word = firstLine + remainingChars;\n      }\n    }\n  }\n\n  fuseWord.push(word);\n  return fuseWord.join('\\n');\n}\n\nexports.wordwrap = function wordwrap(text, options) {\n  var max = options.wordwrap;\n  var preserveNewlines = options.preserveNewlines;\n  var length = options.lineCharCount; // Preserve leading space\n\n  var result = text.startsWith(' ') ? ' ' : '';\n  length += result.length;\n  var buffer = []; // Split the text into words, decide to preserve new lines or not.\n\n  var words = preserveNewlines ? text.trim().replace(/\\n/g, '\\n ').split(/\\ +/) : text.trim().split(/\\s+/); // Determine where to end line word by word.\n\n  words.forEach(function (word) {\n    // Add buffer to result if we can't fit any more words in the buffer.\n    if ((max || max === 0) && length > 0 && (length + word.length > max || length + word.indexOf('\\n') > max)) {\n      // Concat buffer and add it to the result\n      result += buffer.join(' ') + '\\n'; // Reset buffer and length\n\n      buffer.length = length = 0;\n    } // Check if the current word is long enough to be wrapped\n\n\n    if ((max || max === 0) && options.longWordSplit && word.length > max) {\n      word = splitLongWord(word, options);\n    }\n\n    buffer.push(word); // If the word contains a newline then restart the count and add the buffer to the result\n\n    if (word.indexOf('\\n') !== -1) {\n      result += buffer.join(' '); // Reset the buffer, let the length include any characters after the last newline\n\n      buffer.length = 0;\n      length = word.length - (word.lastIndexOf('\\n') + 1); // If there are characters after the newline, add a space and increase the length by 1\n\n      if (length) {\n        result += ' ';\n        length++;\n      }\n    } else {\n      // Add word length + one whitespace\n      length += word.length + 1;\n    }\n  }); // Add the rest to the result.\n\n  result += buffer.join(' '); // Preserve trailing space\n\n  if (!text.endsWith(' ')) {\n    result = trimEnd(result);\n  } else if (!result.endsWith(' ')) {\n    result = result + ' ';\n  }\n\n  return result;\n};\n\nexports.arrayZip = function arrayZip(array) {\n  return zip.apply(null, array);\n};\n\nexports.splitCssSearchTag = function splitCssSearchTag(tagString) {\n  function getParams(re, string) {\n    var captures = [],\n        found;\n\n    while ((found = re.exec(string)) !== null) {\n      captures.push(found[1]);\n    }\n\n    return captures;\n  }\n\n  var splitTag = {};\n  var elementRe = /(^\\w*)/g;\n  splitTag.element = elementRe.exec(tagString)[1];\n  splitTag.classes = getParams(/\\.([\\d\\w-]*)/g, tagString);\n  splitTag.ids = getParams(/#([\\d\\w-]*)/g, tagString);\n  return splitTag;\n};\n\nexports.replaceAll = function replaceAll(str, find, replace) {\n  var reg = new RegExp(find, 'g');\n  return str.replace(reg, replace);\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/html-to-text/lib/helper.js"],"names":["zip","require","trimEnd","splitLongWord","word","options","wrapCharacters","longWordSplit","forceWrapOnLimit","max","wordwrap","fuseWord","idx","length","firstLine","substr","remainingChars","splitIndex","lastIndexOf","push","preserveNewlines","join","exports","text","lineCharCount","result","startsWith","buffer","words","trim","replace","split","forEach","indexOf","endsWith","arrayZip","array","apply","splitCssSearchTag","tagString","getParams","re","string","captures","found","exec","splitTag","elementRe","element","classes","ids","replaceAll","str","find","reg","RegExp"],"mappings":"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","sourcesContent":["var zip = require('lodash/zip');\nvar trimEnd = require('lodash/trimEnd');\n\n// Split a long word up to fit within the word wrap limit.  Use either a\n// character to split looking back from the word wrap limit, or\n// truncate to the word wrap limit.\nfunction splitLongWord(word, options) {\n  var wrapCharacters = options.longWordSplit.wrapCharacters || [];\n  var forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\n  var max = options.wordwrap;\n\n  var fuseWord = [];\n  var idx = 0;\n  while (word.length > max) {\n    var firstLine = word.substr(0, max);\n    var remainingChars = word.substr(max);\n\n    var splitIndex = firstLine.lastIndexOf(wrapCharacters[idx]);\n\n    if (splitIndex > -1) {\n      // We've found a character to split on, store before the split then check if we\n      // need to split again\n      word = firstLine.substr(splitIndex + 1) + remainingChars;\n      fuseWord.push(firstLine.substr(0, splitIndex + 1));\n    } else {\n      idx++;\n      if (idx >= wrapCharacters.length) {\n        // Cannot split on character, so either split at 'max' or preserve length\n        if (forceWrapOnLimit) {\n          fuseWord.push(firstLine);\n          word = remainingChars;\n          if (word.length > max) {\n            continue;\n          }\n        } else {\n          word = firstLine + remainingChars;\n          if (!options.preserveNewlines) {\n            word += '\\n';\n          }\n        }\n        break;\n      } else {\n        word = firstLine + remainingChars;\n      }\n    }\n  }\n  fuseWord.push(word);\n\n  return fuseWord.join('\\n');\n}\n\nexports.wordwrap = function wordwrap(text, options) {\n  var max = options.wordwrap;\n  var preserveNewlines = options.preserveNewlines;\n  var length = options.lineCharCount;\n\n  // Preserve leading space\n  var result = text.startsWith(' ') ? ' ' : '';\n  length += result.length;\n  var buffer = [];\n  // Split the text into words, decide to preserve new lines or not.\n  var words = preserveNewlines\n    ? text.trim().replace(/\\n/g, '\\n ').split(/\\ +/)\n    : text.trim().split(/\\s+/);\n\n  // Determine where to end line word by word.\n  words.forEach(function(word) {\n    // Add buffer to result if we can't fit any more words in the buffer.\n    if ((max || max === 0) && length > 0 && ((length + word.length > max) || (length + word.indexOf('\\n') > max))) {\n      // Concat buffer and add it to the result\n      result += buffer.join(' ') + '\\n';\n      // Reset buffer and length\n      buffer.length = length = 0;\n    }\n\n    // Check if the current word is long enough to be wrapped\n    if ((max || max === 0) && (options.longWordSplit) && (word.length > max)) {\n      word = splitLongWord(word, options);\n    }\n\n    buffer.push(word);\n\n    // If the word contains a newline then restart the count and add the buffer to the result\n    if (word.indexOf('\\n') !== -1) {\n      result += buffer.join(' ');\n\n      // Reset the buffer, let the length include any characters after the last newline\n      buffer.length = 0;\n      length = word.length - (word.lastIndexOf('\\n') + 1);\n      // If there are characters after the newline, add a space and increase the length by 1\n      if (length) {\n        result += ' ';\n        length++;\n      }\n    } else {\n      // Add word length + one whitespace\n      length += word.length + 1;\n    }\n  });\n  // Add the rest to the result.\n  result += buffer.join(' ');\n\n  // Preserve trailing space\n  if (!text.endsWith(' ')) {\n    result = trimEnd(result);\n  } else if (!result.endsWith(' ')) {\n    result = result + ' ';\n  }\n\n  return result;\n};\n\nexports.arrayZip = function arrayZip(array) {\n  return zip.apply(null, array);\n};\n\nexports.splitCssSearchTag = function splitCssSearchTag(tagString) {\n  function getParams(re, string) {\n    var captures = [], found;\n    while ((found = re.exec(string)) !== null) {\n      captures.push(found[1]);\n    }\n    return captures;\n  }\n\n  var splitTag = {};\n  var elementRe = /(^\\w*)/g;\n  splitTag.element = elementRe.exec(tagString)[1];\n  splitTag.classes = getParams( /\\.([\\d\\w-]*)/g, tagString);\n  splitTag.ids = getParams( /#([\\d\\w-]*)/g, tagString);\n\n  return splitTag;\n};\n\nexports.replaceAll = function replaceAll(str, find, replace) {\n  var reg = new RegExp(find, 'g');\n\n  return str.replace(reg, replace);\n};\n"]},"metadata":{},"sourceType":"script"}