{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar select = require('xpath.js');\n\nvar XMLSerializer = require('xmldom').XMLSerializer;\n\nvar constants = require('./constants');\n/**\r\n * @namespace XmlUtil\r\n * @private\r\n */\n\n\nvar XPATH_PATH_TEMPLATE = '*[local-name() = \\'LOCAL_NAME\\' and namespace-uri() = \\'NAMESPACE\\']';\n/**\r\n* The xpath implementation being used does not have a way of matching expanded namespace.\r\n* This method takes an xpath query and expands all of the namespaces involved.  It then\r\n* re-writes the query in to a longer form that directory matches the correct namespaces.\r\n* @private\r\n* @static\r\n* @memberOf XmlUtil\r\n* @param {string} xpath   The expath query string to expand.\r\n* @returns {string} An expanded xpath query.\r\n*/\n\nfunction expandQNames(xpath) {\n  var namespaces = constants.XmlNamespaces;\n  var pathParts = xpath.split('/');\n\n  for (var i = 0; i < pathParts.length; i++) {\n    if (pathParts[i].indexOf(':') !== -1) {\n      var QNameParts = pathParts[i].split(':');\n\n      if (QNameParts.length !== 2) {\n        throw new Error('Unable to parse XPath string : ' + xpath + ' : with QName : ' + pathParts[i]);\n      }\n\n      var expandedPath = XPATH_PATH_TEMPLATE.replace('LOCAL_NAME', QNameParts[1]);\n      expandedPath = expandedPath.replace('NAMESPACE', namespaces[QNameParts[0]]);\n      pathParts[i] = expandedPath;\n    }\n  }\n\n  return pathParts.join('/');\n}\n\nvar exports = {\n  /**\r\n   * Performs an xpath select that does appropriate namespace matching since the imported\r\n   * xpath module does not properly handle namespaces.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} dom     A dom object created by the xmldom module\r\n   * @param  {string} xpath   An xpath expression\r\n   * @return {array}          An array of matching dom nodes.\r\n   */\n  xpathSelect: function (dom, xpath) {\n    return select(dom, expandQNames(xpath));\n  },\n\n  /**\r\n   * Given a dom node serializes all immediate children that are xml elements.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} node  An xml dom node.\r\n   * @return {string}       Serialized xml.\r\n   */\n  serializeNodeChildren: function (node) {\n    var doc = '';\n    var sibling = node.firstChild;\n    var serializer = new XMLSerializer();\n\n    while (sibling) {\n      if (this.isElementNode(sibling)) {\n        doc += serializer.serializeToString(sibling);\n      }\n\n      sibling = sibling.nextSibling;\n    }\n\n    return doc !== '' ? doc : null;\n  },\n\n  /**\r\n   * Detects whether the passed in dom node represents an xml element.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object}  node   An xml dom node.\r\n   * @return {Boolean}        true if the node represents an element.\r\n   */\n  isElementNode: function (node) {\n    return _.has(node, 'tagName');\n  },\n\n  /**\r\n   * Given an xmldom node this function returns any text data contained within.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} node  An xmldom node from which the data should be extracted.\r\n   * @return {string}       Any data found within the element or null if none is found.\r\n   */\n  findElementText: function (node) {\n    var sibling = node.firstChild;\n\n    while (sibling && !sibling.data) {\n      sibling = sibling.nextSibling;\n    }\n\n    return sibling.data ? sibling.data : null;\n  }\n};\nmodule.exports = exports;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/adal-node/lib/xmlutil.js"],"names":["_","require","select","XMLSerializer","constants","XPATH_PATH_TEMPLATE","expandQNames","xpath","namespaces","XmlNamespaces","pathParts","split","i","length","indexOf","QNameParts","Error","expandedPath","replace","join","exports","xpathSelect","dom","serializeNodeChildren","node","doc","sibling","firstChild","serializer","isElementNode","serializeToString","nextSibling","has","findElementText","data","module"],"mappings":"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","sourcesContent":["/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n'use strict';\r\n\r\nvar _ = require('underscore');\r\nvar select = require('xpath.js');\r\nvar XMLSerializer = require('xmldom').XMLSerializer;\r\n\r\nvar constants = require('./constants');\r\n\r\n/**\r\n * @namespace XmlUtil\r\n * @private\r\n */\r\n\r\nvar XPATH_PATH_TEMPLATE = '*[local-name() = \\'LOCAL_NAME\\' and namespace-uri() = \\'NAMESPACE\\']';\r\n/**\r\n* The xpath implementation being used does not have a way of matching expanded namespace.\r\n* This method takes an xpath query and expands all of the namespaces involved.  It then\r\n* re-writes the query in to a longer form that directory matches the correct namespaces.\r\n* @private\r\n* @static\r\n* @memberOf XmlUtil\r\n* @param {string} xpath   The expath query string to expand.\r\n* @returns {string} An expanded xpath query.\r\n*/\r\nfunction expandQNames(xpath) {\r\n  var namespaces = constants.XmlNamespaces;\r\n  var pathParts = xpath.split('/');\r\n  for (var i=0; i < pathParts.length; i++) {\r\n    if (pathParts[i].indexOf(':') !== -1) {\r\n      var QNameParts = pathParts[i].split(':');\r\n      if (QNameParts.length !== 2) {\r\n        throw new Error('Unable to parse XPath string : ' + xpath + ' : with QName : ' + pathParts[i]);\r\n      }\r\n      var expandedPath = XPATH_PATH_TEMPLATE.replace('LOCAL_NAME', QNameParts[1]);\r\n      expandedPath = expandedPath.replace('NAMESPACE', namespaces[QNameParts[0]]);\r\n      pathParts[i] = expandedPath;\r\n    }\r\n  }\r\n  return pathParts.join('/');\r\n}\r\n\r\nvar exports = {\r\n\r\n  /**\r\n   * Performs an xpath select that does appropriate namespace matching since the imported\r\n   * xpath module does not properly handle namespaces.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} dom     A dom object created by the xmldom module\r\n   * @param  {string} xpath   An xpath expression\r\n   * @return {array}          An array of matching dom nodes.\r\n   */\r\n  xpathSelect :  function (dom, xpath) {\r\n    return select(dom, expandQNames(xpath));\r\n  },\r\n\r\n  /**\r\n   * Given a dom node serializes all immediate children that are xml elements.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} node  An xml dom node.\r\n   * @return {string}       Serialized xml.\r\n   */\r\n  serializeNodeChildren : function(node) {\r\n    var doc = '';\r\n    var sibling = node.firstChild;\r\n    var serializer = new XMLSerializer();\r\n\r\n    while (sibling) {\r\n      if (this.isElementNode(sibling)) {\r\n        doc += serializer.serializeToString(sibling);\r\n      }\r\n      sibling = sibling.nextSibling;\r\n    }\r\n\r\n    return doc !== '' ? doc : null;\r\n  },\r\n\r\n  /**\r\n   * Detects whether the passed in dom node represents an xml element.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object}  node   An xml dom node.\r\n   * @return {Boolean}        true if the node represents an element.\r\n   */\r\n  isElementNode : function(node) {\r\n    return _.has(node, 'tagName');\r\n  },\r\n\r\n  /**\r\n   * Given an xmldom node this function returns any text data contained within.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} node  An xmldom node from which the data should be extracted.\r\n   * @return {string}       Any data found within the element or null if none is found.\r\n   */\r\n  findElementText : function(node) {\r\n    var sibling = node.firstChild;\r\n    while (sibling && !sibling.data) {\r\n      sibling = sibling.nextSibling;\r\n    }\r\n\r\n    return sibling.data ? sibling.data : null;\r\n  }\r\n};\r\n\r\nmodule.exports = exports;"]},"metadata":{},"sourceType":"script"}