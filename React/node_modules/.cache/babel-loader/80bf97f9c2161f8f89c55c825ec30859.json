{"ast":null,"code":"module.exports = Geometry;\n\nvar Types = require('./types');\n\nvar Point = require('./point');\n\nvar LineString = require('./linestring');\n\nvar Polygon = require('./polygon');\n\nvar MultiPoint = require('./multipoint');\n\nvar MultiLineString = require('./multilinestring');\n\nvar MultiPolygon = require('./multipolygon');\n\nvar GeometryCollection = require('./geometrycollection');\n\nvar BinaryReader = require('./binaryreader');\n\nvar BinaryWriter = require('./binarywriter');\n\nvar WktParser = require('./wktparser');\n\nvar ZigZag = require('./zigzag.js');\n\nfunction Geometry() {\n  this.srid = undefined;\n  this.hasZ = false;\n  this.hasM = false;\n}\n\nGeometry.parse = function (value, options) {\n  var valueType = typeof value;\n  if (valueType === 'string' || value instanceof WktParser) return Geometry._parseWkt(value);else if (Buffer.isBuffer(value) || value instanceof BinaryReader) return Geometry._parseWkb(value, options);else throw new Error('first argument must be a string or Buffer');\n};\n\nGeometry._parseWkt = function (value) {\n  var wktParser, srid;\n  if (value instanceof WktParser) wktParser = value;else wktParser = new WktParser(value);\n  var match = wktParser.matchRegex([/^SRID=(\\d+);/]);\n  if (match) srid = parseInt(match[1], 10);\n  var geometryType = wktParser.matchType();\n  var dimension = wktParser.matchDimension();\n  var options = {\n    srid: srid,\n    hasZ: dimension.hasZ,\n    hasM: dimension.hasM\n  };\n\n  switch (geometryType) {\n    case Types.wkt.Point:\n      return Point._parseWkt(wktParser, options);\n\n    case Types.wkt.LineString:\n      return LineString._parseWkt(wktParser, options);\n\n    case Types.wkt.Polygon:\n      return Polygon._parseWkt(wktParser, options);\n\n    case Types.wkt.MultiPoint:\n      return MultiPoint._parseWkt(wktParser, options);\n\n    case Types.wkt.MultiLineString:\n      return MultiLineString._parseWkt(wktParser, options);\n\n    case Types.wkt.MultiPolygon:\n      return MultiPolygon._parseWkt(wktParser, options);\n\n    case Types.wkt.GeometryCollection:\n      return GeometryCollection._parseWkt(wktParser, options);\n  }\n};\n\nGeometry._parseWkb = function (value, parentOptions) {\n  var binaryReader,\n      wkbType,\n      geometryType,\n      options = {};\n  if (value instanceof BinaryReader) binaryReader = value;else binaryReader = new BinaryReader(value);\n  binaryReader.isBigEndian = !binaryReader.readInt8();\n  wkbType = binaryReader.readUInt32();\n  options.hasSrid = (wkbType & 0x20000000) === 0x20000000;\n  options.isEwkb = wkbType & 0x20000000 || wkbType & 0x40000000 || wkbType & 0x80000000;\n  if (options.hasSrid) options.srid = binaryReader.readUInt32();\n  options.hasZ = false;\n  options.hasM = false;\n\n  if (!options.isEwkb && (!parentOptions || !parentOptions.isEwkb)) {\n    if (wkbType >= 1000 && wkbType < 2000) {\n      options.hasZ = true;\n      geometryType = wkbType - 1000;\n    } else if (wkbType >= 2000 && wkbType < 3000) {\n      options.hasM = true;\n      geometryType = wkbType - 2000;\n    } else if (wkbType >= 3000 && wkbType < 4000) {\n      options.hasZ = true;\n      options.hasM = true;\n      geometryType = wkbType - 3000;\n    } else {\n      geometryType = wkbType;\n    }\n  } else {\n    if (wkbType & 0x80000000) options.hasZ = true;\n    if (wkbType & 0x40000000) options.hasM = true;\n    geometryType = wkbType & 0xF;\n  }\n\n  switch (geometryType) {\n    case Types.wkb.Point:\n      return Point._parseWkb(binaryReader, options);\n\n    case Types.wkb.LineString:\n      return LineString._parseWkb(binaryReader, options);\n\n    case Types.wkb.Polygon:\n      return Polygon._parseWkb(binaryReader, options);\n\n    case Types.wkb.MultiPoint:\n      return MultiPoint._parseWkb(binaryReader, options);\n\n    case Types.wkb.MultiLineString:\n      return MultiLineString._parseWkb(binaryReader, options);\n\n    case Types.wkb.MultiPolygon:\n      return MultiPolygon._parseWkb(binaryReader, options);\n\n    case Types.wkb.GeometryCollection:\n      return GeometryCollection._parseWkb(binaryReader, options);\n\n    default:\n      throw new Error('GeometryType ' + geometryType + ' not supported');\n  }\n};\n\nGeometry.parseTwkb = function (value) {\n  var binaryReader,\n      options = {};\n  if (value instanceof BinaryReader) binaryReader = value;else binaryReader = new BinaryReader(value);\n  var type = binaryReader.readUInt8();\n  var metadataHeader = binaryReader.readUInt8();\n  var geometryType = type & 0x0F;\n  options.precision = ZigZag.decode(type >> 4);\n  options.precisionFactor = Math.pow(10, options.precision);\n  options.hasBoundingBox = metadataHeader >> 0 & 1;\n  options.hasSizeAttribute = metadataHeader >> 1 & 1;\n  options.hasIdList = metadataHeader >> 2 & 1;\n  options.hasExtendedPrecision = metadataHeader >> 3 & 1;\n  options.isEmpty = metadataHeader >> 4 & 1;\n\n  if (options.hasExtendedPrecision) {\n    var extendedPrecision = binaryReader.readUInt8();\n    options.hasZ = (extendedPrecision & 0x01) === 0x01;\n    options.hasM = (extendedPrecision & 0x02) === 0x02;\n    options.zPrecision = ZigZag.decode((extendedPrecision & 0x1C) >> 2);\n    options.zPrecisionFactor = Math.pow(10, options.zPrecision);\n    options.mPrecision = ZigZag.decode((extendedPrecision & 0xE0) >> 5);\n    options.mPrecisionFactor = Math.pow(10, options.mPrecision);\n  } else {\n    options.hasZ = false;\n    options.hasM = false;\n  }\n\n  if (options.hasSizeAttribute) binaryReader.readVarInt();\n\n  if (options.hasBoundingBox) {\n    var dimensions = 2;\n    if (options.hasZ) dimensions++;\n    if (options.hasM) dimensions++;\n\n    for (var i = 0; i < dimensions; i++) {\n      binaryReader.readVarInt();\n      binaryReader.readVarInt();\n    }\n  }\n\n  switch (geometryType) {\n    case Types.wkb.Point:\n      return Point._parseTwkb(binaryReader, options);\n\n    case Types.wkb.LineString:\n      return LineString._parseTwkb(binaryReader, options);\n\n    case Types.wkb.Polygon:\n      return Polygon._parseTwkb(binaryReader, options);\n\n    case Types.wkb.MultiPoint:\n      return MultiPoint._parseTwkb(binaryReader, options);\n\n    case Types.wkb.MultiLineString:\n      return MultiLineString._parseTwkb(binaryReader, options);\n\n    case Types.wkb.MultiPolygon:\n      return MultiPolygon._parseTwkb(binaryReader, options);\n\n    case Types.wkb.GeometryCollection:\n      return GeometryCollection._parseTwkb(binaryReader, options);\n\n    default:\n      throw new Error('GeometryType ' + geometryType + ' not supported');\n  }\n};\n\nGeometry.parseGeoJSON = function (value) {\n  return Geometry._parseGeoJSON(value);\n};\n\nGeometry._parseGeoJSON = function (value, isSubGeometry) {\n  var geometry;\n\n  switch (value.type) {\n    case Types.geoJSON.Point:\n      geometry = Point._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.LineString:\n      geometry = LineString._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.Polygon:\n      geometry = Polygon._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.MultiPoint:\n      geometry = MultiPoint._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.MultiLineString:\n      geometry = MultiLineString._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.MultiPolygon:\n      geometry = MultiPolygon._parseGeoJSON(value);\n      break;\n\n    case Types.geoJSON.GeometryCollection:\n      geometry = GeometryCollection._parseGeoJSON(value);\n      break;\n\n    default:\n      throw new Error('GeometryType ' + value.type + ' not supported');\n  }\n\n  if (value.crs && value.crs.type && value.crs.type === 'name' && value.crs.properties && value.crs.properties.name) {\n    var crs = value.crs.properties.name;\n    if (crs.indexOf('EPSG:') === 0) geometry.srid = parseInt(crs.substring(5));else if (crs.indexOf('urn:ogc:def:crs:EPSG::') === 0) geometry.srid = parseInt(crs.substring(22));else throw new Error('Unsupported crs: ' + crs);\n  } else if (!isSubGeometry) {\n    geometry.srid = 4326;\n  }\n\n  return geometry;\n};\n\nGeometry.prototype.toEwkt = function () {\n  return 'SRID=' + this.srid + ';' + this.toWkt();\n};\n\nGeometry.prototype.toEwkb = function () {\n  var ewkb = new BinaryWriter(this._getWkbSize() + 4);\n  var wkb = this.toWkb();\n  ewkb.writeInt8(1);\n  ewkb.writeUInt32LE((wkb.slice(1, 5).readUInt32LE(0) | 0x20000000) >>> 0, true);\n  ewkb.writeUInt32LE(this.srid);\n  ewkb.writeBuffer(wkb.slice(5));\n  return ewkb.buffer;\n};\n\nGeometry.prototype._getWktType = function (wktType, isEmpty) {\n  var wkt = wktType;\n  if (this.hasZ && this.hasM) wkt += ' ZM ';else if (this.hasZ) wkt += ' Z ';else if (this.hasM) wkt += ' M ';\n  if (isEmpty && !this.hasZ && !this.hasM) wkt += ' ';\n  if (isEmpty) wkt += 'EMPTY';\n  return wkt;\n};\n\nGeometry.prototype._getWktCoordinate = function (point) {\n  var coordinates = point.x + ' ' + point.y;\n  if (this.hasZ) coordinates += ' ' + point.z;\n  if (this.hasM) coordinates += ' ' + point.m;\n  return coordinates;\n};\n\nGeometry.prototype._writeWkbType = function (wkb, geometryType, parentOptions) {\n  var dimensionType = 0;\n\n  if (typeof this.srid === 'undefined' && (!parentOptions || typeof parentOptions.srid === 'undefined')) {\n    if (this.hasZ && this.hasM) dimensionType += 3000;else if (this.hasZ) dimensionType += 1000;else if (this.hasM) dimensionType += 2000;\n  } else {\n    if (this.hasZ) dimensionType |= 0x80000000;\n    if (this.hasM) dimensionType |= 0x40000000;\n  }\n\n  wkb.writeUInt32LE(dimensionType + geometryType >>> 0, true);\n};\n\nGeometry.getTwkbPrecision = function (xyPrecision, zPrecision, mPrecision) {\n  return {\n    xy: xyPrecision,\n    z: zPrecision,\n    m: mPrecision,\n    xyFactor: Math.pow(10, xyPrecision),\n    zFactor: Math.pow(10, zPrecision),\n    mFactor: Math.pow(10, mPrecision)\n  };\n};\n\nGeometry.prototype._writeTwkbHeader = function (twkb, geometryType, precision, isEmpty) {\n  var type = (ZigZag.encode(precision.xy) << 4) + geometryType;\n  var metadataHeader = (this.hasZ || this.hasM) << 3;\n  metadataHeader += isEmpty << 4;\n  twkb.writeUInt8(type);\n  twkb.writeUInt8(metadataHeader);\n\n  if (this.hasZ || this.hasM) {\n    var extendedPrecision = 0;\n    if (this.hasZ) extendedPrecision |= 0x1;\n    if (this.hasM) extendedPrecision |= 0x2;\n    twkb.writeUInt8(extendedPrecision);\n  }\n};\n\nGeometry.prototype.toGeoJSON = function (options) {\n  var geoJSON = {};\n\n  if (this.srid) {\n    if (options) {\n      if (options.shortCrs) {\n        geoJSON.crs = {\n          type: 'name',\n          properties: {\n            name: 'EPSG:' + this.srid\n          }\n        };\n      } else if (options.longCrs) {\n        geoJSON.crs = {\n          type: 'name',\n          properties: {\n            name: 'urn:ogc:def:crs:EPSG::' + this.srid\n          }\n        };\n      }\n    }\n  }\n\n  return geoJSON;\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/wkx/lib/geometry.js"],"names":["module","exports","Geometry","Types","require","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection","BinaryReader","BinaryWriter","WktParser","ZigZag","srid","undefined","hasZ","hasM","parse","value","options","valueType","_parseWkt","Buffer","isBuffer","_parseWkb","Error","wktParser","match","matchRegex","parseInt","geometryType","matchType","dimension","matchDimension","wkt","parentOptions","binaryReader","wkbType","isBigEndian","readInt8","readUInt32","hasSrid","isEwkb","wkb","parseTwkb","type","readUInt8","metadataHeader","precision","decode","precisionFactor","Math","pow","hasBoundingBox","hasSizeAttribute","hasIdList","hasExtendedPrecision","isEmpty","extendedPrecision","zPrecision","zPrecisionFactor","mPrecision","mPrecisionFactor","readVarInt","dimensions","i","_parseTwkb","parseGeoJSON","_parseGeoJSON","isSubGeometry","geometry","geoJSON","crs","properties","name","indexOf","substring","prototype","toEwkt","toWkt","toEwkb","ewkb","_getWkbSize","toWkb","writeInt8","writeUInt32LE","slice","readUInt32LE","writeBuffer","buffer","_getWktType","wktType","_getWktCoordinate","point","coordinates","x","y","z","m","_writeWkbType","dimensionType","getTwkbPrecision","xyPrecision","xy","xyFactor","zFactor","mFactor","_writeTwkbHeader","twkb","encode","writeUInt8","toGeoJSON","shortCrs","longCrs"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,QAAjB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,WAAD,CAArB;;AACA,IAAII,UAAU,GAAGJ,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIK,eAAe,GAAGL,OAAO,CAAC,mBAAD,CAA7B;;AACA,IAAIM,YAAY,GAAGN,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIO,kBAAkB,GAAGP,OAAO,CAAC,sBAAD,CAAhC;;AACA,IAAIQ,YAAY,GAAGR,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIS,YAAY,GAAGT,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIU,SAAS,GAAGV,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIW,MAAM,GAAGX,OAAO,CAAC,aAAD,CAApB;;AAEA,SAASF,QAAT,GAAoB;AAChB,OAAKc,IAAL,GAAYC,SAAZ;AACA,OAAKC,IAAL,GAAY,KAAZ;AACA,OAAKC,IAAL,GAAY,KAAZ;AACH;;AAEDjB,QAAQ,CAACkB,KAAT,GAAiB,UAAUC,KAAV,EAAiBC,OAAjB,EAA0B;AACvC,MAAIC,SAAS,GAAG,OAAOF,KAAvB;AAEA,MAAIE,SAAS,KAAK,QAAd,IAA0BF,KAAK,YAAYP,SAA/C,EACI,OAAOZ,QAAQ,CAACsB,SAAT,CAAmBH,KAAnB,CAAP,CADJ,KAEK,IAAII,MAAM,CAACC,QAAP,CAAgBL,KAAhB,KAA0BA,KAAK,YAAYT,YAA/C,EACD,OAAOV,QAAQ,CAACyB,SAAT,CAAmBN,KAAnB,EAA0BC,OAA1B,CAAP,CADC,KAGD,MAAM,IAAIM,KAAJ,CAAU,2CAAV,CAAN;AACP,CATD;;AAWA1B,QAAQ,CAACsB,SAAT,GAAqB,UAAUH,KAAV,EAAiB;AAClC,MAAIQ,SAAJ,EACIb,IADJ;AAGA,MAAIK,KAAK,YAAYP,SAArB,EACIe,SAAS,GAAGR,KAAZ,CADJ,KAGIQ,SAAS,GAAG,IAAIf,SAAJ,CAAcO,KAAd,CAAZ;AAEJ,MAAIS,KAAK,GAAGD,SAAS,CAACE,UAAV,CAAqB,CAAC,cAAD,CAArB,CAAZ;AACA,MAAID,KAAJ,EACId,IAAI,GAAGgB,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAf;AAEJ,MAAIG,YAAY,GAAGJ,SAAS,CAACK,SAAV,EAAnB;AACA,MAAIC,SAAS,GAAGN,SAAS,CAACO,cAAV,EAAhB;AAEA,MAAId,OAAO,GAAG;AACVN,IAAAA,IAAI,EAAEA,IADI;AAEVE,IAAAA,IAAI,EAAEiB,SAAS,CAACjB,IAFN;AAGVC,IAAAA,IAAI,EAAEgB,SAAS,CAAChB;AAHN,GAAd;;AAMA,UAAQc,YAAR;AACI,SAAK9B,KAAK,CAACkC,GAAN,CAAUhC,KAAf;AACI,aAAOA,KAAK,CAACmB,SAAN,CAAgBK,SAAhB,EAA2BP,OAA3B,CAAP;;AACJ,SAAKnB,KAAK,CAACkC,GAAN,CAAU/B,UAAf;AACI,aAAOA,UAAU,CAACkB,SAAX,CAAqBK,SAArB,EAAgCP,OAAhC,CAAP;;AACJ,SAAKnB,KAAK,CAACkC,GAAN,CAAU9B,OAAf;AACI,aAAOA,OAAO,CAACiB,SAAR,CAAkBK,SAAlB,EAA6BP,OAA7B,CAAP;;AACJ,SAAKnB,KAAK,CAACkC,GAAN,CAAU7B,UAAf;AACI,aAAOA,UAAU,CAACgB,SAAX,CAAqBK,SAArB,EAAgCP,OAAhC,CAAP;;AACJ,SAAKnB,KAAK,CAACkC,GAAN,CAAU5B,eAAf;AACI,aAAOA,eAAe,CAACe,SAAhB,CAA0BK,SAA1B,EAAqCP,OAArC,CAAP;;AACJ,SAAKnB,KAAK,CAACkC,GAAN,CAAU3B,YAAf;AACI,aAAOA,YAAY,CAACc,SAAb,CAAuBK,SAAvB,EAAkCP,OAAlC,CAAP;;AACJ,SAAKnB,KAAK,CAACkC,GAAN,CAAU1B,kBAAf;AACI,aAAOA,kBAAkB,CAACa,SAAnB,CAA6BK,SAA7B,EAAwCP,OAAxC,CAAP;AAdR;AAgBH,CAtCD;;AAwCApB,QAAQ,CAACyB,SAAT,GAAqB,UAAUN,KAAV,EAAiBiB,aAAjB,EAAgC;AACjD,MAAIC,YAAJ;AAAA,MACIC,OADJ;AAAA,MAEIP,YAFJ;AAAA,MAGIX,OAAO,GAAG,EAHd;AAKA,MAAID,KAAK,YAAYT,YAArB,EACI2B,YAAY,GAAGlB,KAAf,CADJ,KAGIkB,YAAY,GAAG,IAAI3B,YAAJ,CAAiBS,KAAjB,CAAf;AAEJkB,EAAAA,YAAY,CAACE,WAAb,GAA2B,CAACF,YAAY,CAACG,QAAb,EAA5B;AAEAF,EAAAA,OAAO,GAAGD,YAAY,CAACI,UAAb,EAAV;AAEArB,EAAAA,OAAO,CAACsB,OAAR,GAAkB,CAACJ,OAAO,GAAG,UAAX,MAA2B,UAA7C;AACAlB,EAAAA,OAAO,CAACuB,MAAR,GAAkBL,OAAO,GAAG,UAAX,IAA2BA,OAAO,GAAG,UAArC,IAAqDA,OAAO,GAAG,UAAhF;AAEA,MAAIlB,OAAO,CAACsB,OAAZ,EACItB,OAAO,CAACN,IAAR,GAAeuB,YAAY,CAACI,UAAb,EAAf;AAEJrB,EAAAA,OAAO,CAACJ,IAAR,GAAe,KAAf;AACAI,EAAAA,OAAO,CAACH,IAAR,GAAe,KAAf;;AAEA,MAAI,CAACG,OAAO,CAACuB,MAAT,KAAoB,CAACP,aAAD,IAAkB,CAACA,aAAa,CAACO,MAArD,CAAJ,EAAkE;AAC9D,QAAIL,OAAO,IAAI,IAAX,IAAmBA,OAAO,GAAG,IAAjC,EAAuC;AACnClB,MAAAA,OAAO,CAACJ,IAAR,GAAe,IAAf;AACAe,MAAAA,YAAY,GAAGO,OAAO,GAAG,IAAzB;AACH,KAHD,MAIK,IAAIA,OAAO,IAAI,IAAX,IAAmBA,OAAO,GAAG,IAAjC,EAAuC;AACxClB,MAAAA,OAAO,CAACH,IAAR,GAAe,IAAf;AACAc,MAAAA,YAAY,GAAGO,OAAO,GAAG,IAAzB;AACH,KAHI,MAIA,IAAIA,OAAO,IAAI,IAAX,IAAmBA,OAAO,GAAG,IAAjC,EAAuC;AACxClB,MAAAA,OAAO,CAACJ,IAAR,GAAe,IAAf;AACAI,MAAAA,OAAO,CAACH,IAAR,GAAe,IAAf;AACAc,MAAAA,YAAY,GAAGO,OAAO,GAAG,IAAzB;AACH,KAJI,MAKA;AACDP,MAAAA,YAAY,GAAGO,OAAf;AACH;AACJ,GAjBD,MAkBK;AACD,QAAIA,OAAO,GAAG,UAAd,EACIlB,OAAO,CAACJ,IAAR,GAAe,IAAf;AACJ,QAAIsB,OAAO,GAAG,UAAd,EACIlB,OAAO,CAACH,IAAR,GAAe,IAAf;AAEJc,IAAAA,YAAY,GAAGO,OAAO,GAAG,GAAzB;AACH;;AAED,UAAQP,YAAR;AACI,SAAK9B,KAAK,CAAC2C,GAAN,CAAUzC,KAAf;AACI,aAAOA,KAAK,CAACsB,SAAN,CAAgBY,YAAhB,EAA8BjB,OAA9B,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUxC,UAAf;AACI,aAAOA,UAAU,CAACqB,SAAX,CAAqBY,YAArB,EAAmCjB,OAAnC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUvC,OAAf;AACI,aAAOA,OAAO,CAACoB,SAAR,CAAkBY,YAAlB,EAAgCjB,OAAhC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUtC,UAAf;AACI,aAAOA,UAAU,CAACmB,SAAX,CAAqBY,YAArB,EAAmCjB,OAAnC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUrC,eAAf;AACI,aAAOA,eAAe,CAACkB,SAAhB,CAA0BY,YAA1B,EAAwCjB,OAAxC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUpC,YAAf;AACI,aAAOA,YAAY,CAACiB,SAAb,CAAuBY,YAAvB,EAAqCjB,OAArC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUnC,kBAAf;AACI,aAAOA,kBAAkB,CAACgB,SAAnB,CAA6BY,YAA7B,EAA2CjB,OAA3C,CAAP;;AACJ;AACI,YAAM,IAAIM,KAAJ,CAAU,kBAAkBK,YAAlB,GAAiC,gBAA3C,CAAN;AAhBR;AAkBH,CArED;;AAuEA/B,QAAQ,CAAC6C,SAAT,GAAqB,UAAU1B,KAAV,EAAiB;AAClC,MAAIkB,YAAJ;AAAA,MACIjB,OAAO,GAAG,EADd;AAGA,MAAID,KAAK,YAAYT,YAArB,EACI2B,YAAY,GAAGlB,KAAf,CADJ,KAGIkB,YAAY,GAAG,IAAI3B,YAAJ,CAAiBS,KAAjB,CAAf;AAEJ,MAAI2B,IAAI,GAAGT,YAAY,CAACU,SAAb,EAAX;AACA,MAAIC,cAAc,GAAGX,YAAY,CAACU,SAAb,EAArB;AAEA,MAAIhB,YAAY,GAAGe,IAAI,GAAG,IAA1B;AACA1B,EAAAA,OAAO,CAAC6B,SAAR,GAAoBpC,MAAM,CAACqC,MAAP,CAAcJ,IAAI,IAAI,CAAtB,CAApB;AACA1B,EAAAA,OAAO,CAAC+B,eAAR,GAA0BC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAajC,OAAO,CAAC6B,SAArB,CAA1B;AAEA7B,EAAAA,OAAO,CAACkC,cAAR,GAAyBN,cAAc,IAAI,CAAlB,GAAsB,CAA/C;AACA5B,EAAAA,OAAO,CAACmC,gBAAR,GAA2BP,cAAc,IAAI,CAAlB,GAAsB,CAAjD;AACA5B,EAAAA,OAAO,CAACoC,SAAR,GAAoBR,cAAc,IAAI,CAAlB,GAAsB,CAA1C;AACA5B,EAAAA,OAAO,CAACqC,oBAAR,GAA+BT,cAAc,IAAI,CAAlB,GAAsB,CAArD;AACA5B,EAAAA,OAAO,CAACsC,OAAR,GAAkBV,cAAc,IAAI,CAAlB,GAAsB,CAAxC;;AAEA,MAAI5B,OAAO,CAACqC,oBAAZ,EAAkC;AAC9B,QAAIE,iBAAiB,GAAGtB,YAAY,CAACU,SAAb,EAAxB;AACA3B,IAAAA,OAAO,CAACJ,IAAR,GAAe,CAAC2C,iBAAiB,GAAG,IAArB,MAA+B,IAA9C;AACAvC,IAAAA,OAAO,CAACH,IAAR,GAAe,CAAC0C,iBAAiB,GAAG,IAArB,MAA+B,IAA9C;AAEAvC,IAAAA,OAAO,CAACwC,UAAR,GAAqB/C,MAAM,CAACqC,MAAP,CAAc,CAACS,iBAAiB,GAAG,IAArB,KAA8B,CAA5C,CAArB;AACAvC,IAAAA,OAAO,CAACyC,gBAAR,GAA2BT,IAAI,CAACC,GAAL,CAAS,EAAT,EAAajC,OAAO,CAACwC,UAArB,CAA3B;AAEAxC,IAAAA,OAAO,CAAC0C,UAAR,GAAqBjD,MAAM,CAACqC,MAAP,CAAc,CAACS,iBAAiB,GAAG,IAArB,KAA8B,CAA5C,CAArB;AACAvC,IAAAA,OAAO,CAAC2C,gBAAR,GAA2BX,IAAI,CAACC,GAAL,CAAS,EAAT,EAAajC,OAAO,CAAC0C,UAArB,CAA3B;AACH,GAVD,MAWK;AACD1C,IAAAA,OAAO,CAACJ,IAAR,GAAe,KAAf;AACAI,IAAAA,OAAO,CAACH,IAAR,GAAe,KAAf;AACH;;AAED,MAAIG,OAAO,CAACmC,gBAAZ,EACIlB,YAAY,CAAC2B,UAAb;;AACJ,MAAI5C,OAAO,CAACkC,cAAZ,EAA4B;AACxB,QAAIW,UAAU,GAAG,CAAjB;AAEA,QAAI7C,OAAO,CAACJ,IAAZ,EACIiD,UAAU;AACd,QAAI7C,OAAO,CAACH,IAAZ,EACIgD,UAAU;;AAEd,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAApB,EAAgCC,CAAC,EAAjC,EAAqC;AACjC7B,MAAAA,YAAY,CAAC2B,UAAb;AACA3B,MAAAA,YAAY,CAAC2B,UAAb;AACH;AACJ;;AAED,UAAQjC,YAAR;AACI,SAAK9B,KAAK,CAAC2C,GAAN,CAAUzC,KAAf;AACI,aAAOA,KAAK,CAACgE,UAAN,CAAiB9B,YAAjB,EAA+BjB,OAA/B,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUxC,UAAf;AACI,aAAOA,UAAU,CAAC+D,UAAX,CAAsB9B,YAAtB,EAAoCjB,OAApC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUvC,OAAf;AACI,aAAOA,OAAO,CAAC8D,UAAR,CAAmB9B,YAAnB,EAAiCjB,OAAjC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUtC,UAAf;AACI,aAAOA,UAAU,CAAC6D,UAAX,CAAsB9B,YAAtB,EAAoCjB,OAApC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUrC,eAAf;AACI,aAAOA,eAAe,CAAC4D,UAAhB,CAA2B9B,YAA3B,EAAyCjB,OAAzC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUpC,YAAf;AACI,aAAOA,YAAY,CAAC2D,UAAb,CAAwB9B,YAAxB,EAAsCjB,OAAtC,CAAP;;AACJ,SAAKnB,KAAK,CAAC2C,GAAN,CAAUnC,kBAAf;AACI,aAAOA,kBAAkB,CAAC0D,UAAnB,CAA8B9B,YAA9B,EAA4CjB,OAA5C,CAAP;;AACJ;AACI,YAAM,IAAIM,KAAJ,CAAU,kBAAkBK,YAAlB,GAAiC,gBAA3C,CAAN;AAhBR;AAkBH,CAxED;;AA0EA/B,QAAQ,CAACoE,YAAT,GAAwB,UAAUjD,KAAV,EAAiB;AACrC,SAAOnB,QAAQ,CAACqE,aAAT,CAAuBlD,KAAvB,CAAP;AACH,CAFD;;AAIAnB,QAAQ,CAACqE,aAAT,GAAyB,UAAUlD,KAAV,EAAiBmD,aAAjB,EAAgC;AACrD,MAAIC,QAAJ;;AAEA,UAAQpD,KAAK,CAAC2B,IAAd;AACI,SAAK7C,KAAK,CAACuE,OAAN,CAAcrE,KAAnB;AACIoE,MAAAA,QAAQ,GAAGpE,KAAK,CAACkE,aAAN,CAAoBlD,KAApB,CAAX;AAAuC;;AAC3C,SAAKlB,KAAK,CAACuE,OAAN,CAAcpE,UAAnB;AACImE,MAAAA,QAAQ,GAAGnE,UAAU,CAACiE,aAAX,CAAyBlD,KAAzB,CAAX;AAA4C;;AAChD,SAAKlB,KAAK,CAACuE,OAAN,CAAcnE,OAAnB;AACIkE,MAAAA,QAAQ,GAAGlE,OAAO,CAACgE,aAAR,CAAsBlD,KAAtB,CAAX;AAAyC;;AAC7C,SAAKlB,KAAK,CAACuE,OAAN,CAAclE,UAAnB;AACIiE,MAAAA,QAAQ,GAAGjE,UAAU,CAAC+D,aAAX,CAAyBlD,KAAzB,CAAX;AAA4C;;AAChD,SAAKlB,KAAK,CAACuE,OAAN,CAAcjE,eAAnB;AACIgE,MAAAA,QAAQ,GAAGhE,eAAe,CAAC8D,aAAhB,CAA8BlD,KAA9B,CAAX;AAAiD;;AACrD,SAAKlB,KAAK,CAACuE,OAAN,CAAchE,YAAnB;AACI+D,MAAAA,QAAQ,GAAG/D,YAAY,CAAC6D,aAAb,CAA2BlD,KAA3B,CAAX;AAA8C;;AAClD,SAAKlB,KAAK,CAACuE,OAAN,CAAc/D,kBAAnB;AACI8D,MAAAA,QAAQ,GAAG9D,kBAAkB,CAAC4D,aAAnB,CAAiClD,KAAjC,CAAX;AAAoD;;AACxD;AACI,YAAM,IAAIO,KAAJ,CAAU,kBAAkBP,KAAK,CAAC2B,IAAxB,GAA+B,gBAAzC,CAAN;AAhBR;;AAmBA,MAAI3B,KAAK,CAACsD,GAAN,IAAatD,KAAK,CAACsD,GAAN,CAAU3B,IAAvB,IAA+B3B,KAAK,CAACsD,GAAN,CAAU3B,IAAV,KAAmB,MAAlD,IAA4D3B,KAAK,CAACsD,GAAN,CAAUC,UAAtE,IAAoFvD,KAAK,CAACsD,GAAN,CAAUC,UAAV,CAAqBC,IAA7G,EAAmH;AAC/G,QAAIF,GAAG,GAAGtD,KAAK,CAACsD,GAAN,CAAUC,UAAV,CAAqBC,IAA/B;AAEA,QAAIF,GAAG,CAACG,OAAJ,CAAY,OAAZ,MAAyB,CAA7B,EACIL,QAAQ,CAACzD,IAAT,GAAgBgB,QAAQ,CAAC2C,GAAG,CAACI,SAAJ,CAAc,CAAd,CAAD,CAAxB,CADJ,KAEK,IAAIJ,GAAG,CAACG,OAAJ,CAAY,wBAAZ,MAA0C,CAA9C,EACDL,QAAQ,CAACzD,IAAT,GAAgBgB,QAAQ,CAAC2C,GAAG,CAACI,SAAJ,CAAc,EAAd,CAAD,CAAxB,CADC,KAGD,MAAM,IAAInD,KAAJ,CAAU,sBAAsB+C,GAAhC,CAAN;AACP,GATD,MAUK,IAAI,CAACH,aAAL,EAAoB;AACrBC,IAAAA,QAAQ,CAACzD,IAAT,GAAgB,IAAhB;AACH;;AAED,SAAOyD,QAAP;AACH,CArCD;;AAuCAvE,QAAQ,CAAC8E,SAAT,CAAmBC,MAAnB,GAA4B,YAAY;AACpC,SAAO,UAAU,KAAKjE,IAAf,GAAsB,GAAtB,GAA4B,KAAKkE,KAAL,EAAnC;AACH,CAFD;;AAIAhF,QAAQ,CAAC8E,SAAT,CAAmBG,MAAnB,GAA4B,YAAY;AACpC,MAAIC,IAAI,GAAG,IAAIvE,YAAJ,CAAiB,KAAKwE,WAAL,KAAqB,CAAtC,CAAX;AACA,MAAIvC,GAAG,GAAG,KAAKwC,KAAL,EAAV;AAEAF,EAAAA,IAAI,CAACG,SAAL,CAAe,CAAf;AACAH,EAAAA,IAAI,CAACI,aAAL,CAAmB,CAAC1C,GAAG,CAAC2C,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgBC,YAAhB,CAA6B,CAA7B,IAAkC,UAAnC,MAAmD,CAAtE,EAAyE,IAAzE;AACAN,EAAAA,IAAI,CAACI,aAAL,CAAmB,KAAKxE,IAAxB;AAEAoE,EAAAA,IAAI,CAACO,WAAL,CAAiB7C,GAAG,CAAC2C,KAAJ,CAAU,CAAV,CAAjB;AAEA,SAAOL,IAAI,CAACQ,MAAZ;AACH,CAXD;;AAaA1F,QAAQ,CAAC8E,SAAT,CAAmBa,WAAnB,GAAiC,UAAUC,OAAV,EAAmBlC,OAAnB,EAA4B;AACzD,MAAIvB,GAAG,GAAGyD,OAAV;AAEA,MAAI,KAAK5E,IAAL,IAAa,KAAKC,IAAtB,EACIkB,GAAG,IAAI,MAAP,CADJ,KAEK,IAAI,KAAKnB,IAAT,EACDmB,GAAG,IAAI,KAAP,CADC,KAEA,IAAI,KAAKlB,IAAT,EACDkB,GAAG,IAAI,KAAP;AAEJ,MAAIuB,OAAO,IAAI,CAAC,KAAK1C,IAAjB,IAAyB,CAAC,KAAKC,IAAnC,EACIkB,GAAG,IAAI,GAAP;AAEJ,MAAIuB,OAAJ,EACIvB,GAAG,IAAI,OAAP;AAEJ,SAAOA,GAAP;AACH,CAjBD;;AAmBAnC,QAAQ,CAAC8E,SAAT,CAAmBe,iBAAnB,GAAuC,UAAUC,KAAV,EAAiB;AACpD,MAAIC,WAAW,GAAGD,KAAK,CAACE,CAAN,GAAU,GAAV,GAAgBF,KAAK,CAACG,CAAxC;AAEA,MAAI,KAAKjF,IAAT,EACI+E,WAAW,IAAI,MAAMD,KAAK,CAACI,CAA3B;AACJ,MAAI,KAAKjF,IAAT,EACI8E,WAAW,IAAI,MAAMD,KAAK,CAACK,CAA3B;AAEJ,SAAOJ,WAAP;AACH,CATD;;AAWA/F,QAAQ,CAAC8E,SAAT,CAAmBsB,aAAnB,GAAmC,UAAUxD,GAAV,EAAeb,YAAf,EAA6BK,aAA7B,EAA4C;AAC3E,MAAIiE,aAAa,GAAG,CAApB;;AAEA,MAAI,OAAO,KAAKvF,IAAZ,KAAqB,WAArB,KAAqC,CAACsB,aAAD,IAAkB,OAAOA,aAAa,CAACtB,IAArB,KAA8B,WAArF,CAAJ,EAAuG;AACnG,QAAI,KAAKE,IAAL,IAAa,KAAKC,IAAtB,EACIoF,aAAa,IAAI,IAAjB,CADJ,KAEK,IAAI,KAAKrF,IAAT,EACDqF,aAAa,IAAI,IAAjB,CADC,KAEA,IAAI,KAAKpF,IAAT,EACDoF,aAAa,IAAI,IAAjB;AACP,GAPD,MAQK;AACD,QAAI,KAAKrF,IAAT,EACIqF,aAAa,IAAI,UAAjB;AACJ,QAAI,KAAKpF,IAAT,EACIoF,aAAa,IAAI,UAAjB;AACP;;AAEDzD,EAAAA,GAAG,CAAC0C,aAAJ,CAAmBe,aAAa,GAAGtE,YAAjB,KAAmC,CAArD,EAAwD,IAAxD;AACH,CAnBD;;AAqBA/B,QAAQ,CAACsG,gBAAT,GAA4B,UAAUC,WAAV,EAAuB3C,UAAvB,EAAmCE,UAAnC,EAA+C;AACvE,SAAO;AACH0C,IAAAA,EAAE,EAAED,WADD;AAEHL,IAAAA,CAAC,EAAEtC,UAFA;AAGHuC,IAAAA,CAAC,EAAErC,UAHA;AAIH2C,IAAAA,QAAQ,EAAErD,IAAI,CAACC,GAAL,CAAS,EAAT,EAAakD,WAAb,CAJP;AAKHG,IAAAA,OAAO,EAAEtD,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaO,UAAb,CALN;AAMH+C,IAAAA,OAAO,EAAEvD,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaS,UAAb;AANN,GAAP;AAQH,CATD;;AAWA9D,QAAQ,CAAC8E,SAAT,CAAmB8B,gBAAnB,GAAsC,UAAUC,IAAV,EAAgB9E,YAAhB,EAA8BkB,SAA9B,EAAyCS,OAAzC,EAAkD;AACpF,MAAIZ,IAAI,GAAG,CAACjC,MAAM,CAACiG,MAAP,CAAc7D,SAAS,CAACuD,EAAxB,KAA+B,CAAhC,IAAqCzE,YAAhD;AACA,MAAIiB,cAAc,GAAG,CAAC,KAAKhC,IAAL,IAAa,KAAKC,IAAnB,KAA4B,CAAjD;AACA+B,EAAAA,cAAc,IAAIU,OAAO,IAAI,CAA7B;AAEAmD,EAAAA,IAAI,CAACE,UAAL,CAAgBjE,IAAhB;AACA+D,EAAAA,IAAI,CAACE,UAAL,CAAgB/D,cAAhB;;AAEA,MAAI,KAAKhC,IAAL,IAAa,KAAKC,IAAtB,EAA4B;AACxB,QAAI0C,iBAAiB,GAAG,CAAxB;AACA,QAAI,KAAK3C,IAAT,EACI2C,iBAAiB,IAAI,GAArB;AACJ,QAAI,KAAK1C,IAAT,EACI0C,iBAAiB,IAAI,GAArB;AAEJkD,IAAAA,IAAI,CAACE,UAAL,CAAgBpD,iBAAhB;AACH;AACJ,CAjBD;;AAmBA3D,QAAQ,CAAC8E,SAAT,CAAmBkC,SAAnB,GAA+B,UAAU5F,OAAV,EAAmB;AAC9C,MAAIoD,OAAO,GAAG,EAAd;;AAEA,MAAI,KAAK1D,IAAT,EAAe;AACX,QAAIM,OAAJ,EAAa;AACT,UAAIA,OAAO,CAAC6F,QAAZ,EAAsB;AAClBzC,QAAAA,OAAO,CAACC,GAAR,GAAc;AACV3B,UAAAA,IAAI,EAAE,MADI;AAEV4B,UAAAA,UAAU,EAAE;AACRC,YAAAA,IAAI,EAAE,UAAU,KAAK7D;AADb;AAFF,SAAd;AAMH,OAPD,MAQK,IAAIM,OAAO,CAAC8F,OAAZ,EAAqB;AACtB1C,QAAAA,OAAO,CAACC,GAAR,GAAc;AACV3B,UAAAA,IAAI,EAAE,MADI;AAEV4B,UAAAA,UAAU,EAAE;AACRC,YAAAA,IAAI,EAAE,2BAA2B,KAAK7D;AAD9B;AAFF,SAAd;AAMH;AACJ;AACJ;;AAED,SAAO0D,OAAP;AACH,CAzBD","sourcesContent":["module.exports = Geometry;\r\n\r\nvar Types = require('./types');\r\nvar Point = require('./point');\r\nvar LineString = require('./linestring');\r\nvar Polygon = require('./polygon');\r\nvar MultiPoint = require('./multipoint');\r\nvar MultiLineString = require('./multilinestring');\r\nvar MultiPolygon = require('./multipolygon');\r\nvar GeometryCollection = require('./geometrycollection');\r\nvar BinaryReader = require('./binaryreader');\r\nvar BinaryWriter = require('./binarywriter');\r\nvar WktParser = require('./wktparser');\r\nvar ZigZag = require('./zigzag.js');\r\n\r\nfunction Geometry() {\r\n    this.srid = undefined;\r\n    this.hasZ = false;\r\n    this.hasM = false;\r\n}\r\n\r\nGeometry.parse = function (value, options) {\r\n    var valueType = typeof value;\r\n\r\n    if (valueType === 'string' || value instanceof WktParser)\r\n        return Geometry._parseWkt(value);\r\n    else if (Buffer.isBuffer(value) || value instanceof BinaryReader)\r\n        return Geometry._parseWkb(value, options);\r\n    else\r\n        throw new Error('first argument must be a string or Buffer');\r\n};\r\n\r\nGeometry._parseWkt = function (value) {\r\n    var wktParser,\r\n        srid;\r\n\r\n    if (value instanceof WktParser)\r\n        wktParser = value;\r\n    else\r\n        wktParser = new WktParser(value);\r\n\r\n    var match = wktParser.matchRegex([/^SRID=(\\d+);/]);\r\n    if (match)\r\n        srid = parseInt(match[1], 10);\r\n\r\n    var geometryType = wktParser.matchType();\r\n    var dimension = wktParser.matchDimension();\r\n\r\n    var options = {\r\n        srid: srid,\r\n        hasZ: dimension.hasZ,\r\n        hasM: dimension.hasM\r\n    };\r\n\r\n    switch (geometryType) {\r\n        case Types.wkt.Point:\r\n            return Point._parseWkt(wktParser, options);\r\n        case Types.wkt.LineString:\r\n            return LineString._parseWkt(wktParser, options);\r\n        case Types.wkt.Polygon:\r\n            return Polygon._parseWkt(wktParser, options);\r\n        case Types.wkt.MultiPoint:\r\n            return MultiPoint._parseWkt(wktParser, options);\r\n        case Types.wkt.MultiLineString:\r\n            return MultiLineString._parseWkt(wktParser, options);\r\n        case Types.wkt.MultiPolygon:\r\n            return MultiPolygon._parseWkt(wktParser, options);\r\n        case Types.wkt.GeometryCollection:\r\n            return GeometryCollection._parseWkt(wktParser, options);\r\n    }\r\n};\r\n\r\nGeometry._parseWkb = function (value, parentOptions) {\r\n    var binaryReader,\r\n        wkbType,\r\n        geometryType,\r\n        options = {};\r\n\r\n    if (value instanceof BinaryReader)\r\n        binaryReader = value;\r\n    else\r\n        binaryReader = new BinaryReader(value);\r\n\r\n    binaryReader.isBigEndian = !binaryReader.readInt8();\r\n\r\n    wkbType = binaryReader.readUInt32();\r\n\r\n    options.hasSrid = (wkbType & 0x20000000) === 0x20000000;\r\n    options.isEwkb = (wkbType & 0x20000000) || (wkbType & 0x40000000) || (wkbType & 0x80000000);\r\n\r\n    if (options.hasSrid)\r\n        options.srid = binaryReader.readUInt32();\r\n\r\n    options.hasZ = false;\r\n    options.hasM = false;\r\n\r\n    if (!options.isEwkb && (!parentOptions || !parentOptions.isEwkb)) {\r\n        if (wkbType >= 1000 && wkbType < 2000) {\r\n            options.hasZ = true;\r\n            geometryType = wkbType - 1000;\r\n        }\r\n        else if (wkbType >= 2000 && wkbType < 3000) {\r\n            options.hasM = true;\r\n            geometryType = wkbType - 2000;\r\n        }\r\n        else if (wkbType >= 3000 && wkbType < 4000) {\r\n            options.hasZ = true;\r\n            options.hasM = true;\r\n            geometryType = wkbType - 3000;\r\n        }\r\n        else {\r\n            geometryType = wkbType;\r\n        }\r\n    }\r\n    else {\r\n        if (wkbType & 0x80000000)\r\n            options.hasZ = true;\r\n        if (wkbType & 0x40000000)\r\n            options.hasM = true;\r\n\r\n        geometryType = wkbType & 0xF;\r\n    }\r\n\r\n    switch (geometryType) {\r\n        case Types.wkb.Point:\r\n            return Point._parseWkb(binaryReader, options);\r\n        case Types.wkb.LineString:\r\n            return LineString._parseWkb(binaryReader, options);\r\n        case Types.wkb.Polygon:\r\n            return Polygon._parseWkb(binaryReader, options);\r\n        case Types.wkb.MultiPoint:\r\n            return MultiPoint._parseWkb(binaryReader, options);\r\n        case Types.wkb.MultiLineString:\r\n            return MultiLineString._parseWkb(binaryReader, options);\r\n        case Types.wkb.MultiPolygon:\r\n            return MultiPolygon._parseWkb(binaryReader, options);\r\n        case Types.wkb.GeometryCollection:\r\n            return GeometryCollection._parseWkb(binaryReader, options);\r\n        default:\r\n            throw new Error('GeometryType ' + geometryType + ' not supported');\r\n    }\r\n};\r\n\r\nGeometry.parseTwkb = function (value) {\r\n    var binaryReader,\r\n        options = {};\r\n\r\n    if (value instanceof BinaryReader)\r\n        binaryReader = value;\r\n    else\r\n        binaryReader = new BinaryReader(value);\r\n\r\n    var type = binaryReader.readUInt8();\r\n    var metadataHeader = binaryReader.readUInt8();\r\n\r\n    var geometryType = type & 0x0F;\r\n    options.precision = ZigZag.decode(type >> 4);\r\n    options.precisionFactor = Math.pow(10, options.precision);\r\n\r\n    options.hasBoundingBox = metadataHeader >> 0 & 1;\r\n    options.hasSizeAttribute = metadataHeader >> 1 & 1;\r\n    options.hasIdList = metadataHeader >> 2 & 1;\r\n    options.hasExtendedPrecision = metadataHeader >> 3 & 1;\r\n    options.isEmpty = metadataHeader >> 4 & 1;\r\n\r\n    if (options.hasExtendedPrecision) {\r\n        var extendedPrecision = binaryReader.readUInt8();\r\n        options.hasZ = (extendedPrecision & 0x01) === 0x01;\r\n        options.hasM = (extendedPrecision & 0x02) === 0x02;\r\n\r\n        options.zPrecision = ZigZag.decode((extendedPrecision & 0x1C) >> 2);\r\n        options.zPrecisionFactor = Math.pow(10, options.zPrecision);\r\n\r\n        options.mPrecision = ZigZag.decode((extendedPrecision & 0xE0) >> 5);\r\n        options.mPrecisionFactor = Math.pow(10, options.mPrecision);\r\n    }\r\n    else {\r\n        options.hasZ = false;\r\n        options.hasM = false;\r\n    }\r\n\r\n    if (options.hasSizeAttribute)\r\n        binaryReader.readVarInt();\r\n    if (options.hasBoundingBox) {\r\n        var dimensions = 2;\r\n\r\n        if (options.hasZ)\r\n            dimensions++;\r\n        if (options.hasM)\r\n            dimensions++;\r\n\r\n        for (var i = 0; i < dimensions; i++) {\r\n            binaryReader.readVarInt();\r\n            binaryReader.readVarInt();\r\n        }\r\n    }\r\n\r\n    switch (geometryType) {\r\n        case Types.wkb.Point:\r\n            return Point._parseTwkb(binaryReader, options);\r\n        case Types.wkb.LineString:\r\n            return LineString._parseTwkb(binaryReader, options);\r\n        case Types.wkb.Polygon:\r\n            return Polygon._parseTwkb(binaryReader, options);\r\n        case Types.wkb.MultiPoint:\r\n            return MultiPoint._parseTwkb(binaryReader, options);\r\n        case Types.wkb.MultiLineString:\r\n            return MultiLineString._parseTwkb(binaryReader, options);\r\n        case Types.wkb.MultiPolygon:\r\n            return MultiPolygon._parseTwkb(binaryReader, options);\r\n        case Types.wkb.GeometryCollection:\r\n            return GeometryCollection._parseTwkb(binaryReader, options);\r\n        default:\r\n            throw new Error('GeometryType ' + geometryType + ' not supported');\r\n    }\r\n};\r\n\r\nGeometry.parseGeoJSON = function (value) {\r\n    return Geometry._parseGeoJSON(value);\r\n};\r\n\r\nGeometry._parseGeoJSON = function (value, isSubGeometry) {\r\n    var geometry;\r\n\r\n    switch (value.type) {\r\n        case Types.geoJSON.Point:\r\n            geometry = Point._parseGeoJSON(value); break;\r\n        case Types.geoJSON.LineString:\r\n            geometry = LineString._parseGeoJSON(value); break;\r\n        case Types.geoJSON.Polygon:\r\n            geometry = Polygon._parseGeoJSON(value); break;\r\n        case Types.geoJSON.MultiPoint:\r\n            geometry = MultiPoint._parseGeoJSON(value); break;\r\n        case Types.geoJSON.MultiLineString:\r\n            geometry = MultiLineString._parseGeoJSON(value); break;\r\n        case Types.geoJSON.MultiPolygon:\r\n            geometry = MultiPolygon._parseGeoJSON(value); break;\r\n        case Types.geoJSON.GeometryCollection:\r\n            geometry = GeometryCollection._parseGeoJSON(value); break;\r\n        default:\r\n            throw new Error('GeometryType ' + value.type + ' not supported');\r\n    }\r\n\r\n    if (value.crs && value.crs.type && value.crs.type === 'name' && value.crs.properties && value.crs.properties.name) {\r\n        var crs = value.crs.properties.name;\r\n\r\n        if (crs.indexOf('EPSG:') === 0)\r\n            geometry.srid = parseInt(crs.substring(5));\r\n        else if (crs.indexOf('urn:ogc:def:crs:EPSG::') === 0)\r\n            geometry.srid = parseInt(crs.substring(22));\r\n        else\r\n            throw new Error('Unsupported crs: ' + crs);\r\n    }\r\n    else if (!isSubGeometry) {\r\n        geometry.srid = 4326;\r\n    }\r\n\r\n    return geometry;\r\n};\r\n\r\nGeometry.prototype.toEwkt = function () {\r\n    return 'SRID=' + this.srid + ';' + this.toWkt();\r\n};\r\n\r\nGeometry.prototype.toEwkb = function () {\r\n    var ewkb = new BinaryWriter(this._getWkbSize() + 4);\r\n    var wkb = this.toWkb();\r\n\r\n    ewkb.writeInt8(1);\r\n    ewkb.writeUInt32LE((wkb.slice(1, 5).readUInt32LE(0) | 0x20000000) >>> 0, true);\r\n    ewkb.writeUInt32LE(this.srid);\r\n\r\n    ewkb.writeBuffer(wkb.slice(5));\r\n\r\n    return ewkb.buffer;\r\n};\r\n\r\nGeometry.prototype._getWktType = function (wktType, isEmpty) {\r\n    var wkt = wktType;\r\n\r\n    if (this.hasZ && this.hasM)\r\n        wkt += ' ZM ';\r\n    else if (this.hasZ)\r\n        wkt += ' Z ';\r\n    else if (this.hasM)\r\n        wkt += ' M ';\r\n\r\n    if (isEmpty && !this.hasZ && !this.hasM)\r\n        wkt += ' ';\r\n\r\n    if (isEmpty)\r\n        wkt += 'EMPTY';\r\n\r\n    return wkt;\r\n};\r\n\r\nGeometry.prototype._getWktCoordinate = function (point) {\r\n    var coordinates = point.x + ' ' + point.y;\r\n\r\n    if (this.hasZ)\r\n        coordinates += ' ' + point.z;\r\n    if (this.hasM)\r\n        coordinates += ' ' + point.m;\r\n\r\n    return coordinates;\r\n};\r\n\r\nGeometry.prototype._writeWkbType = function (wkb, geometryType, parentOptions) {\r\n    var dimensionType = 0;\r\n\r\n    if (typeof this.srid === 'undefined' && (!parentOptions || typeof parentOptions.srid === 'undefined')) {\r\n        if (this.hasZ && this.hasM)\r\n            dimensionType += 3000;\r\n        else if (this.hasZ)\r\n            dimensionType += 1000;\r\n        else if (this.hasM)\r\n            dimensionType += 2000;\r\n    }\r\n    else {\r\n        if (this.hasZ)\r\n            dimensionType |= 0x80000000;\r\n        if (this.hasM)\r\n            dimensionType |= 0x40000000;\r\n    }\r\n\r\n    wkb.writeUInt32LE((dimensionType + geometryType) >>> 0, true);\r\n};\r\n\r\nGeometry.getTwkbPrecision = function (xyPrecision, zPrecision, mPrecision) {\r\n    return {\r\n        xy: xyPrecision,\r\n        z: zPrecision,\r\n        m: mPrecision,\r\n        xyFactor: Math.pow(10, xyPrecision),\r\n        zFactor: Math.pow(10, zPrecision),\r\n        mFactor: Math.pow(10, mPrecision)\r\n    };\r\n};\r\n\r\nGeometry.prototype._writeTwkbHeader = function (twkb, geometryType, precision, isEmpty) {\r\n    var type = (ZigZag.encode(precision.xy) << 4) + geometryType;\r\n    var metadataHeader = (this.hasZ || this.hasM) << 3;\r\n    metadataHeader += isEmpty << 4;\r\n\r\n    twkb.writeUInt8(type);\r\n    twkb.writeUInt8(metadataHeader);\r\n\r\n    if (this.hasZ || this.hasM) {\r\n        var extendedPrecision = 0;\r\n        if (this.hasZ)\r\n            extendedPrecision |= 0x1;\r\n        if (this.hasM)\r\n            extendedPrecision |= 0x2;\r\n\r\n        twkb.writeUInt8(extendedPrecision);\r\n    }\r\n};\r\n\r\nGeometry.prototype.toGeoJSON = function (options) {\r\n    var geoJSON = {};\r\n\r\n    if (this.srid) {\r\n        if (options) {\r\n            if (options.shortCrs) {\r\n                geoJSON.crs = {\r\n                    type: 'name',\r\n                    properties: {\r\n                        name: 'EPSG:' + this.srid\r\n                    }\r\n                };\r\n            }\r\n            else if (options.longCrs) {\r\n                geoJSON.crs = {\r\n                    type: 'name',\r\n                    properties: {\r\n                        name: 'urn:ogc:def:crs:EPSG::' + this.srid\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return geoJSON;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}