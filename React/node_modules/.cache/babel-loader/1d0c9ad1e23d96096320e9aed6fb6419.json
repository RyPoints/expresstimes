{"ast":null,"code":"'use strict';\n\nconst DataTypes = require('../../data-types');\n\nconst Promise = require('../../promise');\n\nconst QueryTypes = require('../../query-types');\n\nconst _ = require('lodash');\n/**\n Returns an object that handles Postgres special needs to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n   * Ensure enum and their values.\n   *\n   * @param {QueryInterface} qi\n   * @param {string} tableName  Name of table to create\n   * @param {Object} attributes Object representing a list of normalized table attributes\n   * @param {Object} [options]\n   * @param {Model}  [model]\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\nfunction ensureEnums(qi, tableName, attributes, options, model) {\n  const keys = Object.keys(attributes);\n  const keyLen = keys.length;\n  let sql = '';\n  let promises = [];\n  let i = 0;\n\n  for (i = 0; i < keyLen; i++) {\n    const attribute = attributes[keys[i]];\n    const type = attribute.type;\n\n    if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n    ) {\n        sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(qi.sequelize.query(sql, Object.assign({}, options, {\n          plain: true,\n          raw: true,\n          type: QueryTypes.SELECT\n        })));\n      }\n  }\n\n  return Promise.all(promises).then(results => {\n    promises = [];\n    let enumIdx = 0; // This little function allows us to re-use the same code that prepends or appends new value to enum array\n\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = _.clone(options);\n\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n          // If the enum type doesn't exist then create it\n          if (!results[enumIdx]) {\n            promises.push(() => {\n              return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, {\n                raw: true\n              }));\n            });\n          } else if (!!results[enumIdx] && !!model) {\n            const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n            const vals = enumType.values; // Going through already existing values allows us to make queries that depend on those values\n            // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n            // Then we append the rest of new values AFTER the latest already existing value\n            // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n            // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n            // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n            let lastOldEnumValue;\n            let rightestPosition = -1;\n\n            for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n              const enumVal = enumVals[oldIndex];\n              const newIdx = vals.indexOf(enumVal);\n              lastOldEnumValue = enumVal;\n\n              if (newIdx === -1) {\n                continue;\n              }\n\n              const newValuesBefore = vals.slice(0, newIdx);\n              const promisesLength = promises.length; // we go in reverse order so we could stop when we meet old value\n\n              for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n                if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                  break;\n                }\n\n                addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n              } // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n\n              if (newIdx > rightestPosition) {\n                rightestPosition = newIdx;\n              }\n            }\n\n            if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n              const remainingEnumValues = vals.slice(rightestPosition + 1);\n\n              for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n                addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n              }\n            }\n\n            enumIdx++;\n          }\n        }\n    }\n\n    return promises.reduce((promise, asyncFunction) => promise.then(asyncFunction), Promise.resolve()).tap(() => {\n      // If ENUM processed, then refresh OIDs\n      if (promises.length) {\n        return qi.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n      }\n    });\n  });\n}\n\nexports.ensureEnums = ensureEnums;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/dialects/postgres/query-interface.js"],"names":["DataTypes","require","Promise","QueryTypes","_","ensureEnums","qi","tableName","attributes","options","model","keys","Object","keyLen","length","sql","promises","i","attribute","type","ENUM","ARRAY","QueryGenerator","pgListEnums","field","push","sequelize","query","assign","plain","raw","SELECT","all","then","results","enumIdx","addEnumValue","value","relativeValue","position","spliceStart","valueOptions","clone","before","after","splice","pgEnumAdd","enumType","pgEnum","enumVals","fromArray","enum_value","vals","values","lastOldEnumValue","rightestPosition","oldIndex","enumVal","newIdx","indexOf","newValuesBefore","slice","promisesLength","reverseIdx","remainingEnumValues","reduce","promise","asyncFunction","resolve","tap","dialect","connectionManager","_refreshDynamicOIDs","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst DataTypes = require('../../data-types');\nconst Promise = require('../../promise');\nconst QueryTypes = require('../../query-types');\nconst _ = require('lodash');\n\n\n/**\n Returns an object that handles Postgres special needs to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n   * Ensure enum and their values.\n   *\n   * @param {QueryInterface} qi\n   * @param {string} tableName  Name of table to create\n   * @param {Object} attributes Object representing a list of normalized table attributes\n   * @param {Object} [options]\n   * @param {Model}  [model]\n   *\n   * @returns {Promise}\n   * @private\n   */\nfunction ensureEnums(qi, tableName, attributes, options, model) {\n  const keys = Object.keys(attributes);\n  const keyLen = keys.length;\n\n  let sql = '';\n  let promises = [];\n  let i = 0;\n\n  for (i = 0; i < keyLen; i++) {\n    const attribute = attributes[keys[i]];\n    const type = attribute.type;\n\n    if (\n      type instanceof DataTypes.ENUM ||\n      type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n    ) {\n      sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n      promises.push(qi.sequelize.query(\n        sql,\n        Object.assign({}, options, { plain: true, raw: true, type: QueryTypes.SELECT })\n      ));\n    }\n  }\n\n  return Promise.all(promises).then(results => {\n    promises = [];\n    let enumIdx = 0;\n\n    // This little function allows us to re-use the same code that prepends or appends new value to enum array\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = _.clone(options);\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(\n          tableName, field, value, valueOptions\n        ), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        // If the enum type doesn't exist then create it\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, { raw: true }));\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n\n          // Going through already existing values allows us to make queries that depend on those values\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n          // Then we append the rest of new values AFTER the latest already existing value\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n\n            if (newIdx === -1) {\n              continue;\n            }\n\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            // we go in reverse order so we could stop when we meet old value\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n            }\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n            }\n          }\n\n          enumIdx++;\n        }\n      }\n    }\n\n    return promises\n      .reduce((promise, asyncFunction) => promise.then(asyncFunction), Promise.resolve())\n      .tap(() => {\n        // If ENUM processed, then refresh OIDs\n        if (promises.length) {\n          return qi.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n        }\n      });\n  });\n}\n\n\nexports.ensureEnums = ensureEnums;\n"]},"metadata":{},"sourceType":"script"}