{"ast":null,"code":"'use strict';\n\nconst Pooling = require('generic-pool');\n\nconst Promise = require('../../promise');\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst debug = Utils.getLogger().debugContext('pool');\n\nconst semver = require('semver');\n\nconst defaultPoolingConfig = {\n  max: 5,\n  min: 0,\n  idle: 10000,\n  acquire: 10000,\n  evict: 10000,\n  handleDisconnects: true\n};\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pool, replication and determining database version\n * Works with generic-pool to maintain connection pool\n *\n * @private\n */\n\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, defaultPoolingConfig, {\n      validate: this._validate.bind(this),\n      Promise\n    });\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (dataType.hasOwnProperty('parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error('Parse function not supported for type ' + dataType.key + ' in dialect ' + this.dialectName);\n        }\n      }\n    });\n  }\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @return {Promise}\n   */\n\n\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.clear();\n    });\n  }\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @return {Promise}\n   */\n\n\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n\n\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = Pooling.createPool({\n        create: () => this._connect(config).catch(err => err),\n        destroy: mayBeConnection => {\n          if (mayBeConnection instanceof Error) {\n            return Promise.resolve();\n          }\n\n          return this._disconnect(mayBeConnection).tap(() => {\n            debug('connection destroy');\n          });\n        },\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        testOnBorrow: true,\n        returnToHead: true,\n        autostart: false,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n\n    let reads = 0;\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    } // Map main connection config\n\n\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication')); // Apply defaults to each read config\n\n    config.replication.read = _.map(config.replication.read, readConfig => _.defaults(readConfig, _.omit(this.config, 'replication'))); // custom pooling for replication (original author @janmeier)\n\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          return this.pool.read.release(client);\n        } else {\n          return this.pool.write.release(client);\n        }\n      },\n      acquire: (priority, queryType, useMaster) => {\n        useMaster = _.isUndefined(useMaster) ? false : useMaster;\n\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire(priority).then(mayBeConnection => this._determineConnection(mayBeConnection));\n        } else {\n          return this.pool.write.acquire(priority).then(mayBeConnection => this._determineConnection(mayBeConnection));\n        }\n      },\n      destroy: mayBeConnection => {\n        if (mayBeConnection instanceof Error) {\n          return Promise.resolve();\n        }\n\n        return this.pool[mayBeConnection.queryType].destroy(mayBeConnection).tap(() => {\n          debug('connection destroy');\n        });\n      },\n      clear: () => {\n        return Promise.join(this.pool.read.clear(), this.pool.write.clear()).tap(() => {\n          debug('all connection clear');\n        });\n      },\n      drain: () => {\n        return Promise.join(this.pool.write.drain(), this.pool.read.drain());\n      },\n      read: Pooling.createPool({\n        create: () => {\n          const nextRead = reads++ % config.replication.read.length; // round robin config\n\n          return this._connect(config.replication.read[nextRead]).tap(connection => {\n            connection.queryType = 'read';\n          }).catch(err => err);\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        testOnBorrow: true,\n        returnToHead: true,\n        autostart: false,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      }),\n      write: Pooling.createPool({\n        create: () => {\n          return this._connect(config.replication.write).tap(connection => {\n            connection.queryType = 'write';\n          }).catch(err => err);\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        testOnBorrow: true,\n        returnToHead: true,\n        autostart: false,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {Integer}  [options.priority]        Set priority for this call. Read more at https://github.com/coopernurse/node-pool#priority-queueing\n   * @param {String}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {Boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @return {Promise<Connection>}\n   */\n\n\n  getConnection(options) {\n    options = options || {};\n    let promise;\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config).then(connection => {\n          const _options = {};\n          _options.transaction = {\n            connection\n          }; // Cheat .query to use our private connection\n\n          _options.logging = () => {};\n\n          _options.logging.__testLoggingFn = true;\n          return this.sequelize.databaseVersion(_options).then(version => {\n            this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.defaultVersion;\n            this.versionPromise = null;\n            return this._disconnect(connection);\n          });\n        }).catch(err => {\n          this.versionPromise = null;\n          throw err;\n        });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.priority, options.type, options.useMaster).then(mayBeConnection => this._determineConnection(mayBeConnection)).tap(() => {\n        debug('connection acquired');\n      });\n    });\n  }\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @return {Promise}\n   */\n\n\n  releaseConnection(connection) {\n    return this.pool.release(connection).tap(() => {\n      debug('connection released');\n    }).catch(/Resource not currently part of this pool/, () => {});\n  }\n  /**\n   * Check if something acquired by pool is indeed a connection but not an Error instance\n   * Why we need to do this https://github.com/sequelize/sequelize/pull/8330\n   *\n   * @param {Object|Error} mayBeConnection Object which can be either connection or error\n   *\n   * @return {Promise<Connection>}\n   */\n\n\n  _determineConnection(mayBeConnection) {\n    if (mayBeConnection instanceof Error) {\n      return Promise.resolve(this.pool.destroy(mayBeConnection)).catch(/Resource not currently part of this pool/, () => {}).then(() => {\n        throw mayBeConnection;\n      });\n    }\n\n    return Promise.resolve(mayBeConnection);\n  }\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @return {Promise<Connection>}\n   */\n\n\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config).then(() => this.dialect.connectionManager.connect(config)).then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @return {Promise}\n   */\n\n\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @return {Boolean}\n   */\n\n\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/dialects/abstract/connection-manager.js"],"names":["Pooling","require","Promise","_","Utils","debug","getLogger","debugContext","semver","defaultPoolingConfig","max","min","idle","acquire","evict","handleDisconnects","ConnectionManager","constructor","dialect","sequelize","config","cloneDeep","versionPromise","dialectName","options","pool","Error","defaults","validate","_validate","bind","initPools","refreshTypeParser","dataTypes","each","dataType","hasOwnProperty","types","_refreshTypeParser","key","_onProcessExit","resolve","drain","then","clear","close","getConnection","reject","replication","createPool","create","_connect","catch","err","destroy","mayBeConnection","_disconnect","tap","testOnBorrow","returnToHead","autostart","acquireTimeoutMillis","idleTimeoutMillis","evictionRunIntervalMillis","reads","Array","isArray","read","write","omit","map","readConfig","release","client","queryType","priority","useMaster","isUndefined","_determineConnection","join","nextRead","length","connection","promise","databaseVersion","_options","transaction","logging","__testLoggingFn","version","valid","defaultVersion","type","releaseConnection","runHooks","connectionManager","connect","return","disconnect","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Pooling = require('generic-pool');\nconst Promise = require('../../promise');\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst debug = Utils.getLogger().debugContext('pool');\nconst semver = require('semver');\n\nconst defaultPoolingConfig = {\n  max: 5,\n  min: 0,\n  idle: 10000,\n  acquire: 10000,\n  evict: 10000,\n  handleDisconnects: true\n};\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pool, replication and determining database version\n * Works with generic-pool to maintain connection pool\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, defaultPoolingConfig, {\n      validate: this._validate.bind(this),\n      Promise\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (dataType.hasOwnProperty('parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error('Parse function not supported for type ' + dataType.key + ' in dialect ' + this.dialectName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @return {Promise}\n   */\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.clear();\n    });\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @return {Promise}\n   */\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = Pooling.createPool({\n        create: () => this._connect(config).catch(err => err),\n        destroy: mayBeConnection => {\n          if (mayBeConnection instanceof Error) {\n            return Promise.resolve();\n          }\n\n          return this._disconnect(mayBeConnection)\n            .tap(() => { debug('connection destroy'); });\n        },\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        testOnBorrow: true,\n        returnToHead: true,\n        autostart: false,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    let reads = 0;\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = _.map(config.replication.read, readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          return this.pool.read.release(client);\n        } else {\n          return this.pool.write.release(client);\n        }\n      },\n      acquire: (priority, queryType, useMaster) => {\n        useMaster = _.isUndefined(useMaster) ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire(priority)\n            .then(mayBeConnection => this._determineConnection(mayBeConnection));\n        } else {\n          return this.pool.write.acquire(priority)\n            .then(mayBeConnection => this._determineConnection(mayBeConnection));\n        }\n      },\n      destroy: mayBeConnection => {\n        if (mayBeConnection instanceof Error) {\n          return Promise.resolve();\n        }\n\n        return this.pool[mayBeConnection.queryType].destroy(mayBeConnection)\n          .tap(() => { debug('connection destroy'); });\n      },\n      clear: () => {\n        return Promise.join(\n          this.pool.read.clear(),\n          this.pool.write.clear()\n        ).tap(() => { debug('all connection clear'); });\n      },\n      drain: () => {\n        return Promise.join(\n          this.pool.write.drain(),\n          this.pool.read.drain()\n        );\n      },\n      read: Pooling.createPool({\n        create: () => {\n          const nextRead = reads++ % config.replication.read.length; // round robin config\n          return this\n            ._connect(config.replication.read[nextRead])\n            .tap(connection => {\n              connection.queryType = 'read';\n            })\n            .catch(err => err);\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        testOnBorrow: true,\n        returnToHead: true,\n        autostart: false,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      }),\n      write: Pooling.createPool({\n        create: () => {\n          return this\n            ._connect(config.replication.write)\n            .tap(connection => {\n              connection.queryType = 'write';\n            })\n            .catch(err => err);\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate\n      }, {\n        Promise: config.pool.Promise,\n        testOnBorrow: true,\n        returnToHead: true,\n        autostart: false,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        evictionRunIntervalMillis: config.pool.evict\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {Integer}  [options.priority]        Set priority for this call. Read more at https://github.com/coopernurse/node-pool#priority-queueing\n   * @param {String}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {Boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @return {Promise<Connection>}\n   */\n  getConnection(options) {\n    options = options || {};\n\n    let promise;\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config)\n          .then(connection => {\n            const _options = {};\n\n            _options.transaction = {connection}; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            return this.sequelize.databaseVersion(_options).then(version => {\n              this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.defaultVersion;\n              this.versionPromise = null;\n\n              return this._disconnect(connection);\n            });\n          }).catch(err => {\n            this.versionPromise = null;\n            throw err;\n          });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.priority, options.type, options.useMaster)\n        .then(mayBeConnection => this._determineConnection(mayBeConnection))\n        .tap(() => { debug('connection acquired'); });\n    });\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @return {Promise}\n   */\n  releaseConnection(connection) {\n    return this.pool.release(connection)\n      .tap(() => { debug('connection released'); })\n      .catch(/Resource not currently part of this pool/, () => {});\n  }\n\n  /**\n   * Check if something acquired by pool is indeed a connection but not an Error instance\n   * Why we need to do this https://github.com/sequelize/sequelize/pull/8330\n   *\n   * @param {Object|Error} mayBeConnection Object which can be either connection or error\n   *\n   * @return {Promise<Connection>}\n   */\n  _determineConnection(mayBeConnection) {\n    if (mayBeConnection instanceof Error) {\n      return Promise.resolve(this.pool.destroy(mayBeConnection))\n        .catch(/Resource not currently part of this pool/, () => {})\n        .then(() => { throw mayBeConnection; });\n    }\n\n    return Promise.resolve(mayBeConnection);\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @return {Promise<Connection>}\n   */\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config)\n      .then(() => this.dialect.connectionManager.connect(config))\n      .then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @return {Promise}\n   */\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @return {Boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}