{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _jsbi = _interopRequireDefault(require(\"jsbi\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nconst UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nconst ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n/**\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\n\nclass WritableTrackingBuffer {\n  constructor(initialSize, encoding, doubleSizeGrowth) {\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  }\n\n  get data() {\n    this.newBuffer(0);\n    return this.compositeBuffer;\n  }\n\n  copyFrom(buffer) {\n    const length = buffer.length;\n    this.makeRoomFor(length);\n    buffer.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  makeRoomFor(requiredLength) {\n    if (this.buffer.length - this.position < requiredLength) {\n      if (this.doubleSizeGrowth) {\n        let size = Math.max(128, this.buffer.length * 2);\n\n        while (size < requiredLength) {\n          size *= 2;\n        }\n\n        this.newBuffer(size);\n      } else {\n        this.newBuffer(requiredLength);\n      }\n    }\n  }\n\n  newBuffer(size) {\n    const buffer = this.buffer.slice(0, this.position);\n    this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n    this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n    this.position = 0;\n  }\n\n  writeUInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeUShort(value) {\n    this.writeUInt16LE(value);\n  }\n\n  writeUInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt24LE(value) {\n    const length = 3;\n    this.makeRoomFor(length);\n    this.buffer[this.position + 2] = value >>> 16 & 0xff;\n    this.buffer[this.position + 1] = value >>> 8 & 0xff;\n    this.buffer[this.position] = value & 0xff;\n    this.position += length;\n  }\n\n  writeUInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeBigInt64LE(value) {\n    this.writeBigU_Int64LE(value);\n  }\n\n  writeBigU_Int64LE(value) {\n    this.makeRoomFor(8);\n\n    let lo = _jsbi.default.toNumber(_jsbi.default.bitwiseAnd(value, _jsbi.default.BigInt(0xffffffff)));\n\n    this.buffer[this.position++] = lo;\n    lo = lo >> 8;\n    this.buffer[this.position++] = lo;\n    lo = lo >> 8;\n    this.buffer[this.position++] = lo;\n    lo = lo >> 8;\n    this.buffer[this.position++] = lo;\n\n    let hi = _jsbi.default.toNumber(_jsbi.default.bitwiseAnd(_jsbi.default.signedRightShift(value, _jsbi.default.BigInt(32)), _jsbi.default.BigInt(0xffffffff)));\n\n    this.buffer[this.position++] = hi;\n    hi = hi >> 8;\n    this.buffer[this.position++] = hi;\n    hi = hi >> 8;\n    this.buffer[this.position++] = hi;\n    hi = hi >> 8;\n    this.buffer[this.position++] = hi;\n  }\n\n  writeInt64LE(value) {\n    this.writeBigInt64LE(_jsbi.default.BigInt(value));\n  }\n\n  writeUInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt40LE(value) {\n    // inspired by https://github.com/dpw/node-buffer-more-ints\n    this.writeInt32LE(value & -1);\n    this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n  }\n\n  writeUInt64LE(value) {\n    this.writeBigUInt64LE(_jsbi.default.BigInt(value));\n  }\n\n  writeBigUInt64LE(value) {\n    this.writeBigU_Int64LE(value);\n  }\n\n  writeInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeFloatLE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeFloatLE(value, this.position);\n    this.position += length;\n  }\n\n  writeDoubleLE(value) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeDoubleLE(value, this.position);\n    this.position += length;\n  }\n\n  writeString(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    const length = Buffer.byteLength(value, encoding);\n    this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n    this.buffer.write(value, this.position, encoding);\n    this.position += length;\n  }\n\n  writeBVarchar(value, encoding) {\n    this.writeUInt8(value.length);\n    this.writeString(value, encoding);\n  }\n\n  writeUsVarchar(value, encoding) {\n    this.writeUInt16LE(value.length);\n    this.writeString(value, encoding);\n  } // TODO: Figure out what types are passed in other than `Buffer`\n\n\n  writeUsVarbyte(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n\n    this.writeUInt16LE(length);\n\n    if (value instanceof Buffer) {\n      this.writeBuffer(value);\n    } else {\n      this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }\n\n  writePLPBody(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    } // Length of all chunks.\n    // this.writeUInt64LE(length);\n    // unknown seems to work better here - might revisit later.\n\n\n    this.writeBuffer(UNKNOWN_PLP_LEN); // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n\n    if (length > 0) {\n      // One chunk.\n      this.writeUInt32LE(length);\n\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length);\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    } // PLP_TERMINATOR (no more chunks).\n\n\n    this.writeUInt32LE(0);\n  }\n\n  writeBuffer(value) {\n    const length = value.length;\n    this.makeRoomFor(length);\n    value.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  writeMoney(value) {\n    this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    this.writeInt32LE(value & -1);\n  }\n\n}\n\nvar _default = WritableTrackingBuffer;\nexports.default = _default;\nmodule.exports = WritableTrackingBuffer;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js"],"names":["Object","defineProperty","exports","value","default","_jsbi","_interopRequireDefault","require","obj","__esModule","SHIFT_LEFT_32","SHIFT_RIGHT_32","UNKNOWN_PLP_LEN","Buffer","from","ZERO_LENGTH_BUFFER","alloc","WritableTrackingBuffer","constructor","initialSize","encoding","doubleSizeGrowth","buffer","compositeBuffer","position","data","newBuffer","copyFrom","length","makeRoomFor","copy","requiredLength","size","Math","max","slice","concat","writeUInt8","writeUInt16LE","writeUShort","writeUInt16BE","writeUInt24LE","writeUInt32LE","writeBigInt64LE","writeBigU_Int64LE","lo","toNumber","bitwiseAnd","BigInt","hi","signedRightShift","writeInt64LE","writeUInt32BE","writeUInt40LE","writeInt32LE","floor","writeUInt64LE","writeBigUInt64LE","writeInt8","writeInt16LE","writeInt16BE","writeInt32BE","writeFloatLE","writeDoubleLE","writeString","byteLength","write","writeBVarchar","writeUsVarchar","writeUsVarbyte","toString","writeBuffer","writePLPBody","writeMoney","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _jsbi = _interopRequireDefault(require(\"jsbi\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nconst UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nconst ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n\n/**\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\nclass WritableTrackingBuffer {\n  constructor(initialSize, encoding, doubleSizeGrowth) {\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  }\n\n  get data() {\n    this.newBuffer(0);\n    return this.compositeBuffer;\n  }\n\n  copyFrom(buffer) {\n    const length = buffer.length;\n    this.makeRoomFor(length);\n    buffer.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  makeRoomFor(requiredLength) {\n    if (this.buffer.length - this.position < requiredLength) {\n      if (this.doubleSizeGrowth) {\n        let size = Math.max(128, this.buffer.length * 2);\n\n        while (size < requiredLength) {\n          size *= 2;\n        }\n\n        this.newBuffer(size);\n      } else {\n        this.newBuffer(requiredLength);\n      }\n    }\n  }\n\n  newBuffer(size) {\n    const buffer = this.buffer.slice(0, this.position);\n    this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n    this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n    this.position = 0;\n  }\n\n  writeUInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeUShort(value) {\n    this.writeUInt16LE(value);\n  }\n\n  writeUInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt24LE(value) {\n    const length = 3;\n    this.makeRoomFor(length);\n    this.buffer[this.position + 2] = value >>> 16 & 0xff;\n    this.buffer[this.position + 1] = value >>> 8 & 0xff;\n    this.buffer[this.position] = value & 0xff;\n    this.position += length;\n  }\n\n  writeUInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeBigInt64LE(value) {\n    this.writeBigU_Int64LE(value);\n  }\n\n  writeBigU_Int64LE(value) {\n    this.makeRoomFor(8);\n\n    let lo = _jsbi.default.toNumber(_jsbi.default.bitwiseAnd(value, _jsbi.default.BigInt(0xffffffff)));\n\n    this.buffer[this.position++] = lo;\n    lo = lo >> 8;\n    this.buffer[this.position++] = lo;\n    lo = lo >> 8;\n    this.buffer[this.position++] = lo;\n    lo = lo >> 8;\n    this.buffer[this.position++] = lo;\n\n    let hi = _jsbi.default.toNumber(_jsbi.default.bitwiseAnd(_jsbi.default.signedRightShift(value, _jsbi.default.BigInt(32)), _jsbi.default.BigInt(0xffffffff)));\n\n    this.buffer[this.position++] = hi;\n    hi = hi >> 8;\n    this.buffer[this.position++] = hi;\n    hi = hi >> 8;\n    this.buffer[this.position++] = hi;\n    hi = hi >> 8;\n    this.buffer[this.position++] = hi;\n  }\n\n  writeInt64LE(value) {\n    this.writeBigInt64LE(_jsbi.default.BigInt(value));\n  }\n\n  writeUInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt40LE(value) {\n    // inspired by https://github.com/dpw/node-buffer-more-ints\n    this.writeInt32LE(value & -1);\n    this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n  }\n\n  writeUInt64LE(value) {\n    this.writeBigUInt64LE(_jsbi.default.BigInt(value));\n  }\n\n  writeBigUInt64LE(value) {\n    this.writeBigU_Int64LE(value);\n  }\n\n  writeInt8(value) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16LE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16BE(value) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32LE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32BE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeFloatLE(value) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeFloatLE(value, this.position);\n    this.position += length;\n  }\n\n  writeDoubleLE(value) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeDoubleLE(value, this.position);\n    this.position += length;\n  }\n\n  writeString(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    const length = Buffer.byteLength(value, encoding);\n    this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n    this.buffer.write(value, this.position, encoding);\n    this.position += length;\n  }\n\n  writeBVarchar(value, encoding) {\n    this.writeUInt8(value.length);\n    this.writeString(value, encoding);\n  }\n\n  writeUsVarchar(value, encoding) {\n    this.writeUInt16LE(value.length);\n    this.writeString(value, encoding);\n  } // TODO: Figure out what types are passed in other than `Buffer`\n\n\n  writeUsVarbyte(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n\n    this.writeUInt16LE(length);\n\n    if (value instanceof Buffer) {\n      this.writeBuffer(value);\n    } else {\n      this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }\n\n  writePLPBody(value, encoding) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    } // Length of all chunks.\n    // this.writeUInt64LE(length);\n    // unknown seems to work better here - might revisit later.\n\n\n    this.writeBuffer(UNKNOWN_PLP_LEN); // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n\n    if (length > 0) {\n      // One chunk.\n      this.writeUInt32LE(length);\n\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length);\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    } // PLP_TERMINATOR (no more chunks).\n\n\n    this.writeUInt32LE(0);\n  }\n\n  writeBuffer(value) {\n    const length = value.length;\n    this.makeRoomFor(length);\n    value.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  writeMoney(value) {\n    this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    this.writeInt32LE(value & -1);\n  }\n\n}\n\nvar _default = WritableTrackingBuffer;\nexports.default = _default;\nmodule.exports = WritableTrackingBuffer;"]},"metadata":{},"sourceType":"script"}