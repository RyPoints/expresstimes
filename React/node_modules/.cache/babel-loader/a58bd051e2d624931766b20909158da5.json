{"ast":null,"code":"'use strict';\n\nconst Utils = require('./../utils');\n\nconst Helpers = require('./helpers');\n\nconst _ = require('lodash');\n\nconst Association = require('./base');\n\nconst Op = require('../operators');\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\n\n\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = 'HasMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = options.through;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n    /*\n    * If self association, this is the target association\n    */\n\n\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    /*\n    * Foreign key setup\n    */\n\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelizeIf([Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored), this.source.primaryKeyAttribute].join('_'), !this.source.options.underscored);\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n\n    if (this.target.rawAttributes[this.sourceKey]) {\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyField = this.sourceKey;\n    }\n\n    if (this.source.fieldRawAttributesMap[this.sourceKey]) {\n      this.sourceKeyAttribute = this.source.fieldRawAttributesMap[this.sourceKey].fieldName;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n    }\n\n    this.sourceIdentifier = this.sourceKey;\n    this.associationAccessor = this.as; // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n\n    const plural = Utils.uppercaseFirst(this.options.name.plural);\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n    this.accessors = {\n      get: 'get' + plural,\n      set: 'set' + plural,\n      addMultiple: 'add' + plural,\n      add: 'add' + singular,\n      create: 'create' + singular,\n      remove: 'remove' + singular,\n      removeMultiple: 'remove' + plural,\n      hasSingle: 'has' + singular,\n      hasAll: 'has' + plural,\n      count: 'count' + plural\n    };\n  } // the id is in the target table\n  // or in an extra table which connects two tables\n\n\n  injectAttributes() {\n    const newAttributes = {};\n\n    const constraintOptions = _.clone(this.options); // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findAll}  for a full explanation of options\n   * @return {Promise<Array<Model>>}\n   */\n\n\n  get(instances, options) {\n    const association = this;\n    const where = {};\n    let Model = association.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    options = Utils.cloneDeep(options) || {};\n\n    if (association.scope) {\n      _.assign(where, association.scope);\n    }\n\n    if (instances) {\n      values = instances.map(instance => instance.get(association.sourceKey, {\n        raw: true\n      }));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: association,\n          values\n        };\n        delete options.limit;\n      } else {\n        where[association.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[association.foreignKey] = instance.get(association.sourceKey, {\n        raw: true\n      });\n    }\n\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return Model.findAll(options).then(results => {\n      if (instance) return results;\n      const result = {};\n\n      for (const instance of instances) {\n        result[instance.get(association.sourceKey, {\n          raw: true\n        })] = [];\n      }\n\n      for (const instance of results) {\n        result[instance.get(association.foreignKey, {\n          raw: true\n        })].push(instance);\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @return {Promise<Integer>}\n   */\n\n\n  count(instance, options) {\n    const association = this;\n    const model = association.target;\n    const sequelize = model.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [[sequelize.fn('COUNT', sequelize.col(model.name.concat('.', model.primaryKeyField))), 'count']];\n    options.raw = true;\n    options.plain = true;\n    return association.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n  /**\n   * Check if one or more rows are associated with `this`.\n   *\n   * @param {Model[]|Model|string[]|String|number[]|Number} [instance(s)]\n   * @param {Object} [options] Options passed to getAssociations\n   * @return {Promise}\n   */\n\n\n  has(sourceInstance, targetInstances, options) {\n    const association = this;\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = _.assign({}, options, {\n      scope: false,\n      raw: true\n    });\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof association.target) {\n        return instance.where();\n      } else {\n        const _where = {};\n        _where[association.target.primaryKeyAttribute] = instance;\n        return _where;\n      }\n    });\n    options.where = {\n      [Op.and]: [where, options.where]\n    };\n    return association.get(sourceInstance, options).then(associatedObjects => associatedObjects.length === targetInstances.length);\n  }\n  /**\n   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n   *\n   * @param {Array<Model|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {Object} [options] Options passed to `target.findAll` and `update`.\n   * @param {Object} [options.validate] Run validation for the join model\n   * @return {Promise}\n   */\n\n\n  set(sourceInstance, targetInstances, options) {\n    const association = this;\n\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = association.toInstanceArray(targetInstances);\n    }\n\n    return association.get(sourceInstance, _.defaults({\n      scope: false,\n      raw: true\n    }, options)).then(oldAssociations => {\n      const promises = [];\n      const obsoleteAssociations = oldAssociations.filter(old => !_.find(targetInstances, obj => obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute]));\n      const unassociatedObjects = targetInstances.filter(obj => !_.find(oldAssociations, old => obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute]));\n      let updateWhere;\n      let update;\n\n      if (obsoleteAssociations.length > 0) {\n        update = {};\n        update[association.foreignKey] = null;\n        updateWhere = {};\n        updateWhere[association.target.primaryKeyAttribute] = obsoleteAssociations.map(associatedObject => associatedObject[association.target.primaryKeyAttribute]);\n        promises.push(association.target.unscoped().update(update, _.defaults({\n          where: updateWhere\n        }, options)));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        updateWhere = {};\n        update = {};\n        update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n\n        _.assign(update, association.scope);\n\n        updateWhere[association.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject => unassociatedObject[association.target.primaryKeyAttribute]);\n        promises.push(association.target.unscoped().update(update, _.defaults({\n          where: updateWhere\n        }, options)));\n      }\n\n      return Utils.Promise.all(promises).return(sourceInstance);\n    });\n  }\n  /**\n   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n   * or a mixed array of Model / string / numbers to associate multiple rows.\n   *\n   * @param {Model[]|Model|string[]|string|number[]|number} [newAssociation(s)]\n   * @param {Object} [options] Options passed to `target.update`.\n   * @return {Promise}\n   */\n\n\n  add(sourceInstance, targetInstances, options) {\n    if (!targetInstances) return Utils.Promise.resolve();\n    const association = this;\n    const update = {};\n    const where = {};\n    options = options || {};\n    targetInstances = association.toInstanceArray(targetInstances);\n    update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n\n    _.assign(update, association.scope);\n\n    where[association.target.primaryKeyAttribute] = targetInstances.map(unassociatedObject => unassociatedObject.get(association.target.primaryKeyAttribute));\n    return association.target.unscoped().update(update, _.defaults({\n      where\n    }, options)).return(sourceInstance);\n  }\n  /**\n   * Un-associate one or several target rows.\n   *\n   * @param {Model[]|Model|String[]|string|Number[]|number} [oldAssociatedInstance(s)]\n   * @param {Object} [options] Options passed to `target.update`\n   * @return {Promise}\n   */\n\n\n  remove(sourceInstance, targetInstances, options) {\n    const association = this;\n    const update = {};\n    const where = {};\n    options = options || {};\n    targetInstances = association.toInstanceArray(targetInstances);\n    update[association.foreignKey] = null;\n    where[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    where[association.target.primaryKeyAttribute] = targetInstances.map(targetInstance => targetInstance.get(association.target.primaryKeyAttribute));\n    return association.target.unscoped().update(update, _.defaults({\n      where\n    }, options)).return(this);\n  }\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to `target.create`.\n   * @return {Promise}\n   */\n\n\n  create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === undefined) {\n      values = {};\n    }\n\n    if (association.scope) {\n      for (const attribute of Object.keys(association.scope)) {\n        values[attribute] = association.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    if (options.fields) options.fields.push(association.foreignKey);\n    return association.target.create(values, options);\n  }\n\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/associations/has-many.js"],"names":["Utils","require","Helpers","_","Association","Op","HasMany","constructor","source","target","options","associationType","targetAssociation","sequelize","through","isMultiAssociation","foreignKeyAttribute","Error","isSelfAssociation","as","isAliased","isPlainObject","name","plural","singular","singularize","isObject","foreignKey","fieldName","camelizeIf","underscoredIf","underscored","primaryKeyAttribute","join","rawAttributes","identifierField","field","foreignKeyField","sourceKey","sourceKeyField","fieldRawAttributesMap","sourceKeyAttribute","sourceIdentifier","associationAccessor","uppercaseFirst","accessors","get","set","addMultiple","add","create","remove","removeMultiple","hasSingle","hasAll","count","injectAttributes","newAttributes","constraintOptions","clone","defaults","type","keyType","allowNull","constraints","onDelete","onUpdate","addForeignKeyConstraints","mergeDefaults","refreshAttributes","checkNamingCollision","mixin","obj","methods","aliases","mixinMethods","instances","association","where","Model","instance","values","Array","isArray","undefined","cloneDeep","scope","assign","map","raw","limit","length","groupedLimit","on","in","and","hasOwnProperty","unscoped","schema","schemaDelimiter","findAll","then","results","result","push","model","attributes","fn","col","concat","primaryKeyField","plain","parseInt","has","sourceInstance","targetInstances","or","_where","associatedObjects","toInstanceArray","oldAssociations","promises","obsoleteAssociations","filter","old","find","unassociatedObjects","updateWhere","update","associatedObject","unassociatedObject","Promise","all","return","resolve","targetInstance","fields","attribute","Object","keys","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = options.through;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n\n    /*\n    * If self association, this is the target association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    /*\n    * Foreign key setup\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelizeIf(\n        [\n          Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored),\n          this.source.primaryKeyAttribute\n        ].join('_'),\n        !this.source.options.underscored\n      );\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    if (this.target.rawAttributes[this.sourceKey]) {\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyField = this.sourceKey;\n    }\n\n    if (this.source.fieldRawAttributesMap[this.sourceKey]) {\n      this.sourceKeyAttribute = this.source.fieldRawAttributesMap[this.sourceKey].fieldName;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n    }\n    this.sourceIdentifier = this.sourceKey;\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = Utils.uppercaseFirst(this.options.name.plural);\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: 'get' + plural,\n      set: 'set' + plural,\n      addMultiple: 'add' + plural,\n      add: 'add' + singular,\n      create: 'create' + singular,\n      remove: 'remove' + singular,\n      removeMultiple: 'remove' + plural,\n      hasSingle: 'has' + singular,\n      hasAll: 'has' + plural,\n      count: 'count' + plural\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  injectAttributes() {\n    const newAttributes = {};\n    const constraintOptions = _.clone(this.options); // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findAll}  for a full explanation of options\n   * @return {Promise<Array<Model>>}\n   */\n  get(instances, options) {\n    const association = this;\n    const where = {};\n    let Model = association.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    options = Utils.cloneDeep(options) || {};\n\n    if (association.scope) {\n      _.assign(where, association.scope);\n    }\n\n    if (instances) {\n      values = instances.map(instance => instance.get(association.sourceKey, {raw: true}));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: association,\n          values\n        };\n\n        delete options.limit;\n      } else {\n        where[association.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[association.foreignKey] = instance.get(association.sourceKey, {raw: true});\n    }\n\n\n    options.where = options.where ?\n      {[Op.and]: [where, options.where]} :\n      where;\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n\n    return Model.findAll(options).then(results => {\n      if (instance) return results;\n\n      const result = {};\n      for (const instance of instances) {\n        result[instance.get(association.sourceKey, {raw: true})] = [];\n      }\n\n      for (const instance of results) {\n        result[instance.get(association.foreignKey, {raw: true})].push(instance);\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @return {Promise<Integer>}\n   */\n  count(instance, options) {\n    const association = this;\n    const model = association.target;\n    const sequelize = model.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col(model.name.concat('.', model.primaryKeyField))), 'count']\n    ];\n    options.raw = true;\n    options.plain = true;\n\n    return association.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n\n  /**\n   * Check if one or more rows are associated with `this`.\n   *\n   * @param {Model[]|Model|string[]|String|number[]|Number} [instance(s)]\n   * @param {Object} [options] Options passed to getAssociations\n   * @return {Promise}\n   */\n  has(sourceInstance, targetInstances, options) {\n    const association = this;\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = _.assign({}, options, {\n      scope: false,\n      raw: true\n    });\n\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof association.target) {\n        return instance.where();\n      } else {\n        const _where = {};\n        _where[association.target.primaryKeyAttribute] = instance;\n        return _where;\n      }\n    });\n\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n\n    return association.get(sourceInstance, options).then(associatedObjects => associatedObjects.length === targetInstances.length);\n  }\n\n  /**\n   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n   *\n   * @param {Array<Model|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {Object} [options] Options passed to `target.findAll` and `update`.\n   * @param {Object} [options.validate] Run validation for the join model\n   * @return {Promise}\n   */\n  set(sourceInstance, targetInstances, options) {\n    const association = this;\n\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = association.toInstanceArray(targetInstances);\n    }\n\n    return association.get(sourceInstance, _.defaults({scope: false, raw: true}, options)).then(oldAssociations => {\n      const promises = [];\n      const obsoleteAssociations = oldAssociations.filter(old =>\n        !_.find(targetInstances, obj =>\n          obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute]\n        )\n      );\n      const unassociatedObjects = targetInstances.filter(obj =>\n        !_.find(oldAssociations, old =>\n          obj[association.target.primaryKeyAttribute] === old[association.target.primaryKeyAttribute]\n        )\n      );\n      let updateWhere;\n      let update;\n\n      if (obsoleteAssociations.length > 0) {\n        update = {};\n        update[association.foreignKey] = null;\n\n        updateWhere = {};\n\n        updateWhere[association.target.primaryKeyAttribute] = obsoleteAssociations.map(associatedObject =>\n          associatedObject[association.target.primaryKeyAttribute]\n        );\n\n        promises.push(association.target.unscoped().update(\n          update,\n          _.defaults({\n            where: updateWhere\n          }, options)\n        ));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        updateWhere = {};\n\n        update = {};\n        update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n\n        _.assign(update, association.scope);\n        updateWhere[association.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>\n          unassociatedObject[association.target.primaryKeyAttribute]\n        );\n\n        promises.push(association.target.unscoped().update(\n          update,\n          _.defaults({\n            where: updateWhere\n          }, options)\n        ));\n      }\n\n      return Utils.Promise.all(promises).return(sourceInstance);\n    });\n  }\n\n  /**\n   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n   * or a mixed array of Model / string / numbers to associate multiple rows.\n   *\n   * @param {Model[]|Model|string[]|string|number[]|number} [newAssociation(s)]\n   * @param {Object} [options] Options passed to `target.update`.\n   * @return {Promise}\n   */\n  add(sourceInstance, targetInstances, options) {\n    if (!targetInstances) return Utils.Promise.resolve();\n\n    const association = this;\n    const update = {};\n    const where = {};\n\n    options = options || {};\n\n    targetInstances = association.toInstanceArray(targetInstances);\n\n    update[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    _.assign(update, association.scope);\n\n    where[association.target.primaryKeyAttribute] = targetInstances.map(unassociatedObject =>\n      unassociatedObject.get(association.target.primaryKeyAttribute)\n    );\n\n    return association.target.unscoped().update(update, _.defaults({where}, options)).return(sourceInstance);\n  }\n\n  /**\n   * Un-associate one or several target rows.\n   *\n   * @param {Model[]|Model|String[]|string|Number[]|number} [oldAssociatedInstance(s)]\n   * @param {Object} [options] Options passed to `target.update`\n   * @return {Promise}\n   */\n  remove(sourceInstance, targetInstances, options) {\n    const association = this;\n    const update = {};\n    const where = {};\n\n    options = options || {};\n    targetInstances = association.toInstanceArray(targetInstances);\n\n    update[association.foreignKey] = null;\n\n    where[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    where[association.target.primaryKeyAttribute] = targetInstances.map(targetInstance =>\n      targetInstance.get(association.target.primaryKeyAttribute)\n    );\n\n    return association.target.unscoped().update(update, _.defaults({where}, options)).return(this);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to `target.create`.\n   * @return {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === undefined) {\n      values = {};\n    }\n\n    if (association.scope) {\n      for (const attribute of Object.keys(association.scope)) {\n        values[attribute] = association.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[association.foreignKey] = sourceInstance.get(association.sourceKey);\n    if (options.fields) options.fields.push(association.foreignKey);\n    return association.target.create(values, options);\n  }\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;\n"]},"metadata":{},"sourceType":"script"}