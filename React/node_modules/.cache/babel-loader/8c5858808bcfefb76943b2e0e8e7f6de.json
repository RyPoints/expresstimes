{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst util = require('util');\n\nconst Op = require('../../operators');\n\nconst QueryGenerator = {\n  __proto__: AbstractQueryGenerator,\n  dialect: 'mysql',\n  OperatorMap: Object.assign({}, AbstractQueryGenerator.OperatorMap, {\n    [Op.regexp]: 'REGEXP',\n    [Op.notRegexp]: 'NOT REGEXP'\n  }),\n\n  createSchema() {\n    return 'SHOW TABLES';\n  },\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  },\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  },\n\n  createTableQuery(tableName, attributes, options) {\n    options = _.extend({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n    const query = 'CREATE TABLE IF NOT EXISTS <%= table %> (<%= attributes%>) ENGINE=<%= engine %><%= comment %><%= charset %><%= collation %><%= initialAutoIncrement %><%= rowFormat %>';\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (attributes.hasOwnProperty(attr)) {\n        const dataType = attributes[attr];\n        let match;\n\n        if (_.includes(dataType, 'PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (_.includes(dataType, 'REFERENCES')) {\n            // MySQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1].replace(/PRIMARY KEY/, ''));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType.replace(/PRIMARY KEY/, ''));\n          }\n        } else if (_.includes(dataType, 'REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1]);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType);\n        }\n      }\n    }\n\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(', '),\n      comment: options.comment && _.isString(options.comment) ? ' COMMENT ' + this.escape(options.comment) : '',\n      engine: options.engine,\n      charset: options.charset ? ' DEFAULT CHARSET=' + options.charset : '',\n      collation: options.collate ? ' COLLATE ' + options.collate : '',\n      rowFormat: options.rowFormat ? ' ROW_FORMAT=' + options.rowFormat : '',\n      initialAutoIncrement: options.initialAutoIncrement ? ' AUTO_INCREMENT=' + options.initialAutoIncrement : ''\n    };\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = 'uniq_' + tableName + '_' + columns.fields.join('_');\n          }\n\n          values.attributes += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (foreignKeys.hasOwnProperty(fkey)) {\n        values.attributes += ', FOREIGN KEY (' + this.quoteIdentifier(fkey) + ') ' + foreignKeys[fkey];\n      }\n    }\n\n    return _.template(query, this._templateSettings)(values).trim() + ';';\n  },\n\n  showTablesQuery() {\n    return 'SHOW TABLES;';\n  },\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  },\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  },\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n\n      if (definition.match(/REFERENCES/)) {\n        const fkName = this.quoteIdentifier(tableName + '_' + attributeName + '_foreign_idx');\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`${fkName} FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push('`' + attributeName + '` `' + attributeName + '` ' + definition);\n      }\n    }\n\n    let finalQuery = '';\n\n    if (attrString.length) {\n      finalQuery += 'CHANGE ' + attrString.join(', ');\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n\n    if (constraintString.length) {\n      finalQuery += 'ADD CONSTRAINT ' + constraintString.join(', ');\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  },\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push('`' + attrBefore + '` `' + attrName + '` ' + definition);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  },\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = _.map(this.parseConditionObject(smth.conditions), condition => `${this.quoteIdentifier(_.first(condition.path))}->>'\\$.${_.tail(condition.path).join('.')}' = '${condition.value}'`);\n\n        return conditions.join(' and ');\n      } else if (smth.path) {\n        let str; // Allow specifying conditions using the sqlite json functions\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json dot notation\n          let path = smth.path;\n          let startWithDot = true; // Convert .number. to [number].\n\n          path = path.replace(/\\.(\\d+)\\./g, '[$1].'); // Convert .number$ to [number]\n\n          path = path.replace(/\\.(\\d+)$/, '[$1]');\n          path = path.split('.');\n          let columnName = path.shift();\n          const match = columnName.match(/\\[\\d+\\]$/); // If columnName ends with [\\d+]\n\n          if (match !== null) {\n            path.unshift(columnName.substr(match.index));\n            columnName = columnName.substr(0, match.index);\n            startWithDot = false;\n          }\n\n          str = `${this.quoteIdentifier(columnName)}->>'\\$${startWithDot ? '.' : ''}${path.join('.')}'`;\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  },\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    } // null is stored as a string in mysql\n\n\n    if (value === null) {\n      return 'null';\n    }\n\n    return value;\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return key + '=VALUES(' + key + ')';\n    }).join(', ');\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  },\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    const table = this.quoteTable(tableName);\n\n    if (options.truncate === true) {\n      // Truncate does not allow LIMIT and WHERE\n      return 'TRUNCATE ' + table;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n    let limit = '';\n\n    if (_.isUndefined(options.limit)) {\n      options.limit = 1;\n    }\n\n    if (options.limit) {\n      limit = ' LIMIT ' + this.escape(options.limit);\n    }\n\n    let query = 'DELETE FROM ' + table;\n    if (where) query += ' WHERE ' + where;\n    query += limit;\n    return query;\n  },\n\n  showIndexesQuery(tableName, options) {\n    return 'SHOW INDEX FROM ' + this.quoteTable(tableName) + ((options || {}).database ? ' FROM `' + options.database + '`' : '');\n  },\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = ['SELECT CONSTRAINT_CATALOG AS constraintCatalog,', 'CONSTRAINT_NAME AS constraintName,', 'CONSTRAINT_SCHEMA AS constraintSchema,', 'CONSTRAINT_TYPE AS constraintType,', 'TABLE_NAME AS tableName,', 'TABLE_SCHEMA AS tableSchema', 'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS', `WHERE table_name='${tableName}'`].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    if (schemaName) {\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\n    }\n\n    return sql + ';';\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  },\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    } // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n\n\n    if (!_.includes(['BLOB', 'TEXT', 'GEOMETRY', 'JSON'], attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' DEFAULT ' + this.escape(attribute.defaultValue);\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n\n    if (attribute.after) {\n      template += ' AFTER ' + this.quoteIdentifier(attribute.after);\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ' REFERENCES ' + this.quoteTable(attribute.references.model);\n\n      if (attribute.references.key) {\n        template += ' (' + this.quoteIdentifier(attribute.references.key) + ')';\n      } else {\n        template += ' (' + this.quoteIdentifier('id') + ')';\n      }\n\n      if (attribute.onDelete) {\n        template += ' ON DELETE ' + attribute.onDelete.toUpperCase();\n      }\n\n      if (attribute.onUpdate) {\n        template += ' ON UPDATE ' + attribute.onUpdate.toUpperCase();\n      }\n    }\n\n    return template;\n  },\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  },\n\n  quoteIdentifier(identifier) {\n    if (identifier === '*') return identifier;\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  },\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {String}  stmt  The statement to validate\n   * @returns {Boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (!_.isString(stmt)) {\n      return false;\n    }\n\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error('Invalid json statement: ' + stmt);\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  },\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {String}               column  The JSON column\n   * @param   {String|Array<String>} [path]  The path to extract (optional)\n   * @returns {String}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    /**\n     * Sub paths need to be quoted as ECMAScript identifiers\n     *\n     * https://bugs.mysql.com/bug.php?id=81896\n     */\n    const paths = _.toPath(path).map(subPath => Utils.addTicks(subPath, '\"'));\n\n    const pathStr = `${['$'].concat(paths).join('.')}`;\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    return `(${quotedColumn}->>'${pathStr}')`;\n  },\n\n  /**\n   *  Generates fields for getForeignKeysQuery\n   * @returns {String} fields\n   * @private\n   */\n  _getForeignKeysQueryFields() {\n    return ['CONSTRAINT_NAME as constraint_name', 'CONSTRAINT_NAME as constraintName', 'CONSTRAINT_SCHEMA as constraintSchema', 'CONSTRAINT_SCHEMA as constraintCatalog', 'TABLE_NAME as tableName', 'TABLE_SCHEMA as tableSchema', 'TABLE_SCHEMA as tableCatalog', 'COLUMN_NAME as columnName', 'REFERENCED_TABLE_SCHEMA as referencedTableSchema', 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog', 'REFERENCED_TABLE_NAME as referencedTableName', 'REFERENCED_COLUMN_NAME as referencedColumnName'].join(',');\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} schemaName The name of the schema.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName, schemaName) {\n    return 'SELECT ' + this._getForeignKeysQueryFields() + ' FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = \\'' + tableName +\n    /* jshint ignore: line */\n    '\\' AND CONSTRAINT_NAME!=\\'PRIMARY\\' AND CONSTRAINT_SCHEMA=\\'' + schemaName + '\\' AND REFERENCED_TABLE_NAME IS NOT NULL;';\n    /* jshint ignore: line */\n  },\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} columnName The name of the column.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return 'SELECT ' + this._getForeignKeysQueryFields() + ' FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE' + ' WHERE (REFERENCED_TABLE_NAME = ' + wrapSingleQuote(tableName) + (schemaName ? ' AND REFERENCED_TABLE_SCHEMA = ' + wrapSingleQuote(schemaName) : '') + ' AND REFERENCED_COLUMN_NAME = ' + wrapSingleQuote(columnName) + ') OR (TABLE_NAME = ' + wrapSingleQuote(tableName) + (schemaName ? ' AND TABLE_SCHEMA = ' + wrapSingleQuote(schemaName) : '') + ' AND COLUMN_NAME = ' + wrapSingleQuote(columnName) + ' AND REFERENCED_TABLE_NAME IS NOT NULL' + ')';\n  },\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} foreignKey The name of the foreign key constraint.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return 'ALTER TABLE ' + this.quoteTable(tableName) + ' DROP FOREIGN KEY ' + this.quoteIdentifier(foreignKey) + ';';\n  }\n\n}; // private methods\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = QueryGenerator;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/dialects/mysql/query-generator.js"],"names":["_","require","Utils","AbstractQueryGenerator","util","Op","QueryGenerator","__proto__","dialect","OperatorMap","Object","assign","regexp","notRegexp","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","options","extend","engine","charset","rowFormat","query","primaryKeys","foreignKeys","attrStr","attr","hasOwnProperty","dataType","match","includes","push","quoteIdentifier","replace","values","table","quoteTable","join","comment","isString","escape","collation","collate","initialAutoIncrement","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","template","_templateSettings","trim","showTablesQuery","addColumnQuery","key","definition","attributeToSQL","context","foreignKey","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","fkName","attrName","finalQuery","renameColumnQuery","attrBefore","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","first","path","tail","value","str","_checkValidJsonStatement","startWithDot","split","columnName","shift","unshift","substr","index","format","Cast","test","type","json","_toJSONValue","toString","upsertQuery","insertValues","updateValues","where","model","onDuplicate","keys","insertQuery","rawAttributes","deleteQuery","truncate","getWhereConditions","limit","isUndefined","showIndexesQuery","database","showConstraintsQuery","constraintName","schemaName","schema","sql","removeIndexQuery","indexNameOrAttributes","underscore","attribute","isPlainObject","attributeString","bind","allowNull","autoIncrement","_binary","defaultValueSchemable","defaultValue","unique","primaryKey","after","references","onDelete","toUpperCase","onUpdate","attributesToSQL","result","identifier","addTicks","removeTicks","stmt","jsonFunctionRegex","jsonOperatorRegex","tokenCaptureRegex","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","functionMatches","exec","indexOf","operatorMatches","tokenMatches","capturedToken","Error","jsonPathExtractionQuery","column","paths","toPath","subPath","pathStr","concat","quotedColumn","isIdentifierQuoted","_getForeignKeysQueryFields","getForeignKeysQuery","getForeignKeyQuery","wrapSingleQuote","dropForeignKeyQuery","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\nconst QueryGenerator = {\n  __proto__: AbstractQueryGenerator,\n  dialect: 'mysql',\n\n  OperatorMap: Object.assign({}, AbstractQueryGenerator.OperatorMap, {\n    [Op.regexp]: 'REGEXP',\n    [Op.notRegexp]: 'NOT REGEXP'\n  }),\n\n  createSchema() {\n    return 'SHOW TABLES';\n  },\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  },\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  },\n\n  createTableQuery(tableName, attributes, options) {\n    options = _.extend({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n\n    const query = 'CREATE TABLE IF NOT EXISTS <%= table %> (<%= attributes%>) ENGINE=<%= engine %><%= comment %><%= charset %><%= collation %><%= initialAutoIncrement %><%= rowFormat %>';\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (attributes.hasOwnProperty(attr)) {\n        const dataType = attributes[attr];\n        let match;\n\n        if (_.includes(dataType, 'PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (_.includes(dataType, 'REFERENCES')) {\n            // MySQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1].replace(/PRIMARY KEY/, ''));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType.replace(/PRIMARY KEY/, ''));\n          }\n        } else if (_.includes(dataType, 'REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + match[1]);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType);\n        }\n      }\n    }\n\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(', '),\n      comment: options.comment && _.isString(options.comment) ? ' COMMENT ' + this.escape(options.comment) : '',\n      engine: options.engine,\n      charset: options.charset ? ' DEFAULT CHARSET=' + options.charset : '',\n      collation: options.collate ? ' COLLATE ' + options.collate : '',\n      rowFormat: options.rowFormat ? ' ROW_FORMAT=' + options.rowFormat : '',\n      initialAutoIncrement: options.initialAutoIncrement ? ' AUTO_INCREMENT=' + options.initialAutoIncrement : ''\n    };\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = 'uniq_' + tableName + '_' + columns.fields.join('_');\n          }\n          values.attributes += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (foreignKeys.hasOwnProperty(fkey)) {\n        values.attributes += ', FOREIGN KEY (' + this.quoteIdentifier(fkey) + ') ' + foreignKeys[fkey];\n      }\n    }\n\n    return _.template(query, this._templateSettings)(values).trim() + ';';\n  },\n\n  showTablesQuery() {\n    return 'SHOW TABLES;';\n  },\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  },\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  },\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        const fkName = this.quoteIdentifier(tableName + '_' + attributeName + '_foreign_idx');\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`${fkName} FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push('`' + attributeName + '` `' + attributeName + '` ' + definition);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += 'CHANGE ' + attrString.join(', ');\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += 'ADD CONSTRAINT ' + constraintString.join(', ');\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  },\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push('`' + attrBefore + '` `' + attrName + '` ' + definition);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  },\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = _.map(this.parseConditionObject(smth.conditions), condition =>\n          `${this.quoteIdentifier(_.first(condition.path))}->>'\\$.${_.tail(condition.path).join('.')}' = '${condition.value}'`\n        );\n\n        return conditions.join(' and ');\n      } else if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json dot notation\n          let path = smth.path;\n          let startWithDot = true;\n\n          // Convert .number. to [number].\n          path = path.replace(/\\.(\\d+)\\./g, '[$1].');\n          // Convert .number$ to [number]\n          path = path.replace(/\\.(\\d+)$/, '[$1]');\n\n          path = path.split('.');\n\n          let columnName = path.shift();\n          const match = columnName.match(/\\[\\d+\\]$/);\n          // If columnName ends with [\\d+]\n          if (match !== null) {\n            path.unshift(columnName.substr(match.index));\n            columnName = columnName.substr(0, match.index);\n            startWithDot = false;\n          }\n\n          str = `${this.quoteIdentifier(columnName)}->>'\\$${startWithDot ? '.' : ''}${path.join('.')}'`;\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  },\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  },\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return key + '=VALUES(' + key +')';\n    }).join(', ');\n\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  },\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n\n    const table = this.quoteTable(tableName);\n    if (options.truncate === true) {\n      // Truncate does not allow LIMIT and WHERE\n      return 'TRUNCATE ' + table;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n    let limit = '';\n\n    if (_.isUndefined(options.limit)) {\n      options.limit = 1;\n    }\n\n    if (options.limit) {\n      limit = ' LIMIT ' + this.escape(options.limit);\n    }\n\n    let query = 'DELETE FROM ' + table;\n    if (where) query += ' WHERE ' + where;\n    query += limit;\n\n    return query;\n  },\n\n  showIndexesQuery(tableName, options) {\n    return 'SHOW INDEX FROM ' + this.quoteTable(tableName) + ((options || {}).database ? ' FROM `' + options.database + '`' : '');\n  },\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    let sql = [\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`\n    ].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    if (schemaName) {\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\n    }\n\n    return sql + ';';\n  },\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(tableName + '_' + indexNameOrAttributes.join('_'));\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  },\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!_.includes(['BLOB', 'TEXT', 'GEOMETRY', 'JSON'], attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' DEFAULT ' + this.escape(attribute.defaultValue);\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ' AFTER ' + this.quoteIdentifier(attribute.after);\n    }\n\n    if (attribute.references) {\n\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ' REFERENCES ' + this.quoteTable(attribute.references.model);\n\n      if (attribute.references.key) {\n        template += ' (' + this.quoteIdentifier(attribute.references.key) + ')';\n      } else {\n        template += ' (' + this.quoteIdentifier('id') + ')';\n      }\n\n      if (attribute.onDelete) {\n        template += ' ON DELETE ' + attribute.onDelete.toUpperCase();\n      }\n\n      if (attribute.onUpdate) {\n        template += ' ON UPDATE ' + attribute.onUpdate.toUpperCase();\n      }\n    }\n\n    return template;\n  },\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  },\n\n  quoteIdentifier(identifier) {\n    if (identifier === '*') return identifier;\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  },\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {String}  stmt  The statement to validate\n   * @returns {Boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (!_.isString(stmt)) {\n      return false;\n    }\n\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error('Invalid json statement: ' + stmt);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  },\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {String}               column  The JSON column\n   * @param   {String|Array<String>} [path]  The path to extract (optional)\n   * @returns {String}                       The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path) {\n    /**\n     * Sub paths need to be quoted as ECMAScript identifiers\n     *\n     * https://bugs.mysql.com/bug.php?id=81896\n     */\n    const paths = _.toPath(path).map(subPath => Utils.addTicks(subPath, '\"'));\n    const pathStr = `${['$'].concat(paths).join('.')}`;\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    return `(${quotedColumn}->>'${pathStr}')`;\n  },\n\n  /**\n   *  Generates fields for getForeignKeysQuery\n   * @returns {String} fields\n   * @private\n   */\n  _getForeignKeysQueryFields() {\n    return [\n      'CONSTRAINT_NAME as constraint_name',\n      'CONSTRAINT_NAME as constraintName',\n      'CONSTRAINT_SCHEMA as constraintSchema',\n      'CONSTRAINT_SCHEMA as constraintCatalog',\n      'TABLE_NAME as tableName',\n      'TABLE_SCHEMA as tableSchema',\n      'TABLE_SCHEMA as tableCatalog',\n      'COLUMN_NAME as columnName',\n      'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n      'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n      'REFERENCED_TABLE_NAME as referencedTableName',\n      'REFERENCED_COLUMN_NAME as referencedColumnName',\n    ].join(',');\n  },\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} schemaName The name of the schema.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName, schemaName) {\n    return 'SELECT ' + this._getForeignKeysQueryFields() + ' FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = \\'' + tableName + /* jshint ignore: line */\n      '\\' AND CONSTRAINT_NAME!=\\'PRIMARY\\' AND CONSTRAINT_SCHEMA=\\'' + schemaName + '\\' AND REFERENCED_TABLE_NAME IS NOT NULL;'; /* jshint ignore: line */\n  },\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} columnName The name of the column.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return 'SELECT ' + this._getForeignKeysQueryFields()\n      + ' FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE'\n      + ' WHERE (REFERENCED_TABLE_NAME = ' + wrapSingleQuote(tableName)\n      + (schemaName ? ' AND REFERENCED_TABLE_SCHEMA = ' + wrapSingleQuote(schemaName): '')\n      + ' AND REFERENCED_COLUMN_NAME = ' + wrapSingleQuote(columnName)\n      + ') OR (TABLE_NAME = ' + wrapSingleQuote(tableName)\n      + (schemaName ? ' AND TABLE_SCHEMA = ' + wrapSingleQuote(schemaName): '')\n      + ' AND COLUMN_NAME = ' + wrapSingleQuote(columnName)\n      + ' AND REFERENCED_TABLE_NAME IS NOT NULL'\n      + ')';\n  },\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {String} tableName  The name of the table.\n   * @param  {String} foreignKey The name of the foreign key constraint.\n   * @return {String}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return 'ALTER TABLE ' + this.quoteTable(tableName) + ' DROP FOREIGN KEY ' + this.quoteIdentifier(foreignKey) + ';';\n  }\n};\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = QueryGenerator;\n"]},"metadata":{},"sourceType":"script"}