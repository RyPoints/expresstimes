{"ast":null,"code":"'use strict'; // Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.  The trailing byte in the\n// section will always be 0x20, or in some implementations 0x00.\n// this module encodes and decodes these things.\n\nconst encode = exports.encode = (num, buf) => {\n  buf[buf.length - 1] = 0x20;\n  if (num < 0) encodeNegative(num, buf);else encodePositive(num, buf);\n  return buf;\n};\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80;\n\n  for (var i = buf.length - 2; i > 0; i--) {\n    if (num === 0) buf[i] = 0;else {\n      buf[i] = num % 0x100;\n      num = Math.floor(num / 0x100);\n    }\n  }\n};\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff;\n  var flipped = false;\n  num = num * -1;\n\n  for (var i = buf.length - 2; i > 0; i--) {\n    var byte;\n    if (num === 0) byte = 0;else {\n      byte = num % 0x100;\n      num = Math.floor(num / 0x100);\n    }\n    if (flipped) buf[i] = onesComp(byte);else if (byte === 0) buf[i] = 0;else {\n      flipped = true;\n      buf[i] = twosComp(byte);\n    }\n  }\n};\n\nconst parse = exports.parse = buf => {\n  var post = buf[buf.length - 1];\n  var pre = buf[0];\n  return pre === 0x80 ? pos(buf.slice(1, buf.length - 1)) : twos(buf.slice(1, buf.length - 1));\n};\n\nconst twos = buf => {\n  var len = buf.length;\n  var sum = 0;\n  var flipped = false;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    var f;\n    if (flipped) f = onesComp(byte);else if (byte === 0) f = byte;else {\n      flipped = true;\n      f = twosComp(byte);\n    }\n    if (f !== 0) sum += f * Math.pow(256, len - i - 1);\n  }\n\n  return sum * -1;\n};\n\nconst pos = buf => {\n  var len = buf.length;\n  var sum = 0;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    if (byte !== 0) sum += byte * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nconst onesComp = byte => (0xff ^ byte) & 0xff;\n\nconst twosComp = byte => (0xff ^ byte) + 1 & 0xff;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/chokidar/node_modules/fsevents/node_modules/tar/lib/large-numbers.js"],"names":["encode","exports","num","buf","length","encodeNegative","encodePositive","i","Math","floor","flipped","byte","onesComp","twosComp","parse","post","pre","pos","slice","twos","len","sum","f","pow"],"mappings":"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","sourcesContent":["'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.  The trailing byte in the\n// section will always be 0x20, or in some implementations 0x00.\n// this module encodes and decodes these things.\n\nconst encode = exports.encode = (num, buf) => {\n  buf[buf.length - 1] = 0x20\n  if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n  for (var i = buf.length - 2; i > 0; i--) {\n    if (num === 0)\n      buf[i] = 0\n    else {\n      buf[i] = num % 0x100\n      num = Math.floor(num / 0x100)\n    }\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length - 2; i > 0; i--) {\n    var byte\n    if (num === 0)\n      byte = 0\n    else {\n      byte = num % 0x100\n      num = Math.floor(num / 0x100)\n    }\n    if (flipped)\n      buf[i] = onesComp(byte)\n    else if (byte === 0)\n      buf[i] = 0\n    else {\n      flipped = true\n      buf[i] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  return pre === 0x80 ? pos(buf.slice(1, buf.length - 1))\n   : twos(buf.slice(1, buf.length - 1))\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum += f * Math.pow(256, len - i - 1)\n  }\n  return sum * -1\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n"]},"metadata":{},"sourceType":"script"}