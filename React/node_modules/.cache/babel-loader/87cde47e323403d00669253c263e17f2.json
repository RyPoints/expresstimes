{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('./utils');\n/**\n * The transaction object is used to identify a running transaction. It is created by calling `Sequelize.transaction()`.\n *\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @see {@link Sequelize.transaction}\n */\n\n\nclass Transaction {\n  /**\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {Object} options An object with options\n   * @param {Boolean} options.autocommit Sets the autocommit property of the transaction.\n   * @param {String} options.type=true Sets the type of the transaction.\n   * @param {String} options.isolationLevel=true Sets the isolation level of the transaction.\n   * @param {String} options.deferrable Sets the constraints to be deferred or immediately checked.\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = []; // get dialect specific transaction options\n\n    const transactionOptions = sequelize.dialect.supports.transactionOptions || {};\n    const generateTransactionId = this.sequelize.dialect.QueryGenerator.generateTransactionId;\n    this.options = _.extend({\n      autocommit: transactionOptions.autocommit || null,\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options || {});\n    this.parent = this.options.transaction;\n    this.id = this.parent ? this.parent.id : generateTransactionId();\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = this.id + '-sp-' + this.parent.savepoints.length;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n  /**\n   * Commit the transaction\n   *\n   * @return {Promise}\n   */\n\n\n  commit() {\n    if (this.finished) {\n      return Utils.Promise.reject(new Error('Transaction cannot be committed because it has been finished with state: ' + this.finished));\n    }\n\n    this._clearCls();\n\n    return this.sequelize.getQueryInterface().commitTransaction(this, this.options).finally(() => {\n      this.finished = 'commit';\n\n      if (!this.parent) {\n        return this.cleanup();\n      }\n\n      return null;\n    }).tap(() => Utils.Promise.each(this._afterCommitHooks, hook => Promise.resolve(hook.apply(this, [this]))));\n  }\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @return {Promise}\n   */\n\n\n  rollback() {\n    if (this.finished) {\n      return Utils.Promise.reject(new Error('Transaction cannot be rolled back because it has been finished with state: ' + this.finished));\n    }\n\n    if (!this.connection) {\n      return Promise.reject(new Error('Transaction cannot be rolled back because it never started'));\n    }\n\n    this._clearCls();\n\n    return this.sequelize.getQueryInterface().rollbackTransaction(this, this.options).finally(() => {\n      if (!this.parent) {\n        return this.cleanup();\n      }\n\n      return this;\n    });\n  }\n\n  prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (typeof useCLS === 'undefined') {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Utils.Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = {\n        uuid: this.id\n      };\n\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    return connectionPromise.then(connection => {\n      this.connection = connection;\n      this.connection.uuid = this.id;\n    }).then(() => {\n      return this.begin().then(() => this.setDeferrable()).then(() => this.setIsolationLevel()).then(() => this.setAutocommit()).catch(setupErr => this.rollback().finally(() => {\n        throw setupErr;\n      }));\n    }).tap(() => {\n      if (useCLS && this.sequelize.constructor._cls) {\n        this.sequelize.constructor._cls.set('transaction', this);\n      }\n\n      return null;\n    });\n  }\n\n  begin() {\n    return this.sequelize.getQueryInterface().startTransaction(this, this.options);\n  }\n\n  setDeferrable() {\n    if (this.options.deferrable) {\n      return this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n    }\n  }\n\n  setAutocommit() {\n    return this.sequelize.getQueryInterface().setAutocommit(this, this.options.autocommit, this.options);\n  }\n\n  setIsolationLevel() {\n    return this.sequelize.getQueryInterface().setIsolationLevel(this, this.options.isolationLevel, this.options);\n  }\n\n  cleanup() {\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n\n\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n\n    this._afterCommitHooks.push(fn);\n  }\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * ```js\n   * return sequelize.transaction({type: Sequelize.Transaction.TYPES.EXCLUSIVE}, transaction => {\n   *\n   *  // your transactions\n   *\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   * ```\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n\n\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n  /**\n   * Isolations levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Default to `REPEATABLE_READ` but you can override the default isolation level by passing `options.isolationLevel` in `new Sequelize`.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * ```js\n   * return sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n  *\n  *  // your transactions\n  *\n  * }).then(result => {\n  *   // transaction has been committed. Do something after the commit if required.\n  * }).catch(err => {\n  *   // do something with the err.\n  * });\n   * ```\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n\n\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * ```js\n   * t1 // is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   * ```\n   *\n   * Postgres also supports specific locks while eager loading by using OF:\n   * ```js\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   * ```\n   * UserModel will be locked but TaskModel won't!\n   *\n   * @return {Object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n\n\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n  /**\n   * @see {@link Transaction.LOCK}\n   */\n\n\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/transaction.js"],"names":["_","require","Utils","Transaction","constructor","sequelize","options","savepoints","_afterCommitHooks","transactionOptions","dialect","supports","generateTransactionId","QueryGenerator","extend","autocommit","type","transactionType","isolationLevel","readOnly","parent","transaction","id","push","name","length","commit","finished","Promise","reject","Error","_clearCls","getQueryInterface","commitTransaction","finally","cleanup","tap","each","hook","resolve","apply","rollback","connection","rollbackTransaction","prepareEnvironment","useCLS","connectionPromise","acquireOptions","uuid","connectionManager","getConnection","then","begin","setDeferrable","setIsolationLevel","setAutocommit","catch","setupErr","_cls","set","startTransaction","deferrable","deferConstraints","res","releaseConnection","undefined","cls","get","afterCommit","fn","TYPES","DEFERRED","IMMEDIATE","EXCLUSIVE","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","SERIALIZABLE","LOCK","UPDATE","SHARE","KEY_SHARE","NO_KEY_UPDATE","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('./utils');\n\n/**\n * The transaction object is used to identify a running transaction. It is created by calling `Sequelize.transaction()`.\n *\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @see {@link Sequelize.transaction}\n */\nclass Transaction {\n  /**\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {Object} options An object with options\n   * @param {Boolean} options.autocommit Sets the autocommit property of the transaction.\n   * @param {String} options.type=true Sets the type of the transaction.\n   * @param {String} options.isolationLevel=true Sets the isolation level of the transaction.\n   * @param {String} options.deferrable Sets the constraints to be deferred or immediately checked.\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n\n    // get dialect specific transaction options\n    const transactionOptions = sequelize.dialect.supports.transactionOptions || {};\n    const generateTransactionId = this.sequelize.dialect.QueryGenerator.generateTransactionId;\n\n    this.options = _.extend({\n      autocommit: transactionOptions.autocommit || null,\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options || {});\n\n    this.parent = this.options.transaction;\n    this.id = this.parent ? this.parent.id : generateTransactionId();\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = this.id + '-sp-' + this.parent.savepoints.length;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction\n   *\n   * @return {Promise}\n   */\n  commit() {\n\n    if (this.finished) {\n      return Utils.Promise.reject(new Error('Transaction cannot be committed because it has been finished with state: ' + this.finished));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .commitTransaction(this, this.options)\n      .finally(() => {\n        this.finished = 'commit';\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return null;\n      }).tap(\n        () => Utils.Promise.each(\n          this._afterCommitHooks,\n          hook => Promise.resolve(hook.apply(this, [this])))\n      );\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @return {Promise}\n   */\n  rollback() {\n\n    if (this.finished) {\n      return Utils.Promise.reject(new Error('Transaction cannot be rolled back because it has been finished with state: ' + this.finished));\n    }\n\n    if (!this.connection) {\n      return Promise.reject(new Error('Transaction cannot be rolled back because it never started'));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .rollbackTransaction(this, this.options)\n      .finally(() => {\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return this;\n      });\n  }\n\n  prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (typeof useCLS === 'undefined') {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Utils.Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    return connectionPromise\n      .then(connection => {\n        this.connection = connection;\n        this.connection.uuid = this.id;\n      })\n      .then(() => {\n        return this.begin()\n          .then(() => this.setDeferrable())\n          .then(() => this.setIsolationLevel())\n          .then(() => this.setAutocommit())\n          .catch(setupErr => this.rollback().finally(() => {\n            throw setupErr;\n          }));\n      })\n      .tap(() => {\n        if (useCLS && this.sequelize.constructor._cls) {\n          this.sequelize.constructor._cls.set('transaction', this);\n        }\n        return null;\n      });\n  }\n\n  begin() {\n    return this\n      .sequelize\n      .getQueryInterface()\n      .startTransaction(this, this.options);\n  }\n\n  setDeferrable() {\n    if (this.options.deferrable) {\n      return this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  setAutocommit() {\n    return this\n      .sequelize\n      .getQueryInterface()\n      .setAutocommit(this, this.options.autocommit, this.options);\n  }\n\n  setIsolationLevel() {\n    return this\n      .sequelize\n      .getQueryInterface()\n      .setIsolationLevel(this, this.options.isolationLevel, this.options);\n  }\n\n  cleanup() {\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * ```js\n   * return sequelize.transaction({type: Sequelize.Transaction.TYPES.EXCLUSIVE}, transaction => {\n   *\n   *  // your transactions\n   *\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   * ```\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n\n  /**\n   * Isolations levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Default to `REPEATABLE_READ` but you can override the default isolation level by passing `options.isolationLevel` in `new Sequelize`.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * ```js\n   * return sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n *\n *  // your transactions\n *\n * }).then(result => {\n *   // transaction has been committed. Do something after the commit if required.\n * }).catch(err => {\n *   // do something with the err.\n * });\n   * ```\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * ```js\n   * t1 // is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   * ```\n   *\n   * Postgres also supports specific locks while eager loading by using OF:\n   * ```js\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   * ```\n   * UserModel will be locked but TaskModel won't!\n   *\n   * @return {Object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n\n  /**\n   * @see {@link Transaction.LOCK}\n   */\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n"]},"metadata":{},"sourceType":"script"}