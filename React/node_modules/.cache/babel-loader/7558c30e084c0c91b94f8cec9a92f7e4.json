{"ast":null,"code":"'use strict';\n\nconst DataTypes = require('./data-types');\n\nconst SqlString = require('./sql-string');\n\nconst _ = require('lodash');\n\nconst parameterValidator = require('./utils/parameter-validator');\n\nconst Logger = require('./utils/logger');\n\nconst uuid = require('uuid');\n\nconst Promise = require('./promise');\n\nconst operators = require('./operators');\n\nconst operatorsArray = _.values(operators);\n\nconst primitives = ['string', 'number', 'boolean'];\n\nlet inflection = require('inflection');\n\nconst logger = new Logger();\nexports.Promise = Promise;\nexports.debug = logger.debug.bind(logger);\nexports.deprecate = logger.deprecate.bind(logger);\nexports.warn = logger.warn.bind(logger);\n\nexports.getLogger = () => logger;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\n\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\n\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\n\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  return primitives.indexOf(typeof val) !== -1;\n}\n\nexports.isPrimitive = isPrimitive; // Same concept as _.merge, but don't overwrite properties that have already been assigned\n\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, objectValue => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      return objectValue;\n    }\n  });\n}\n\nexports.mergeDefaults = mergeDefaults; // An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\n\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (typeof value !== 'undefined') {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\n\nexports.merge = merge;\n\nfunction lowercaseFirst(s) {\n  return s[0].toLowerCase() + s.slice(1);\n}\n\nexports.lowercaseFirst = lowercaseFirst;\n\nfunction uppercaseFirst(s) {\n  return s[0].toUpperCase() + s.slice(1);\n}\n\nexports.uppercaseFirst = uppercaseFirst;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\n\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\n\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\n\nexports.underscore = underscore;\n\nfunction format(arr, dialect) {\n  const timeZone = null; // Make a clone of the array beacuse format modifies the passed args\n\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\n\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\n\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    } // Don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n\n\n    if (typeof elem === 'object') {\n      return elem;\n    } // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n\n\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\n\nexports.cloneDeep = cloneDeep;\n/* Expand and normalize finder options */\n\nfunction mapFinderOptions(options, Model) {\n  if (Model._hasVirtualAttributes && Array.isArray(options.attributes)) {\n    for (const attribute of options.attributes) {\n      if (Model._isVirtualAttribute(attribute) && Model.rawAttributes[attribute].type.fields) {\n        options.attributes = options.attributes.concat(Model.rawAttributes[attribute].type.fields);\n      }\n    }\n\n    options.attributes = _.without.apply(_, [options.attributes].concat(Model._virtualAttributes));\n    options.attributes = _.uniq(options.attributes);\n  }\n\n  mapOptionFieldNames(options, Model);\n  return options;\n}\n\nexports.mapFinderOptions = mapFinderOptions;\n/* Used to map field names in attributes and where conditions */\n\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr; // Map attributes to aliased syntax attributes\n\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\n\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {\n        // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute] = attributes[attribute].map(where => {\n          if (_.isPlainObject(where)) {\n            return mapWhereFieldNames(where, Model);\n          }\n\n          return where;\n        });\n      }\n    });\n  }\n\n  return attributes;\n}\n\nexports.mapWhereFieldNames = mapWhereFieldNames;\n/* Used to map field names in values */\n\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._isVirtualAttribute(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\n\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value.substr(0, 1) === '$' && value.substr(value.length - 1, 1) === '$';\n}\n\nexports.isColString = isColString;\n\nfunction argsArePrimaryKeys(args, primaryKeys) {\n  let result = args.length === Object.keys(primaryKeys).length;\n\n  if (result) {\n    _.each(args, arg => {\n      if (result) {\n        if (['number', 'string'].indexOf(typeof arg) !== -1) {\n          result = true;\n        } else {\n          result = arg instanceof Date || Buffer.isBuffer(arg);\n        }\n      }\n    });\n  }\n\n  return result;\n}\n\nexports.argsArePrimaryKeys = argsArePrimaryKeys;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.reduce((treatAsAnd, arg) => {\n    if (treatAsAnd) {\n      return treatAsAnd;\n    } else {\n      return _.isPlainObject(arg);\n    }\n  }, false);\n}\n\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\n\nexports.combineTableNames = combineTableNames;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\n\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\n\nexports.pluralize = pluralize;\n\nfunction removeCommentsFromFunctionString(s) {\n  s = s.replace(/\\s*(\\/\\/.*)/g, '');\n  s = s.replace(/(\\/\\*[\\n\\r\\s\\S]*?\\*\\/)/mg, '');\n  return s;\n}\n\nexports.removeCommentsFromFunctionString = removeCommentsFromFunctionString;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    } else {\n      return tmp;\n    }\n  } else if (value instanceof DataTypes.UUIDV1) {\n    return uuid.v1();\n  } else if (value instanceof DataTypes.UUIDV4) {\n    return uuid.v4();\n  } else if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  } else if (_.isPlainObject(value) || _.isArray(value)) {\n    return _.clone(value);\n  } else {\n    return value;\n  }\n}\n\nexports.toDefaultValue = toDefaultValue;\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @return {boolean} yes / no.\n * @private\n */\n\nfunction defaultValueSchemable(value) {\n  if (typeof value === 'undefined') {\n    return false;\n  } // TODO this will be schemable when all supported db\n  // have been normalized for this case\n\n\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n\n  if (_.isFunction(value)) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.indexOf(key) > -1 || key.match(/Id$/) || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\n\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nfunction stack() {\n  const orig = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = (_, stack) => stack;\n\n  const err = new Error();\n  Error.captureStackTrace(err, stack);\n  const errStack = err.stack;\n  Error.prepareStackTrace = orig;\n  return errStack;\n}\n\nexports.stack = stack;\n\nfunction sliceArgs(args, begin) {\n  begin = begin || 0;\n  const tmp = new Array(args.length - begin);\n\n  for (let i = begin; i < args.length; ++i) {\n    tmp[i - begin] = args[i];\n  }\n\n  return tmp;\n}\n\nexports.sliceArgs = sliceArgs;\n\nfunction now(dialect) {\n  const now = new Date();\n\n  if (['mysql', 'postgres', 'sqlite', 'mssql'].indexOf(dialect) === -1) {\n    now.setMilliseconds(0);\n  }\n\n  return now;\n}\n\nexports.now = now; // Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\n\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\n\nexports.removeTicks = removeTicks;\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param value, an Object\n * @return Object, an flattened object\n * @private\n */\n\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : `${key}`;\n\n      if (typeof obj[key] === 'object') {\n        flattenObject(obj[key], flattenedObj, pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\n\nexports.flattenObjectDeep = flattenObjectDeep;\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n * @private\n */\n\nclass SequelizeMethod {}\n\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n\n}\n\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col) {\n    super();\n\n    if (arguments.length > 1) {\n      col = this.sliceArgs(arguments);\n    }\n\n    this.col = col;\n  }\n\n}\n\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n\n}\n\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n\n}\n\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n\n}\n\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n\n}\n\nexports.Where = Where;\nexports.validateParameter = parameterValidator;\n\nexports.mapIsolationLevelStringToTedious = (isolationLevel, tedious) => {\n  if (!tedious) {\n    throw new Error('An instance of tedious lib should be passed to this function');\n  }\n\n  const tediousIsolationLevel = tedious.ISOLATION_LEVEL;\n\n  switch (isolationLevel) {\n    case 'READ_UNCOMMITTED':\n      return tediousIsolationLevel.READ_UNCOMMITTED;\n\n    case 'READ_COMMITTED':\n      return tediousIsolationLevel.READ_COMMITTED;\n\n    case 'REPEATABLE_READ':\n      return tediousIsolationLevel.REPEATABLE_READ;\n\n    case 'SERIALIZABLE':\n      return tediousIsolationLevel.SERIALIZABLE;\n\n    case 'SNAPSHOT':\n      return tediousIsolationLevel.SNAPSHOT;\n  }\n}; //Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n * @param  {Object} obj\n * @return {Array<Symbol>} All operators properties of obj\n * @private\n */\n\n\nfunction getOperators(obj) {\n  return _.intersection(Object.getOwnPropertySymbols(obj || {}), operatorsArray);\n}\n\nexports.getOperators = getOperators;\n/**\n * getComplexKeys\n * @param  {Object} obj\n * @return {Array<String|Symbol>} All keys including operators\n * @private\n */\n\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(_.keys(obj));\n}\n\nexports.getComplexKeys = getComplexKeys;\n/**\n * getComplexSize\n * @param  {Object|Array} obj\n * @return {Integer}      Length of object properties including operators if obj is array returns its length\n * @private\n */\n\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\n\nexports.getComplexSize = getComplexSize;\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {Object} obj\n * @return {Boolean}\n * @private\n */\n\nfunction isWhereEmpty(obj) {\n  return _.isEmpty(obj) && getOperators(obj).length === 0;\n}\n\nexports.isWhereEmpty = isWhereEmpty;\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {String} tableName\n * @param {String} columnName\n * @return {String}\n * @private\n */\n\nfunction generateEnumName(tableName, columnName) {\n  return 'enum_' + tableName + '_' + columnName;\n}\n\nexports.generateEnumName = generateEnumName;\n/**\n * Returns an new Object which keys are camelized\n * @param {Object} obj\n * @return {String}\n * @private\n */\n\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\n\nexports.camelizeObjectKeys = camelizeObjectKeys;\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @private\n */\n\nfunction defaults(object) {\n  object = Object(object);\n\n  const sources = _.tail(arguments);\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n\n        if (value === undefined || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n  return object;\n}\n\nexports.defaults = defaults;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/utils.js"],"names":["DataTypes","require","SqlString","_","parameterValidator","Logger","uuid","Promise","operators","operatorsArray","values","primitives","inflection","logger","exports","debug","bind","deprecate","warn","getLogger","useInflection","_inflection","camelizeIf","str","condition","result","camelize","underscoredIf","underscore","isPrimitive","val","indexOf","mergeDefaults","a","b","mergeWith","objectValue","isPlainObject","undefined","merge","obj","arguments","forOwn","value","key","Array","isArray","concat","lowercaseFirst","s","toLowerCase","slice","uppercaseFirst","toUpperCase","spliceStr","index","count","add","trim","replace","match","c","format","arr","dialect","timeZone","formatNamedParameters","sql","parameters","cloneDeep","cloneDeepWith","elem","clone","mapFinderOptions","options","Model","_hasVirtualAttributes","attributes","attribute","_isVirtualAttribute","rawAttributes","type","fields","without","apply","_virtualAttributes","uniq","mapOptionFieldNames","map","attr","field","where","mapWhereFieldNames","getComplexKeys","forEach","rawAttribute","fieldName","HSTORE","JSON","mapValueFieldNames","dataValues","isColString","substr","length","argsArePrimaryKeys","args","primaryKeys","Object","keys","each","arg","Date","Buffer","isBuffer","canTreatArrayAsAnd","reduce","treatAsAnd","combineTableNames","tableName1","tableName2","singularize","pluralize","removeCommentsFromFunctionString","toDefaultValue","tmp","ABSTRACT","toSql","UUIDV1","v1","UUIDV4","v4","NOW","now","defaultValueSchemable","isFunction","removeNullValuesFromHash","hash","omitNull","allowNull","_hash","forIn","stack","orig","Error","prepareStackTrace","err","captureStackTrace","errStack","sliceArgs","begin","i","setMilliseconds","TICK_CHAR","addTicks","tickChar","removeTicks","RegExp","flattenObjectDeep","flattenedObj","flattenObject","subPath","pathToProperty","get","SequelizeMethod","Fn","constructor","fn","Col","col","Cast","json","Literal","Json","conditionsOrPath","isObject","conditions","path","Where","comparator","logic","validateParameter","mapIsolationLevelStringToTedious","isolationLevel","tedious","tediousIsolationLevel","ISOLATION_LEVEL","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","SERIALIZABLE","SNAPSHOT","getOperators","intersection","getOwnPropertySymbols","getComplexSize","isWhereEmpty","isEmpty","generateEnumName","tableName","columnName","camelizeObjectKeys","newObj","defaults","object","sources","tail","source","eq","prototype","hasOwnProperty","call"],"mappings":"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","sourcesContent":["'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash');\nconst parameterValidator = require('./utils/parameter-validator');\nconst Logger = require('./utils/logger');\nconst uuid = require('uuid');\nconst Promise = require('./promise');\nconst operators  = require('./operators');\nconst operatorsArray = _.values(operators);\nconst primitives = ['string', 'number', 'boolean'];\n\nlet inflection = require('inflection');\nconst logger = new Logger();\n\nexports.Promise = Promise;\nexports.debug = logger.debug.bind(logger);\nexports.deprecate = logger.deprecate.bind(logger);\nexports.warn = logger.warn.bind(logger);\nexports.getLogger = () =>  logger ;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  return primitives.indexOf(typeof val) !== -1;\n}\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, objectValue => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (typeof value !== 'undefined') {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\nexports.merge = merge;\n\nfunction lowercaseFirst(s) {\n  return s[0].toLowerCase() + s.slice(1);\n}\nexports.lowercaseFirst = lowercaseFirst;\n\nfunction uppercaseFirst(s) {\n  return s[0].toUpperCase() + s.slice(1);\n}\nexports.uppercaseFirst = uppercaseFirst;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    }\n\n    // Don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (Model._hasVirtualAttributes && Array.isArray(options.attributes)) {\n    for (const attribute of options.attributes) {\n      if (Model._isVirtualAttribute(attribute) && Model.rawAttributes[attribute].type.fields) {\n        options.attributes = options.attributes.concat(Model.rawAttributes[attribute].type.fields);\n      }\n    }\n    options.attributes = _.without.apply(_, [options.attributes].concat(Model._virtualAttributes));\n    options.attributes = _.uniq(options.attributes);\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr;\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute] = attributes[attribute].map(where => {\n          if (_.isPlainObject(where)) {\n            return mapWhereFieldNames(where, Model);\n          }\n\n          return where;\n        });\n      }\n\n    });\n  }\n\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._isVirtualAttribute(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value.substr(0, 1) === '$' && value.substr(value.length - 1, 1) === '$';\n}\nexports.isColString = isColString;\n\nfunction argsArePrimaryKeys(args, primaryKeys) {\n  let result = args.length === Object.keys(primaryKeys).length;\n  if (result) {\n    _.each(args, arg => {\n      if (result) {\n        if (['number', 'string'].indexOf(typeof arg) !== -1) {\n          result = true;\n        } else {\n          result = arg instanceof Date || Buffer.isBuffer(arg);\n        }\n      }\n    });\n  }\n  return result;\n}\nexports.argsArePrimaryKeys = argsArePrimaryKeys;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.reduce((treatAsAnd, arg) => {\n    if (treatAsAnd) {\n      return treatAsAnd;\n    } else {\n      return _.isPlainObject(arg);\n    }\n  }, false);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\n\nfunction removeCommentsFromFunctionString(s) {\n  s = s.replace(/\\s*(\\/\\/.*)/g, '');\n  s = s.replace(/(\\/\\*[\\n\\r\\s\\S]*?\\*\\/)/mg, '');\n\n  return s;\n}\nexports.removeCommentsFromFunctionString = removeCommentsFromFunctionString;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    } else {\n      return tmp;\n    }\n  } else if (value instanceof DataTypes.UUIDV1) {\n    return uuid.v1();\n  } else if (value instanceof DataTypes.UUIDV4) {\n    return uuid.v4();\n  } else if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  } else if (_.isPlainObject(value) || _.isArray(value)) {\n    return _.clone(value);\n  } else {\n    return value;\n  }\n}\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @return {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (typeof value === 'undefined') { return false; }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) { return false; }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n  if (_.isFunction(value)) {\n    return false;\n  }\n\n  return true;\n}\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.indexOf(key) > -1 || key.match(/Id$/) || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nfunction stack() {\n  const orig = Error.prepareStackTrace;\n  Error.prepareStackTrace = (_, stack) => stack;\n  const err = new Error();\n  Error.captureStackTrace(err, stack);\n  const errStack = err.stack;\n  Error.prepareStackTrace = orig;\n  return errStack;\n}\nexports.stack = stack;\n\nfunction sliceArgs(args, begin) {\n  begin = begin || 0;\n  const tmp = new Array(args.length - begin);\n  for (let i = begin; i < args.length; ++i) {\n    tmp[i - begin] = args[i];\n  }\n  return tmp;\n}\nexports.sliceArgs = sliceArgs;\n\nfunction now(dialect) {\n  const now = new Date();\n  if (['mysql', 'postgres', 'sqlite', 'mssql'].indexOf(dialect) === -1) {\n    now.setMilliseconds(0);\n  }\n  return now;\n}\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param value, an Object\n * @return Object, an flattened object\n * @private\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : `${key}`;\n      if (typeof obj[key] === 'object') {\n        flattenObject(obj[key], flattenedObj, pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n * @private\n */\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col) {\n    super();\n    if (arguments.length > 1) {\n      col = this.sliceArgs(arguments);\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\n\nexports.validateParameter = parameterValidator;\n\n\nexports.mapIsolationLevelStringToTedious = (isolationLevel, tedious) => {\n  if (!tedious) {\n    throw new Error('An instance of tedious lib should be passed to this function');\n  }\n  const tediousIsolationLevel = tedious.ISOLATION_LEVEL;\n  switch (isolationLevel) {\n    case 'READ_UNCOMMITTED':\n      return tediousIsolationLevel.READ_UNCOMMITTED;\n    case 'READ_COMMITTED':\n      return tediousIsolationLevel.READ_COMMITTED;\n    case 'REPEATABLE_READ':\n      return tediousIsolationLevel.REPEATABLE_READ;\n    case 'SERIALIZABLE':\n      return tediousIsolationLevel.SERIALIZABLE;\n    case 'SNAPSHOT':\n      return tediousIsolationLevel.SNAPSHOT;\n  }\n};\n\n//Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n * @param  {Object} obj\n * @return {Array<Symbol>} All operators properties of obj\n * @private\n */\nfunction getOperators(obj) {\n  return _.intersection(Object.getOwnPropertySymbols(obj || {}), operatorsArray);\n}\nexports.getOperators = getOperators;\n\n/**\n * getComplexKeys\n * @param  {Object} obj\n * @return {Array<String|Symbol>} All keys including operators\n * @private\n */\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(_.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\n\n/**\n * getComplexSize\n * @param  {Object|Array} obj\n * @return {Integer}      Length of object properties including operators if obj is array returns its length\n * @private\n */\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\n\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {Object} obj\n * @return {Boolean}\n * @private\n */\nfunction isWhereEmpty(obj) {\n  return _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\n\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {String} tableName\n * @param {String} columnName\n * @return {String}\n * @private\n */\nfunction generateEnumName(tableName, columnName) {\n  return 'enum_' + tableName + '_' + columnName;\n}\nexports.generateEnumName = generateEnumName;\n\n/**\n * Returns an new Object which keys are camelized\n * @param {Object} obj\n * @return {String}\n * @private\n */\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @private\n */\nfunction defaults(object) {\n  object = Object(object);\n\n  const sources = _.tail(arguments);\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n        if (\n          value === undefined || (\n            _.eq(value, Object.prototype[key]) &&\n            !Object.prototype.hasOwnProperty.call(object, key)\n          )\n        ) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n\n  return object;\n}\nexports.defaults = defaults;\n\n"]},"metadata":{},"sourceType":"script"}