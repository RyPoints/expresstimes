{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar tls = _interopRequireWildcard(require(\"tls\"));\n\nvar _events = require(\"events\");\n\nvar _message = _interopRequireDefault(require(\"./message\"));\n\nvar _packet = require(\"./packet\");\n\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\n\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n\n  if (obj != null) {\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst DuplexPair = require('native-duplexpair');\n\nclass MessageIO extends _events.EventEmitter {\n  constructor(socket, packetSize, debug) {\n    super();\n    this.socket = socket;\n    this.debug = debug;\n    this.tlsNegotiationComplete = false;\n    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);\n    this.incomingMessageStream.on('data', message => {\n      message.on('data', chunk => {\n        this.emit('data', chunk);\n      });\n      message.on('end', () => {\n        this.emit('message');\n      });\n    });\n    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {\n      packetSize: packetSize\n    });\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n\n  packetSize(...args) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n\n    return this.outgoingMessageStream.packetSize;\n  }\n\n  startTls(secureContext, hostname, trustServerCertificate) {\n    const duplexpair = new DuplexPair();\n    const securePair = this.securePair = {\n      cleartext: tls.connect({\n        socket: duplexpair.socket1,\n        servername: hostname,\n        secureContext: secureContext,\n        rejectUnauthorized: !trustServerCertificate\n      }),\n      encrypted: duplexpair.socket2\n    }; // If an error happens in the TLS layer, there is nothing we can do about it.\n    // Forward the error to the socket so the connection gets properly cleaned up.\n\n    securePair.cleartext.on('error', err => {\n      // Streams in node.js versions before 8.0.0 don't support `.destroy`\n      if (typeof securePair.encrypted.destroy === 'function') {\n        securePair.encrypted.destroy();\n      }\n\n      this.socket.destroy(err);\n    });\n    securePair.cleartext.on('secureConnect', () => {\n      const cipher = securePair.cleartext.getCipher();\n\n      if (cipher) {\n        this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n      }\n\n      this.emit('secure', securePair.cleartext);\n      this.encryptAllFutureTraffic();\n    });\n    securePair.encrypted.on('data', data => {\n      this.sendMessage(_packet.TYPE.PRELOGIN, data, false);\n    });\n  }\n\n  encryptAllFutureTraffic() {\n    const securePair = this.securePair;\n    securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    securePair.encrypted.removeAllListeners('data');\n    this.outgoingMessageStream.unpipe(this.socket);\n    this.socket.unpipe(this.incomingMessageStream);\n    this.socket.pipe(securePair.encrypted);\n    securePair.encrypted.pipe(this.socket);\n    securePair.cleartext.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(securePair.cleartext);\n    this.tlsNegotiationComplete = true;\n  }\n\n  tlsHandshakeData(data) {\n    const securePair = this.securePair;\n    securePair.encrypted.write(data);\n  } // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n\n\n  sendMessage(packetType, data, resetConnection) {\n    const message = new _message.default({\n      type: packetType,\n      resetConnection: resetConnection\n    });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  } // Temporarily suspends the flow of incoming packets.\n\n\n  pause() {\n    this.incomingMessageStream.pause();\n  } // Resumes the flow of incoming packets.\n\n\n  resume() {\n    this.incomingMessageStream.resume();\n  }\n\n}\n\nvar _default = MessageIO;\nexports.default = _default;\nmodule.exports = MessageIO;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/tedious/lib/message-io.js"],"names":["Object","defineProperty","exports","value","default","tls","_interopRequireWildcard","require","_events","_message","_interopRequireDefault","_packet","_incomingMessageStream","_outgoingMessageStream","obj","__esModule","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","DuplexPair","MessageIO","EventEmitter","constructor","socket","packetSize","debug","tlsNegotiationComplete","incomingMessageStream","on","message","chunk","emit","outgoingMessageStream","pipe","args","length","log","securePair","cleartext","setMaxSendFragment","startTls","secureContext","hostname","trustServerCertificate","duplexpair","connect","socket1","servername","rejectUnauthorized","encrypted","socket2","err","destroy","cipher","getCipher","name","version","encryptAllFutureTraffic","data","sendMessage","TYPE","PRELOGIN","removeAllListeners","unpipe","tlsHandshakeData","write","packetType","resetConnection","type","end","pause","resume","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar tls = _interopRequireWildcard(require(\"tls\"));\n\nvar _events = require(\"events\");\n\nvar _message = _interopRequireDefault(require(\"./message\"));\n\nvar _packet = require(\"./packet\");\n\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\n\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst DuplexPair = require('native-duplexpair');\n\nclass MessageIO extends _events.EventEmitter {\n  constructor(socket, packetSize, debug) {\n    super();\n    this.socket = socket;\n    this.debug = debug;\n    this.tlsNegotiationComplete = false;\n    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);\n    this.incomingMessageStream.on('data', message => {\n      message.on('data', chunk => {\n        this.emit('data', chunk);\n      });\n      message.on('end', () => {\n        this.emit('message');\n      });\n    });\n    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {\n      packetSize: packetSize\n    });\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n\n  packetSize(...args) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n\n    return this.outgoingMessageStream.packetSize;\n  }\n\n  startTls(secureContext, hostname, trustServerCertificate) {\n    const duplexpair = new DuplexPair();\n    const securePair = this.securePair = {\n      cleartext: tls.connect({\n        socket: duplexpair.socket1,\n        servername: hostname,\n        secureContext: secureContext,\n        rejectUnauthorized: !trustServerCertificate\n      }),\n      encrypted: duplexpair.socket2\n    }; // If an error happens in the TLS layer, there is nothing we can do about it.\n    // Forward the error to the socket so the connection gets properly cleaned up.\n\n    securePair.cleartext.on('error', err => {\n      // Streams in node.js versions before 8.0.0 don't support `.destroy`\n      if (typeof securePair.encrypted.destroy === 'function') {\n        securePair.encrypted.destroy();\n      }\n\n      this.socket.destroy(err);\n    });\n    securePair.cleartext.on('secureConnect', () => {\n      const cipher = securePair.cleartext.getCipher();\n\n      if (cipher) {\n        this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n      }\n\n      this.emit('secure', securePair.cleartext);\n      this.encryptAllFutureTraffic();\n    });\n    securePair.encrypted.on('data', data => {\n      this.sendMessage(_packet.TYPE.PRELOGIN, data, false);\n    });\n  }\n\n  encryptAllFutureTraffic() {\n    const securePair = this.securePair;\n    securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    securePair.encrypted.removeAllListeners('data');\n    this.outgoingMessageStream.unpipe(this.socket);\n    this.socket.unpipe(this.incomingMessageStream);\n    this.socket.pipe(securePair.encrypted);\n    securePair.encrypted.pipe(this.socket);\n    securePair.cleartext.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(securePair.cleartext);\n    this.tlsNegotiationComplete = true;\n  }\n\n  tlsHandshakeData(data) {\n    const securePair = this.securePair;\n    securePair.encrypted.write(data);\n  } // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n\n\n  sendMessage(packetType, data, resetConnection) {\n    const message = new _message.default({\n      type: packetType,\n      resetConnection: resetConnection\n    });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  } // Temporarily suspends the flow of incoming packets.\n\n\n  pause() {\n    this.incomingMessageStream.pause();\n  } // Resumes the flow of incoming packets.\n\n\n  resume() {\n    this.incomingMessageStream.resume();\n  }\n\n}\n\nvar _default = MessageIO;\nexports.default = _default;\nmodule.exports = MessageIO;"]},"metadata":{},"sourceType":"script"}