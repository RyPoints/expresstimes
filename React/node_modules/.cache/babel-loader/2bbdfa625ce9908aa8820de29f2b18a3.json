{"ast":null,"code":"var PQ = module.exports = require('bindings')('addon.node').PQ; //print out the include dir\n//if you want to include this in a binding.gyp file\n\n\nif (!module.parent) {\n  var path = require('path');\n\n  console.log(path.normalize(__dirname + '/src'));\n}\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar assert = require('assert');\n\nfor (var key in EventEmitter.prototype) {\n  PQ.prototype[key] = EventEmitter.prototype[key];\n} //SYNC connects to the server\n//throws an exception in the event of a connection error\n\n\nPQ.prototype.connectSync = function (paramString) {\n  this.connected = true;\n\n  if (!paramString) {\n    paramString = '';\n  }\n\n  var connected = this.$connectSync(paramString);\n\n  if (!connected) {\n    var err = new Error(this.errorMessage());\n    this.finish();\n    throw err;\n  }\n}; //connects async using a background thread\n//calls the callback with an error if there was one\n\n\nPQ.prototype.connect = function (paramString, cb) {\n  this.connected = true;\n\n  if (typeof paramString == 'function') {\n    cb = paramString;\n    paramString = '';\n  }\n\n  if (!paramString) {\n    paramString = '';\n  }\n\n  assert(cb, 'Must provide a connection callback');\n\n  if (process.domain) {\n    cb = process.domain.bind(cb);\n  }\n\n  this.$connect(paramString, cb);\n};\n\nPQ.prototype.errorMessage = function () {\n  return this.$getLastErrorMessage();\n}; //returns an int for the fd of the socket\n\n\nPQ.prototype.socket = function () {\n  return this.$socket();\n}; // return server version number e.g. 90300\n\n\nPQ.prototype.serverVersion = function () {\n  return this.$serverVersion();\n}; //finishes the connection & closes it\n\n\nPQ.prototype.finish = function () {\n  this.connected = false;\n  this.$finish();\n}; ////SYNC executes a plain text query\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\n\n\nPQ.prototype.exec = function (commandText) {\n  if (!commandText) {\n    commandText = '';\n  }\n\n  this.$exec(commandText);\n}; //SYNC executes a query with parameters\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\n\n\nPQ.prototype.execParams = function (commandText, parameters) {\n  if (!commandText) {\n    commandText = '';\n  }\n\n  if (!parameters) {\n    parameters = [];\n  }\n\n  this.$execParams(commandText, parameters);\n}; //SYNC prepares a named query and stores the result\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\n\n\nPQ.prototype.prepare = function (statementName, commandText, nParams) {\n  assert.equal(arguments.length, 3, 'Must supply 3 arguments');\n\n  if (!statementName) {\n    statementName = '';\n  }\n\n  if (!commandText) {\n    commandText = '';\n  }\n\n  nParams = Number(nParams) || 0;\n  this.$prepare(statementName, commandText, nParams);\n}; //SYNC executes a named, prepared query and stores the result\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\n\n\nPQ.prototype.execPrepared = function (statementName, parameters) {\n  if (!statementName) {\n    statementName = '';\n  }\n\n  if (!parameters) {\n    parameters = [];\n  }\n\n  this.$execPrepared(statementName, parameters);\n}; //send a command to begin executing a query in async mode\n//returns true if sent, or false if there was a send failure\n\n\nPQ.prototype.sendQuery = function (commandText) {\n  if (!commandText) {\n    commandText = '';\n  }\n\n  return this.$sendQuery(commandText);\n}; //send a command to begin executing a query with parameters in async mode\n//returns true if sent, or false if there was a send failure\n\n\nPQ.prototype.sendQueryParams = function (commandText, parameters) {\n  if (!commandText) {\n    commandText = '';\n  }\n\n  if (!parameters) {\n    parameters = [];\n  }\n\n  return this.$sendQueryParams(commandText, parameters);\n}; //send a command to prepare a named query in async mode\n//returns true if sent, or false if there was a send failure\n\n\nPQ.prototype.sendPrepare = function (statementName, commandText, nParams) {\n  assert.equal(arguments.length, 3, 'Must supply 3 arguments');\n\n  if (!statementName) {\n    statementName = '';\n  }\n\n  if (!commandText) {\n    commandText = '';\n  }\n\n  nParams = Number(nParams) || 0;\n  return this.$sendPrepare(statementName, commandText, nParams);\n}; //send a command to execute a named query in async mode\n//returns true if sent, or false if there was a send failure\n\n\nPQ.prototype.sendQueryPrepared = function (statementName, parameters) {\n  if (!statementName) {\n    statementName = '';\n  }\n\n  if (!parameters) {\n    parameters = [];\n  }\n\n  return this.$sendQueryPrepared(statementName, parameters);\n}; //'pops' a result out of the buffered\n//response data read during async command execution\n//and stores it on the c/c++ object so you can consume\n//the data from it.  returns true if there was a pending result\n//or false if there was no pending result. if there was no pending result\n//the last found result is not overwritten so you can call getResult as many\n//times as you want, and you'll always have the last available result for consumption\n\n\nPQ.prototype.getResult = function () {\n  return this.$getResult();\n}; //returns a text of the enum associated with the result\n//usually just PGRES_COMMAND_OK or PGRES_FATAL_ERROR\n\n\nPQ.prototype.resultStatus = function () {\n  return this.$resultStatus();\n};\n\nPQ.prototype.resultErrorMessage = function () {\n  return this.$resultErrorMessage();\n};\n\nPQ.prototype.resultErrorFields = function () {\n  return this.$resultErrorFields();\n}; //free the memory associated with a result\n//this is somewhat handled for you within the c/c++ code\n//by never allowing the code to 'leak' a result. still,\n//if you absolutely want to free it yourself, you can use this.\n\n\nPQ.prototype.clear = function () {\n  this.$clear();\n}; //returns the number of tuples (rows) in the result set\n\n\nPQ.prototype.ntuples = function () {\n  return this.$ntuples();\n}; //returns the number of fields (columns) in the result set\n\n\nPQ.prototype.nfields = function () {\n  return this.$nfields();\n}; //returns the name of the field (column) at the given offset\n\n\nPQ.prototype.fname = function (offset) {\n  return this.$fname(offset);\n}; //returns the Oid of the type for the given field\n\n\nPQ.prototype.ftype = function (offset) {\n  return this.$ftype(offset);\n}; //returns a text value at the given row/col\n//if the value is null this still returns empty string\n//so you need to use PQ#getisnull to determine\n\n\nPQ.prototype.getvalue = function (row, col) {\n  return this.$getvalue(row, col);\n}; //returns true/false if the value is null\n\n\nPQ.prototype.getisnull = function (row, col) {\n  return this.$getisnull(row, col);\n}; //returns the status of the command\n\n\nPQ.prototype.cmdStatus = function () {\n  return this.$cmdStatus();\n}; //returns the tuples in the command\n\n\nPQ.prototype.cmdTuples = function () {\n  return this.$cmdTuples();\n}; //starts the 'read ready' libuv socket listener.\n//Once the socket becomes readable, the PQ instance starts\n//emitting 'readable' events.  Similar to how node's readable-stream\n//works except to clear the SELECT() notification you need to call\n//PQ#consumeInput instead of letting node pull the data off the socket\n//http://www.postgresql.org/docs/9.1/static/libpq-async.html\n\n\nPQ.prototype.startReader = function () {\n  assert(this.connected, 'Must be connected to start reader');\n  this.$startRead();\n}; //suspends the libuv socket 'read ready' listener\n\n\nPQ.prototype.stopReader = function () {\n  this.$stopRead();\n};\n\nPQ.prototype.writable = function (cb) {\n  assert(this.connected, 'Must be connected to start writer');\n  this.$startWrite();\n  return this.once('writable', cb);\n}; //returns boolean - false indicates an error condition\n//e.g. a failure to consume input\n\n\nPQ.prototype.consumeInput = function () {\n  return this.$consumeInput();\n}; //returns true if PQ#getResult would cause\n//the process to block waiting on results\n//false indicates PQ#getResult can be called\n//with an assurance of not blocking\n\n\nPQ.prototype.isBusy = function () {\n  return this.$isBusy();\n}; //toggles the socket blocking on outgoing writes\n\n\nPQ.prototype.setNonBlocking = function (truthy) {\n  return this.$setNonBlocking(truthy ? 1 : 0);\n}; //returns true if the connection is non-blocking on writes, otherwise false\n//note: connection is always non-blocking on reads if using the send* methods\n\n\nPQ.prototype.isNonBlocking = function () {\n  return this.$isNonBlocking();\n}; //returns 1 if socket is not write-ready\n//returns 0 if all data flushed to socket\n//returns -1 if there is an error\n\n\nPQ.prototype.flush = function () {\n  return this.$flush();\n}; //escapes a literal and returns the escaped string\n//I'm not 100% sure this doesn't do any I/O...need to check that\n\n\nPQ.prototype.escapeLiteral = function (input) {\n  if (!input) return input;\n  return this.$escapeLiteral(input);\n};\n\nPQ.prototype.escapeIdentifier = function (input) {\n  if (!input) return input;\n  return this.$escapeIdentifier(input);\n}; //Checks for any notifications which may have arrivied\n//and returns them as a javascript object: {relname: 'string', extra: 'string', be_pid: int}\n//if there are no pending notifications this returns undefined\n\n\nPQ.prototype.notifies = function () {\n  return this.$notifies();\n}; //Sends a buffer of binary data to the server\n//returns 1 if the command was sent successfully\n//returns 0 if the command would block (use PQ#writable here if so)\n//returns -1 if there was an error\n\n\nPQ.prototype.putCopyData = function (buffer) {\n  assert(buffer instanceof Buffer);\n  return this.$putCopyData(buffer);\n}; //Sends a command to 'finish' the copy\n//if an error message is passed, it will be sent to the\n//backend and signal a request to cancel the copy in\n//returns 1 if sent succesfully\n//returns 0 if the command would block\n//returns -1 if there was an error\n\n\nPQ.prototype.putCopyEnd = function (errorMessage) {\n  if (errorMessage) {\n    return this.$putCopyEnd(errorMessage);\n  }\n\n  return this.$putCopyEnd();\n}; //Gets a buffer of data from a copy out command\n//if async is passed as true it will not block waiting\n//for the result, otherwise this will BLOCK for a result.\n//returns a buffer if successful\n//returns 0 if copy is still in process (async only)\n//returns -1 if the copy is done\n//returns -2 if there was an error\n\n\nPQ.prototype.getCopyData = function (async) {\n  return this.$getCopyData(!!async);\n};\n\nPQ.prototype.cancel = function () {\n  return this.$cancel();\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/libpq/index.js"],"names":["PQ","module","exports","require","parent","path","console","log","normalize","__dirname","EventEmitter","assert","key","prototype","connectSync","paramString","connected","$connectSync","err","Error","errorMessage","finish","connect","cb","process","domain","bind","$connect","$getLastErrorMessage","socket","$socket","serverVersion","$serverVersion","$finish","exec","commandText","$exec","execParams","parameters","$execParams","prepare","statementName","nParams","equal","arguments","length","Number","$prepare","execPrepared","$execPrepared","sendQuery","$sendQuery","sendQueryParams","$sendQueryParams","sendPrepare","$sendPrepare","sendQueryPrepared","$sendQueryPrepared","getResult","$getResult","resultStatus","$resultStatus","resultErrorMessage","$resultErrorMessage","resultErrorFields","$resultErrorFields","clear","$clear","ntuples","$ntuples","nfields","$nfields","fname","offset","$fname","ftype","$ftype","getvalue","row","col","$getvalue","getisnull","$getisnull","cmdStatus","$cmdStatus","cmdTuples","$cmdTuples","startReader","$startRead","stopReader","$stopRead","writable","$startWrite","once","consumeInput","$consumeInput","isBusy","$isBusy","setNonBlocking","truthy","$setNonBlocking","isNonBlocking","$isNonBlocking","flush","$flush","escapeLiteral","input","$escapeLiteral","escapeIdentifier","$escapeIdentifier","notifies","$notifies","putCopyData","buffer","Buffer","$putCopyData","putCopyEnd","$putCopyEnd","getCopyData","async","$getCopyData","cancel","$cancel"],"mappings":"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","sourcesContent":["var PQ = module.exports = require('bindings')('addon.node').PQ;\n\n//print out the include dir\n//if you want to include this in a binding.gyp file\nif(!module.parent) {\n  var path = require('path');\n  console.log(path.normalize(__dirname + '/src'));\n}\n\nvar EventEmitter = require('events').EventEmitter;\nvar assert = require('assert');\n\nfor(var key in EventEmitter.prototype) {\n  PQ.prototype[key] = EventEmitter.prototype[key];\n}\n\n//SYNC connects to the server\n//throws an exception in the event of a connection error\nPQ.prototype.connectSync = function(paramString) {\n  this.connected = true;\n  if(!paramString) {\n    paramString = '';\n  }\n  var connected = this.$connectSync(paramString);\n  if(!connected) {\n    var err = new Error(this.errorMessage());\n    this.finish();\n    throw err;\n  }\n};\n\n//connects async using a background thread\n//calls the callback with an error if there was one\nPQ.prototype.connect = function(paramString, cb) {\n  this.connected = true;\n  if(typeof paramString == 'function') {\n    cb = paramString;\n    paramString = '';\n  }\n  if(!paramString) {\n    paramString = '';\n  }\n  assert(cb, 'Must provide a connection callback');\n  if(process.domain) {\n    cb = process.domain.bind(cb);\n  }\n  this.$connect(paramString, cb);\n};\n\nPQ.prototype.errorMessage = function() {\n  return this.$getLastErrorMessage();\n};\n\n//returns an int for the fd of the socket\nPQ.prototype.socket = function() {\n  return this.$socket();\n};\n\n// return server version number e.g. 90300\nPQ.prototype.serverVersion = function () {\n  return this.$serverVersion();\n};\n\n//finishes the connection & closes it\nPQ.prototype.finish = function() {\n  this.connected = false;\n  this.$finish();\n};\n\n////SYNC executes a plain text query\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\nPQ.prototype.exec = function(commandText) {\n  if(!commandText) {\n    commandText = '';\n  }\n  this.$exec(commandText);\n};\n\n//SYNC executes a query with parameters\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\nPQ.prototype.execParams = function(commandText, parameters) {\n  if(!commandText) {\n    commandText = '';\n  }\n  if(!parameters) {\n    parameters = [];\n  }\n  this.$execParams(commandText, parameters);\n};\n\n//SYNC prepares a named query and stores the result\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\nPQ.prototype.prepare = function(statementName, commandText, nParams) {\n  assert.equal(arguments.length, 3, 'Must supply 3 arguments');\n  if(!statementName) {\n    statementName = '';\n  }\n  if(!commandText) {\n    commandText = '';\n  }\n  nParams = Number(nParams) || 0;\n  this.$prepare(statementName, commandText, nParams);\n};\n\n//SYNC executes a named, prepared query and stores the result\n//immediately stores the results within the PQ object for consumption with\n//ntuples, getvalue, etc...\n//returns false if there was an error\n//consume additional error details via PQ#errorMessage & friends\nPQ.prototype.execPrepared = function(statementName, parameters) {\n  if(!statementName) {\n    statementName = '';\n  }\n  if(!parameters) {\n    parameters = [];\n  }\n  this.$execPrepared(statementName, parameters);\n};\n\n//send a command to begin executing a query in async mode\n//returns true if sent, or false if there was a send failure\nPQ.prototype.sendQuery = function(commandText) {\n  if(!commandText) {\n    commandText = '';\n  }\n  return this.$sendQuery(commandText);\n};\n\n//send a command to begin executing a query with parameters in async mode\n//returns true if sent, or false if there was a send failure\nPQ.prototype.sendQueryParams = function(commandText, parameters) {\n  if(!commandText) {\n    commandText = '';\n  }\n  if(!parameters) {\n    parameters = [];\n  }\n  return this.$sendQueryParams(commandText, parameters);\n};\n\n//send a command to prepare a named query in async mode\n//returns true if sent, or false if there was a send failure\nPQ.prototype.sendPrepare = function(statementName, commandText, nParams) {\n  assert.equal(arguments.length, 3, 'Must supply 3 arguments');\n  if(!statementName) {\n    statementName = '';\n  }\n  if(!commandText) {\n    commandText = '';\n  }\n  nParams = Number(nParams) || 0;\n  return this.$sendPrepare(statementName, commandText, nParams);\n};\n\n//send a command to execute a named query in async mode\n//returns true if sent, or false if there was a send failure\nPQ.prototype.sendQueryPrepared = function(statementName, parameters) {\n  if(!statementName) {\n    statementName = '';\n  }\n  if(!parameters) {\n    parameters = [];\n  }\n  return this.$sendQueryPrepared(statementName, parameters);\n};\n\n//'pops' a result out of the buffered\n//response data read during async command execution\n//and stores it on the c/c++ object so you can consume\n//the data from it.  returns true if there was a pending result\n//or false if there was no pending result. if there was no pending result\n//the last found result is not overwritten so you can call getResult as many\n//times as you want, and you'll always have the last available result for consumption\nPQ.prototype.getResult = function() {\n  return this.$getResult();\n};\n\n//returns a text of the enum associated with the result\n//usually just PGRES_COMMAND_OK or PGRES_FATAL_ERROR\nPQ.prototype.resultStatus = function() {\n  return this.$resultStatus();\n};\n\nPQ.prototype.resultErrorMessage = function() {\n  return this.$resultErrorMessage();\n};\n\nPQ.prototype.resultErrorFields = function() {\n  return this.$resultErrorFields();\n};\n\n//free the memory associated with a result\n//this is somewhat handled for you within the c/c++ code\n//by never allowing the code to 'leak' a result. still,\n//if you absolutely want to free it yourself, you can use this.\nPQ.prototype.clear = function() {\n  this.$clear();\n};\n\n//returns the number of tuples (rows) in the result set\nPQ.prototype.ntuples = function() {\n  return this.$ntuples();\n};\n\n//returns the number of fields (columns) in the result set\nPQ.prototype.nfields = function() {\n  return this.$nfields();\n};\n\n//returns the name of the field (column) at the given offset\nPQ.prototype.fname = function(offset) {\n  return this.$fname(offset);\n};\n\n//returns the Oid of the type for the given field\nPQ.prototype.ftype = function(offset) {\n  return this.$ftype(offset);\n};\n\n//returns a text value at the given row/col\n//if the value is null this still returns empty string\n//so you need to use PQ#getisnull to determine\nPQ.prototype.getvalue = function(row, col) {\n  return this.$getvalue(row, col);\n};\n\n//returns true/false if the value is null\nPQ.prototype.getisnull = function(row, col) {\n  return this.$getisnull(row, col);\n};\n\n//returns the status of the command\nPQ.prototype.cmdStatus = function() {\n  return this.$cmdStatus();\n};\n\n//returns the tuples in the command\nPQ.prototype.cmdTuples = function() {\n  return this.$cmdTuples();\n};\n\n//starts the 'read ready' libuv socket listener.\n//Once the socket becomes readable, the PQ instance starts\n//emitting 'readable' events.  Similar to how node's readable-stream\n//works except to clear the SELECT() notification you need to call\n//PQ#consumeInput instead of letting node pull the data off the socket\n//http://www.postgresql.org/docs/9.1/static/libpq-async.html\nPQ.prototype.startReader = function() {\n  assert(this.connected, 'Must be connected to start reader');\n  this.$startRead();\n};\n\n//suspends the libuv socket 'read ready' listener\nPQ.prototype.stopReader = function() {\n  this.$stopRead();\n};\n\nPQ.prototype.writable = function(cb) {\n  assert(this.connected, 'Must be connected to start writer');\n  this.$startWrite();\n  return this.once('writable', cb);\n};\n\n//returns boolean - false indicates an error condition\n//e.g. a failure to consume input\nPQ.prototype.consumeInput = function() {\n  return this.$consumeInput();\n};\n\n//returns true if PQ#getResult would cause\n//the process to block waiting on results\n//false indicates PQ#getResult can be called\n//with an assurance of not blocking\nPQ.prototype.isBusy = function() {\n  return this.$isBusy();\n};\n\n//toggles the socket blocking on outgoing writes\nPQ.prototype.setNonBlocking = function(truthy) {\n  return this.$setNonBlocking(truthy ? 1 : 0);\n};\n\n//returns true if the connection is non-blocking on writes, otherwise false\n//note: connection is always non-blocking on reads if using the send* methods\nPQ.prototype.isNonBlocking = function() {\n  return this.$isNonBlocking();\n};\n\n//returns 1 if socket is not write-ready\n//returns 0 if all data flushed to socket\n//returns -1 if there is an error\nPQ.prototype.flush = function() {\n  return this.$flush();\n};\n\n//escapes a literal and returns the escaped string\n//I'm not 100% sure this doesn't do any I/O...need to check that\nPQ.prototype.escapeLiteral = function(input) {\n  if(!input) return input;\n  return this.$escapeLiteral(input);\n};\n\nPQ.prototype.escapeIdentifier = function(input) {\n  if(!input) return input;\n  return this.$escapeIdentifier(input);\n};\n\n//Checks for any notifications which may have arrivied\n//and returns them as a javascript object: {relname: 'string', extra: 'string', be_pid: int}\n//if there are no pending notifications this returns undefined\nPQ.prototype.notifies = function() {\n  return this.$notifies();\n};\n\n//Sends a buffer of binary data to the server\n//returns 1 if the command was sent successfully\n//returns 0 if the command would block (use PQ#writable here if so)\n//returns -1 if there was an error\nPQ.prototype.putCopyData = function(buffer) {\n  assert(buffer instanceof Buffer);\n  return this.$putCopyData(buffer);\n};\n\n//Sends a command to 'finish' the copy\n//if an error message is passed, it will be sent to the\n//backend and signal a request to cancel the copy in\n//returns 1 if sent succesfully\n//returns 0 if the command would block\n//returns -1 if there was an error\nPQ.prototype.putCopyEnd = function(errorMessage) {\n  if(errorMessage) {\n    return this.$putCopyEnd(errorMessage);\n  }\n  return this.$putCopyEnd();\n};\n\n//Gets a buffer of data from a copy out command\n//if async is passed as true it will not block waiting\n//for the result, otherwise this will BLOCK for a result.\n//returns a buffer if successful\n//returns 0 if copy is still in process (async only)\n//returns -1 if the copy is done\n//returns -2 if there was an error\nPQ.prototype.getCopyData = function(async) {\n  return this.$getCopyData(!!async);\n};\n\nPQ.prototype.cancel = function() {\n  return this.$cancel();\n};\n"]},"metadata":{},"sourceType":"script"}