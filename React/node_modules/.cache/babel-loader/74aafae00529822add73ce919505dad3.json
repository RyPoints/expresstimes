{"ast":null,"code":"var max = require('lodash/max');\n\nvar compact = require('lodash/compact');\n\nvar times = require('lodash/times');\n\nvar trimStart = require('lodash/trimStart');\n\nvar padEnd = require('lodash/padEnd');\n\nvar he = require('he');\n\nvar helper = require('./helper');\n\nfunction formatText(elem, options) {\n  var text = elem.data || \"\";\n  text = he.decode(text, options.decodeOptions);\n\n  if (options.isInPre) {\n    return text;\n  } else {\n    return helper.wordwrap(elem.trimLeadingSpace ? trimStart(text) : text, options);\n  }\n}\n\nfunction formatImage(elem, options) {\n  if (options.ignoreImage) {\n    return '';\n  }\n\n  var result = '',\n      attribs = elem.attribs || {};\n\n  if (attribs.alt) {\n    result += he.decode(attribs.alt, options.decodeOptions);\n\n    if (attribs.src) {\n      result += ' ';\n    }\n  }\n\n  if (attribs.src) {\n    result += '[' + attribs.src + ']';\n  }\n\n  return result;\n}\n\nfunction formatLineBreak(elem, fn, options) {\n  return '\\n' + fn(elem.children, options);\n}\n\nfunction formatParagraph(elem, fn, options) {\n  var paragraph = fn(elem.children, options);\n\n  if (options.singleNewLineParagraphs) {\n    return paragraph + '\\n';\n  } else {\n    return paragraph + '\\n\\n';\n  }\n}\n\nfunction formatHeading(elem, fn, options) {\n  var heading = fn(elem.children, options);\n\n  if (options.uppercaseHeadings) {\n    heading = heading.toUpperCase();\n  }\n\n  return heading + '\\n';\n} // If we have both href and anchor text, format it in a useful manner:\n// - \"anchor text [href]\"\n// Otherwise if we have only anchor text or an href, we return the part we have:\n// - \"anchor text\" or\n// - \"href\"\n\n\nfunction formatAnchor(elem, fn, options) {\n  var href = ''; // Always get the anchor text\n\n  var storedCharCount = options.lineCharCount;\n  var text = fn(elem.children || [], options);\n\n  if (!text) {\n    text = '';\n  }\n\n  var result = elem.trimLeadingSpace ? trimStart(text) : text;\n\n  if (!options.ignoreHref) {\n    // Get the href, if present\n    if (elem.attribs && elem.attribs.href) {\n      href = elem.attribs.href.replace(/^mailto:/, '');\n    }\n\n    if (href) {\n      if (!options.noAnchorUrl || options.noAnchorUrl && href[0] !== '#') {\n        if (options.linkHrefBaseUrl && href.indexOf('/') === 0) {\n          href = options.linkHrefBaseUrl + href;\n        }\n\n        if (!options.hideLinkHrefIfSameAsText || href !== helper.replaceAll(result, '\\n', '')) {\n          if (!options.noLinkBrackets) {\n            result += ' [' + href + ']';\n          } else {\n            result += ' ' + href;\n          }\n        }\n      }\n    }\n  }\n\n  options.lineCharCount = storedCharCount;\n  return formatText({\n    data: result || href,\n    trimLeadingSpace: elem.trimLeadingSpace\n  }, options);\n}\n\nfunction formatHorizontalLine(elem, fn, options) {\n  return '\\n' + '-'.repeat(options.wordwrap) + '\\n\\n';\n}\n\nfunction formatListItem(prefix, elem, fn, options) {\n  options = Object.assign({}, options); // Reduce the wordwrap for sub elements.\n\n  if (options.wordwrap) {\n    options.wordwrap -= prefix.length;\n  } // Process sub elements.\n\n\n  var text = fn(elem.children, options); // Replace all line breaks with line break + prefix spacing.\n\n  text = text.replace(/\\n/g, '\\n' + ' '.repeat(prefix.length)); // Add first prefix and line break at the end.\n\n  return prefix + text + '\\n';\n}\n\nvar whiteSpaceRegex = /^\\s*$/;\n\nfunction formatUnorderedList(elem, fn, options) {\n  var result = '';\n  var prefix = options.unorderedListItemPrefix;\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  nonWhiteSpaceChildren.forEach(function (elem) {\n    result += formatListItem(prefix, elem, fn, options);\n  });\n  return result + '\\n';\n}\n\nfunction formatOrderedList(elem, fn, options) {\n  var result = '';\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function (child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  }); // Return different functions for different OL types\n\n  var typeFunction = function () {\n    // Determine type\n    var olType = elem.attribs.type || '1'; // TODO Imeplement the other valid types\n    //   Fallback to type '1' function for other valid types\n\n    switch (olType) {\n      case 'a':\n        return function (start, i) {\n          return String.fromCharCode(i + start + 97);\n        };\n\n      case 'A':\n        return function (start, i) {\n          return String.fromCharCode(i + start + 65);\n        };\n\n      case '1':\n      default:\n        return function (start, i) {\n          return i + 1 + start;\n        };\n    }\n  }(); // Make sure there are list items present\n\n\n  if (nonWhiteSpaceChildren.length) {\n    // Calculate initial start from ol attribute\n    var start = Number(elem.attribs.start || '1') - 1; // Calculate the maximum length to i.\n\n    var maxLength = (nonWhiteSpaceChildren.length + start).toString().length;\n    nonWhiteSpaceChildren.forEach(function (elem, i) {\n      // Use different function depending on type\n      var index = typeFunction(start, i); // Calculate the needed spacing for nice indentation.\n\n      var spacing = maxLength - index.toString().length;\n      var prefix = ' ' + index + '. ' + ' '.repeat(spacing);\n      result += formatListItem(prefix, elem, fn, options);\n    });\n  }\n\n  return result + '\\n';\n}\n\nfunction tableToString(table) {\n  // Determine space width per column\n  // Convert all rows to lengths\n  var widths = table.map(function (row) {\n    return row.map(function (col) {\n      return col.length;\n    });\n  }); // Invert rows with colums\n\n  widths = helper.arrayZip(widths); // Determine the max values for each column\n\n  widths = widths.map(function (col) {\n    return max(col);\n  }); // Build the table\n\n  var text = '';\n  table.forEach(function (row) {\n    var i = 0;\n    row.forEach(function (col) {\n      text += padEnd(col.trim(), widths[i++], ' ') + '   ';\n    });\n    text += '\\n';\n  });\n  return text + '\\n';\n}\n\nfunction formatTable(elem, fn, options) {\n  var table = [];\n  elem.children.forEach(tryParseRows);\n  return tableToString(table);\n\n  function tryParseRows(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n\n    switch (elem.name.toLowerCase()) {\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"center\":\n        elem.children.forEach(tryParseRows);\n        return;\n\n      case 'tr':\n        var rows = [];\n        elem.children.forEach(function (elem) {\n          var tokens, count;\n\n          if (elem.type === 'tag') {\n            switch (elem.name.toLowerCase()) {\n              case 'th':\n                tokens = formatHeading(elem, fn, options).split('\\n');\n                rows.push(compact(tokens));\n                break;\n\n              case 'td':\n                tokens = fn(elem.children, options).split('\\n');\n                rows.push(compact(tokens)); // Fill colspans with empty values\n\n                if (elem.attribs && elem.attribs.colspan) {\n                  count = elem.attribs.colspan - 1 || 0;\n                  times(count, function () {\n                    rows.push(['']);\n                  });\n                }\n\n                break;\n            }\n          }\n        });\n        rows = helper.arrayZip(rows);\n        rows.forEach(function (row) {\n          row = row.map(function (col) {\n            return col || '';\n          });\n          table.push(row);\n        });\n        break;\n    }\n  }\n}\n\nfunction formatBlockquote(elem, fn, options) {\n  return '> ' + fn(elem.children, options) + '\\n';\n}\n\nexports.text = formatText;\nexports.image = formatImage;\nexports.lineBreak = formatLineBreak;\nexports.paragraph = formatParagraph;\nexports.anchor = formatAnchor;\nexports.heading = formatHeading;\nexports.table = formatTable;\nexports.orderedList = formatOrderedList;\nexports.unorderedList = formatUnorderedList;\nexports.listItem = formatListItem;\nexports.horizontalLine = formatHorizontalLine;\nexports.blockquote = formatBlockquote;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/html-to-text/lib/formatter.js"],"names":["max","require","compact","times","trimStart","padEnd","he","helper","formatText","elem","options","text","data","decode","decodeOptions","isInPre","wordwrap","trimLeadingSpace","formatImage","ignoreImage","result","attribs","alt","src","formatLineBreak","fn","children","formatParagraph","paragraph","singleNewLineParagraphs","formatHeading","heading","uppercaseHeadings","toUpperCase","formatAnchor","href","storedCharCount","lineCharCount","ignoreHref","replace","noAnchorUrl","linkHrefBaseUrl","indexOf","hideLinkHrefIfSameAsText","replaceAll","noLinkBrackets","formatHorizontalLine","repeat","formatListItem","prefix","Object","assign","length","whiteSpaceRegex","formatUnorderedList","unorderedListItemPrefix","nonWhiteSpaceChildren","filter","child","type","test","forEach","formatOrderedList","typeFunction","olType","start","i","String","fromCharCode","Number","maxLength","toString","index","spacing","tableToString","table","widths","map","row","col","arrayZip","trim","formatTable","tryParseRows","name","toLowerCase","rows","tokens","count","split","push","colspan","formatBlockquote","exports","image","lineBreak","anchor","orderedList","unorderedList","listItem","horizontalLine","blockquote"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,YAAD,CAAjB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,cAAD,CAAnB;;AAEA,IAAIG,SAAS,GAAGH,OAAO,CAAC,kBAAD,CAAvB;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,eAAD,CAApB;;AAEA,IAAIK,EAAE,GAAGL,OAAO,CAAC,IAAD,CAAhB;;AAEA,IAAIM,MAAM,GAAGN,OAAO,CAAC,UAAD,CAApB;;AAEA,SAASO,UAAT,CAAoBC,IAApB,EAA0BC,OAA1B,EAAmC;AACjC,MAAIC,IAAI,GAAGF,IAAI,CAACG,IAAL,IAAa,EAAxB;AACAD,EAAAA,IAAI,GAAGL,EAAE,CAACO,MAAH,CAAUF,IAAV,EAAgBD,OAAO,CAACI,aAAxB,CAAP;;AAEA,MAAIJ,OAAO,CAACK,OAAZ,EAAqB;AACnB,WAAOJ,IAAP;AACD,GAFD,MAEO;AACL,WAAOJ,MAAM,CAACS,QAAP,CAAgBP,IAAI,CAACQ,gBAAL,GAAwBb,SAAS,CAACO,IAAD,CAAjC,GAA0CA,IAA1D,EAAgED,OAAhE,CAAP;AACD;AACF;;AAED,SAASQ,WAAT,CAAqBT,IAArB,EAA2BC,OAA3B,EAAoC;AAClC,MAAIA,OAAO,CAACS,WAAZ,EAAyB;AACvB,WAAO,EAAP;AACD;;AAED,MAAIC,MAAM,GAAG,EAAb;AAAA,MAAiBC,OAAO,GAAGZ,IAAI,CAACY,OAAL,IAAgB,EAA3C;;AACA,MAAIA,OAAO,CAACC,GAAZ,EAAiB;AACfF,IAAAA,MAAM,IAAId,EAAE,CAACO,MAAH,CAAUQ,OAAO,CAACC,GAAlB,EAAuBZ,OAAO,CAACI,aAA/B,CAAV;;AACA,QAAIO,OAAO,CAACE,GAAZ,EAAiB;AACfH,MAAAA,MAAM,IAAI,GAAV;AACD;AACF;;AACD,MAAIC,OAAO,CAACE,GAAZ,EAAiB;AACfH,IAAAA,MAAM,IAAI,MAAMC,OAAO,CAACE,GAAd,GAAoB,GAA9B;AACD;;AACD,SAAQH,MAAR;AACD;;AAED,SAASI,eAAT,CAAyBf,IAAzB,EAA+BgB,EAA/B,EAAmCf,OAAnC,EAA4C;AAC1C,SAAO,OAAOe,EAAE,CAAChB,IAAI,CAACiB,QAAN,EAAgBhB,OAAhB,CAAhB;AACD;;AAED,SAASiB,eAAT,CAAyBlB,IAAzB,EAA+BgB,EAA/B,EAAmCf,OAAnC,EAA4C;AAC1C,MAAIkB,SAAS,GAAGH,EAAE,CAAChB,IAAI,CAACiB,QAAN,EAAgBhB,OAAhB,CAAlB;;AACA,MAAIA,OAAO,CAACmB,uBAAZ,EAAqC;AACnC,WAAOD,SAAS,GAAG,IAAnB;AACD,GAFD,MAEO;AACL,WAAOA,SAAS,GAAG,MAAnB;AACD;AACF;;AAED,SAASE,aAAT,CAAuBrB,IAAvB,EAA6BgB,EAA7B,EAAiCf,OAAjC,EAA0C;AACxC,MAAIqB,OAAO,GAAGN,EAAE,CAAChB,IAAI,CAACiB,QAAN,EAAgBhB,OAAhB,CAAhB;;AACA,MAAIA,OAAO,CAACsB,iBAAZ,EAA+B;AAC7BD,IAAAA,OAAO,GAAGA,OAAO,CAACE,WAAR,EAAV;AACD;;AACD,SAAOF,OAAO,GAAG,IAAjB;AACD,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASG,YAAT,CAAsBzB,IAAtB,EAA4BgB,EAA5B,EAAgCf,OAAhC,EAAyC;AACvC,MAAIyB,IAAI,GAAG,EAAX,CADuC,CAEvC;;AACA,MAAIC,eAAe,GAAG1B,OAAO,CAAC2B,aAA9B;AACA,MAAI1B,IAAI,GAAGc,EAAE,CAAChB,IAAI,CAACiB,QAAL,IAAiB,EAAlB,EAAsBhB,OAAtB,CAAb;;AACA,MAAI,CAACC,IAAL,EAAW;AACTA,IAAAA,IAAI,GAAG,EAAP;AACD;;AAED,MAAIS,MAAM,GAAGX,IAAI,CAACQ,gBAAL,GAAwBb,SAAS,CAACO,IAAD,CAAjC,GAA0CA,IAAvD;;AAEA,MAAI,CAACD,OAAO,CAAC4B,UAAb,EAAyB;AACvB;AACA,QAAI7B,IAAI,CAACY,OAAL,IAAgBZ,IAAI,CAACY,OAAL,CAAac,IAAjC,EAAuC;AACrCA,MAAAA,IAAI,GAAG1B,IAAI,CAACY,OAAL,CAAac,IAAb,CAAkBI,OAAlB,CAA0B,UAA1B,EAAsC,EAAtC,CAAP;AACD;;AACD,QAAIJ,IAAJ,EAAU;AACR,UAAK,CAACzB,OAAO,CAAC8B,WAAV,IAA2B9B,OAAO,CAAC8B,WAAR,IAAuBL,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAlE,EAAwE;AACtE,YAAIzB,OAAO,CAAC+B,eAAR,IAA2BN,IAAI,CAACO,OAAL,CAAa,GAAb,MAAsB,CAArD,EAAwD;AACtDP,UAAAA,IAAI,GAAGzB,OAAO,CAAC+B,eAAR,GAA0BN,IAAjC;AACD;;AACD,YAAI,CAACzB,OAAO,CAACiC,wBAAT,IAAqCR,IAAI,KAAK5B,MAAM,CAACqC,UAAP,CAAkBxB,MAAlB,EAA0B,IAA1B,EAAgC,EAAhC,CAAlD,EAAuF;AACrF,cAAI,CAACV,OAAO,CAACmC,cAAb,EAA6B;AAC3BzB,YAAAA,MAAM,IAAI,OAAOe,IAAP,GAAc,GAAxB;AACD,WAFD,MAEO;AACLf,YAAAA,MAAM,IAAI,MAAMe,IAAhB;AACD;AACF;AACF;AACF;AACF;;AAEDzB,EAAAA,OAAO,CAAC2B,aAAR,GAAwBD,eAAxB;AAEA,SAAO5B,UAAU,CAAC;AAAEI,IAAAA,IAAI,EAAEQ,MAAM,IAAIe,IAAlB;AAAwBlB,IAAAA,gBAAgB,EAAER,IAAI,CAACQ;AAA/C,GAAD,EAAoEP,OAApE,CAAjB;AACD;;AAED,SAASoC,oBAAT,CAA8BrC,IAA9B,EAAoCgB,EAApC,EAAwCf,OAAxC,EAAiD;AAC/C,SAAO,OAAO,IAAIqC,MAAJ,CAAWrC,OAAO,CAACM,QAAnB,CAAP,GAAsC,MAA7C;AACD;;AAED,SAASgC,cAAT,CAAwBC,MAAxB,EAAgCxC,IAAhC,EAAsCgB,EAAtC,EAA0Cf,OAA1C,EAAmD;AACjDA,EAAAA,OAAO,GAAGwC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBzC,OAAlB,CAAV,CADiD,CAEjD;;AACA,MAAIA,OAAO,CAACM,QAAZ,EAAsB;AACpBN,IAAAA,OAAO,CAACM,QAAR,IAAoBiC,MAAM,CAACG,MAA3B;AACD,GALgD,CAMjD;;;AACA,MAAIzC,IAAI,GAAGc,EAAE,CAAChB,IAAI,CAACiB,QAAN,EAAgBhB,OAAhB,CAAb,CAPiD,CAQjD;;AACAC,EAAAA,IAAI,GAAGA,IAAI,CAAC4B,OAAL,CAAa,KAAb,EAAoB,OAAO,IAAIQ,MAAJ,CAAWE,MAAM,CAACG,MAAlB,CAA3B,CAAP,CATiD,CAUjD;;AACA,SAAOH,MAAM,GAAGtC,IAAT,GAAgB,IAAvB;AACD;;AAED,IAAI0C,eAAe,GAAG,OAAtB;;AAEA,SAASC,mBAAT,CAA6B7C,IAA7B,EAAmCgB,EAAnC,EAAuCf,OAAvC,EAAgD;AAC9C,MAAIU,MAAM,GAAG,EAAb;AACA,MAAI6B,MAAM,GAAGvC,OAAO,CAAC6C,uBAArB;AACA,MAAIC,qBAAqB,GAAG,CAAC/C,IAAI,CAACiB,QAAL,IAAiB,EAAlB,EAAsB+B,MAAtB,CAA6B,UAASC,KAAT,EAAgB;AACvE,WAAOA,KAAK,CAACC,IAAN,KAAe,MAAf,IAAyB,CAACN,eAAe,CAACO,IAAhB,CAAqBF,KAAK,CAAC9C,IAA3B,CAAjC;AACD,GAF2B,CAA5B;AAGA4C,EAAAA,qBAAqB,CAACK,OAAtB,CAA8B,UAASpD,IAAT,EAAe;AAC3CW,IAAAA,MAAM,IAAI4B,cAAc,CAACC,MAAD,EAASxC,IAAT,EAAegB,EAAf,EAAmBf,OAAnB,CAAxB;AACD,GAFD;AAGA,SAAOU,MAAM,GAAG,IAAhB;AACD;;AAED,SAAS0C,iBAAT,CAA2BrD,IAA3B,EAAiCgB,EAAjC,EAAqCf,OAArC,EAA8C;AAC5C,MAAIU,MAAM,GAAG,EAAb;AACA,MAAIoC,qBAAqB,GAAG,CAAC/C,IAAI,CAACiB,QAAL,IAAiB,EAAlB,EAAsB+B,MAAtB,CAA6B,UAASC,KAAT,EAAgB;AACvE,WAAOA,KAAK,CAACC,IAAN,KAAe,MAAf,IAAyB,CAACN,eAAe,CAACO,IAAhB,CAAqBF,KAAK,CAAC9C,IAA3B,CAAjC;AACD,GAF2B,CAA5B,CAF4C,CAK5C;;AACA,MAAImD,YAAY,GAAI,YAAW;AAC7B;AACA,QAAIC,MAAM,GAAGvD,IAAI,CAACY,OAAL,CAAasC,IAAb,IAAqB,GAAlC,CAF6B,CAG7B;AACA;;AACA,YAAOK,MAAP;AACE,WAAK,GAAL;AAAU,eAAO,UAASC,KAAT,EAAgBC,CAAhB,EAAmB;AAAE,iBAAOC,MAAM,CAACC,YAAP,CAAoBF,CAAC,GAAGD,KAAJ,GAAY,EAAhC,CAAP;AAA4C,SAAxE;;AACV,WAAK,GAAL;AAAU,eAAO,UAASA,KAAT,EAAgBC,CAAhB,EAAmB;AAAE,iBAAOC,MAAM,CAACC,YAAP,CAAoBF,CAAC,GAAGD,KAAJ,GAAY,EAAhC,CAAP;AAA4C,SAAxE;;AACV,WAAK,GAAL;AACA;AAAS,eAAO,UAASA,KAAT,EAAgBC,CAAhB,EAAmB;AAAE,iBAAOA,CAAC,GAAG,CAAJ,GAAQD,KAAf;AAAsB,SAAlD;AAJX;AAMD,GAXmB,EAApB,CAN4C,CAkB5C;;;AACA,MAAIT,qBAAqB,CAACJ,MAA1B,EAAkC;AAChC;AACA,QAAIa,KAAK,GAAGI,MAAM,CAAC5D,IAAI,CAACY,OAAL,CAAa4C,KAAb,IAAsB,GAAvB,CAAN,GAAoC,CAAhD,CAFgC,CAGhC;;AACA,QAAIK,SAAS,GAAG,CAACd,qBAAqB,CAACJ,MAAtB,GAA+Ba,KAAhC,EAAuCM,QAAvC,GAAkDnB,MAAlE;AACAI,IAAAA,qBAAqB,CAACK,OAAtB,CAA8B,UAASpD,IAAT,EAAeyD,CAAf,EAAkB;AAC9C;AACA,UAAIM,KAAK,GAAGT,YAAY,CAACE,KAAD,EAAQC,CAAR,CAAxB,CAF8C,CAG9C;;AACA,UAAIO,OAAO,GAAGH,SAAS,GAAGE,KAAK,CAACD,QAAN,GAAiBnB,MAA3C;AACA,UAAIH,MAAM,GAAG,MAAMuB,KAAN,GAAc,IAAd,GAAqB,IAAIzB,MAAJ,CAAW0B,OAAX,CAAlC;AACArD,MAAAA,MAAM,IAAI4B,cAAc,CAACC,MAAD,EAASxC,IAAT,EAAegB,EAAf,EAAmBf,OAAnB,CAAxB;AACD,KAPD;AAQD;;AACD,SAAOU,MAAM,GAAG,IAAhB;AACD;;AAED,SAASsD,aAAT,CAAuBC,KAAvB,EAA8B;AAC5B;AACA;AACA,MAAIC,MAAM,GAAGD,KAAK,CAACE,GAAN,CAAU,UAASC,GAAT,EAAc;AACnC,WAAOA,GAAG,CAACD,GAAJ,CAAQ,UAASE,GAAT,EAAc;AAC3B,aAAOA,GAAG,CAAC3B,MAAX;AACD,KAFM,CAAP;AAGD,GAJY,CAAb,CAH4B,CAQ5B;;AACAwB,EAAAA,MAAM,GAAGrE,MAAM,CAACyE,QAAP,CAAgBJ,MAAhB,CAAT,CAT4B,CAU5B;;AACAA,EAAAA,MAAM,GAAGA,MAAM,CAACC,GAAP,CAAW,UAASE,GAAT,EAAc;AAChC,WAAO/E,GAAG,CAAC+E,GAAD,CAAV;AACD,GAFQ,CAAT,CAX4B,CAe5B;;AACA,MAAIpE,IAAI,GAAG,EAAX;AACAgE,EAAAA,KAAK,CAACd,OAAN,CAAc,UAASiB,GAAT,EAAc;AAC1B,QAAIZ,CAAC,GAAG,CAAR;AACAY,IAAAA,GAAG,CAACjB,OAAJ,CAAY,UAASkB,GAAT,EAAc;AACxBpE,MAAAA,IAAI,IAAIN,MAAM,CAAC0E,GAAG,CAACE,IAAJ,EAAD,EAAaL,MAAM,CAACV,CAAC,EAAF,CAAnB,EAA0B,GAA1B,CAAN,GAAuC,KAA/C;AACD,KAFD;AAGAvD,IAAAA,IAAI,IAAI,IAAR;AACD,GAND;AAOA,SAAOA,IAAI,GAAG,IAAd;AACD;;AAED,SAASuE,WAAT,CAAqBzE,IAArB,EAA2BgB,EAA3B,EAA+Bf,OAA/B,EAAwC;AACtC,MAAIiE,KAAK,GAAG,EAAZ;AACAlE,EAAAA,IAAI,CAACiB,QAAL,CAAcmC,OAAd,CAAsBsB,YAAtB;AACA,SAAOT,aAAa,CAACC,KAAD,CAApB;;AAEA,WAASQ,YAAT,CAAsB1E,IAAtB,EAA4B;AAC1B,QAAIA,IAAI,CAACkD,IAAL,KAAc,KAAlB,EAAyB;AACvB;AACD;;AACD,YAAQlD,IAAI,CAAC2E,IAAL,CAAUC,WAAV,EAAR;AACE,WAAK,OAAL;AACA,WAAK,OAAL;AACA,WAAK,OAAL;AACA,WAAK,QAAL;AACE5E,QAAAA,IAAI,CAACiB,QAAL,CAAcmC,OAAd,CAAsBsB,YAAtB;AACA;;AAEF,WAAK,IAAL;AACE,YAAIG,IAAI,GAAG,EAAX;AACA7E,QAAAA,IAAI,CAACiB,QAAL,CAAcmC,OAAd,CAAsB,UAASpD,IAAT,EAAe;AACnC,cAAI8E,MAAJ,EAAYC,KAAZ;;AACA,cAAI/E,IAAI,CAACkD,IAAL,KAAc,KAAlB,EAAyB;AACvB,oBAAQlD,IAAI,CAAC2E,IAAL,CAAUC,WAAV,EAAR;AACE,mBAAK,IAAL;AACEE,gBAAAA,MAAM,GAAGzD,aAAa,CAACrB,IAAD,EAAOgB,EAAP,EAAWf,OAAX,CAAb,CAAiC+E,KAAjC,CAAuC,IAAvC,CAAT;AACAH,gBAAAA,IAAI,CAACI,IAAL,CAAUxF,OAAO,CAACqF,MAAD,CAAjB;AACA;;AAEF,mBAAK,IAAL;AACEA,gBAAAA,MAAM,GAAG9D,EAAE,CAAChB,IAAI,CAACiB,QAAN,EAAgBhB,OAAhB,CAAF,CAA2B+E,KAA3B,CAAiC,IAAjC,CAAT;AACAH,gBAAAA,IAAI,CAACI,IAAL,CAAUxF,OAAO,CAACqF,MAAD,CAAjB,EAFF,CAGE;;AACA,oBAAI9E,IAAI,CAACY,OAAL,IAAgBZ,IAAI,CAACY,OAAL,CAAasE,OAAjC,EAA0C;AACxCH,kBAAAA,KAAK,GAAG/E,IAAI,CAACY,OAAL,CAAasE,OAAb,GAAuB,CAAvB,IAA4B,CAApC;AACAxF,kBAAAA,KAAK,CAACqF,KAAD,EAAQ,YAAW;AACtBF,oBAAAA,IAAI,CAACI,IAAL,CAAU,CAAC,EAAD,CAAV;AACD,mBAFI,CAAL;AAGD;;AACD;AAhBJ;AAkBD;AACF,SAtBD;AAuBAJ,QAAAA,IAAI,GAAG/E,MAAM,CAACyE,QAAP,CAAgBM,IAAhB,CAAP;AACAA,QAAAA,IAAI,CAACzB,OAAL,CAAa,UAASiB,GAAT,EAAc;AACzBA,UAAAA,GAAG,GAAGA,GAAG,CAACD,GAAJ,CAAQ,UAASE,GAAT,EAAc;AAC1B,mBAAOA,GAAG,IAAI,EAAd;AACD,WAFK,CAAN;AAGAJ,UAAAA,KAAK,CAACe,IAAN,CAAWZ,GAAX;AACD,SALD;AAMA;AAxCJ;AA0CD;AACF;;AAED,SAASc,gBAAT,CAA0BnF,IAA1B,EAAgCgB,EAAhC,EAAoCf,OAApC,EAA6C;AAC3C,SAAO,OAAOe,EAAE,CAAChB,IAAI,CAACiB,QAAN,EAAgBhB,OAAhB,CAAT,GAAoC,IAA3C;AACD;;AAEDmF,OAAO,CAAClF,IAAR,GAAeH,UAAf;AACAqF,OAAO,CAACC,KAAR,GAAgB5E,WAAhB;AACA2E,OAAO,CAACE,SAAR,GAAoBvE,eAApB;AACAqE,OAAO,CAACjE,SAAR,GAAoBD,eAApB;AACAkE,OAAO,CAACG,MAAR,GAAiB9D,YAAjB;AACA2D,OAAO,CAAC9D,OAAR,GAAkBD,aAAlB;AACA+D,OAAO,CAAClB,KAAR,GAAgBO,WAAhB;AACAW,OAAO,CAACI,WAAR,GAAsBnC,iBAAtB;AACA+B,OAAO,CAACK,aAAR,GAAwB5C,mBAAxB;AACAuC,OAAO,CAACM,QAAR,GAAmBnD,cAAnB;AACA6C,OAAO,CAACO,cAAR,GAAyBtD,oBAAzB;AACA+C,OAAO,CAACQ,UAAR,GAAqBT,gBAArB","sourcesContent":["var max = require('lodash/max');\nvar compact = require('lodash/compact');\nvar times = require('lodash/times');\n\nvar trimStart = require('lodash/trimStart');\nvar padEnd = require('lodash/padEnd');\n\nvar he = require('he');\n\nvar helper = require('./helper');\n\nfunction formatText(elem, options) {\n  var text = elem.data || \"\";\n  text = he.decode(text, options.decodeOptions);\n\n  if (options.isInPre) {\n    return text;\n  } else {\n    return helper.wordwrap(elem.trimLeadingSpace ? trimStart(text) : text, options);\n  }\n}\n\nfunction formatImage(elem, options) {\n  if (options.ignoreImage) {\n    return '';\n  }\n\n  var result = '', attribs = elem.attribs || {};\n  if (attribs.alt) {\n    result += he.decode(attribs.alt, options.decodeOptions);\n    if (attribs.src) {\n      result += ' ';\n    }\n  }\n  if (attribs.src) {\n    result += '[' + attribs.src + ']';\n  }\n  return (result);\n}\n\nfunction formatLineBreak(elem, fn, options) {\n  return '\\n' + fn(elem.children, options);\n}\n\nfunction formatParagraph(elem, fn, options) {\n  var paragraph = fn(elem.children, options);\n  if (options.singleNewLineParagraphs) {\n    return paragraph + '\\n';\n  } else {\n    return paragraph + '\\n\\n';\n  }\n}\n\nfunction formatHeading(elem, fn, options) {\n  var heading = fn(elem.children, options);\n  if (options.uppercaseHeadings) {\n    heading = heading.toUpperCase();\n  }\n  return heading + '\\n';\n}\n\n// If we have both href and anchor text, format it in a useful manner:\n// - \"anchor text [href]\"\n// Otherwise if we have only anchor text or an href, we return the part we have:\n// - \"anchor text\" or\n// - \"href\"\nfunction formatAnchor(elem, fn, options) {\n  var href = '';\n  // Always get the anchor text\n  var storedCharCount = options.lineCharCount;\n  var text = fn(elem.children || [], options);\n  if (!text) {\n    text = '';\n  }\n\n  var result = elem.trimLeadingSpace ? trimStart(text) : text;\n\n  if (!options.ignoreHref) {\n    // Get the href, if present\n    if (elem.attribs && elem.attribs.href) {\n      href = elem.attribs.href.replace(/^mailto:/, '');\n    }\n    if (href) {\n      if ((!options.noAnchorUrl) || (options.noAnchorUrl && href[0] !== '#')) {\n        if (options.linkHrefBaseUrl && href.indexOf('/') === 0) {\n          href = options.linkHrefBaseUrl + href;\n        }\n        if (!options.hideLinkHrefIfSameAsText || href !== helper.replaceAll(result, '\\n', '')) {\n          if (!options.noLinkBrackets) {\n            result += ' [' + href + ']';\n          } else {\n            result += ' ' + href;\n          }\n        }\n      }\n    }\n  }\n\n  options.lineCharCount = storedCharCount;\n\n  return formatText({ data: result || href, trimLeadingSpace: elem.trimLeadingSpace }, options);\n}\n\nfunction formatHorizontalLine(elem, fn, options) {\n  return '\\n' + '-'.repeat(options.wordwrap) + '\\n\\n';\n}\n\nfunction formatListItem(prefix, elem, fn, options) {\n  options = Object.assign({}, options);\n  // Reduce the wordwrap for sub elements.\n  if (options.wordwrap) {\n    options.wordwrap -= prefix.length;\n  }\n  // Process sub elements.\n  var text = fn(elem.children, options);\n  // Replace all line breaks with line break + prefix spacing.\n  text = text.replace(/\\n/g, '\\n' + ' '.repeat(prefix.length));\n  // Add first prefix and line break at the end.\n  return prefix + text + '\\n';\n}\n\nvar whiteSpaceRegex = /^\\s*$/;\n\nfunction formatUnorderedList(elem, fn, options) {\n  var result = '';\n  var prefix = options.unorderedListItemPrefix;\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function(child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  nonWhiteSpaceChildren.forEach(function(elem) {\n    result += formatListItem(prefix, elem, fn, options);\n  });\n  return result + '\\n';\n}\n\nfunction formatOrderedList(elem, fn, options) {\n  var result = '';\n  var nonWhiteSpaceChildren = (elem.children || []).filter(function(child) {\n    return child.type !== 'text' || !whiteSpaceRegex.test(child.data);\n  });\n  // Return different functions for different OL types\n  var typeFunction = (function() {\n    // Determine type\n    var olType = elem.attribs.type || '1';\n    // TODO Imeplement the other valid types\n    //   Fallback to type '1' function for other valid types\n    switch(olType) {\n      case 'a': return function(start, i) { return String.fromCharCode(i + start + 97);};\n      case 'A': return function(start, i) { return String.fromCharCode(i + start + 65);};\n      case '1':\n      default: return function(start, i) { return i + 1 + start;};\n    }\n  }());\n  // Make sure there are list items present\n  if (nonWhiteSpaceChildren.length) {\n    // Calculate initial start from ol attribute\n    var start = Number(elem.attribs.start || '1') - 1;\n    // Calculate the maximum length to i.\n    var maxLength = (nonWhiteSpaceChildren.length + start).toString().length;\n    nonWhiteSpaceChildren.forEach(function(elem, i) {\n      // Use different function depending on type\n      var index = typeFunction(start, i);\n      // Calculate the needed spacing for nice indentation.\n      var spacing = maxLength - index.toString().length;\n      var prefix = ' ' + index + '. ' + ' '.repeat(spacing);\n      result += formatListItem(prefix, elem, fn, options);\n    });\n  }\n  return result + '\\n';\n}\n\nfunction tableToString(table) {\n  // Determine space width per column\n  // Convert all rows to lengths\n  var widths = table.map(function(row) {\n    return row.map(function(col) {\n      return col.length;\n    });\n  });\n  // Invert rows with colums\n  widths = helper.arrayZip(widths);\n  // Determine the max values for each column\n  widths = widths.map(function(col) {\n    return max(col);\n  });\n\n  // Build the table\n  var text = '';\n  table.forEach(function(row) {\n    var i = 0;\n    row.forEach(function(col) {\n      text += padEnd(col.trim(), widths[i++], ' ') + '   ';\n    });\n    text += '\\n';\n  });\n  return text + '\\n';\n}\n\nfunction formatTable(elem, fn, options) {\n  var table = [];\n  elem.children.forEach(tryParseRows);\n  return tableToString(table);\n\n  function tryParseRows(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    switch (elem.name.toLowerCase()) {\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"center\":\n        elem.children.forEach(tryParseRows);\n        return;\n\n      case 'tr':\n        var rows = [];\n        elem.children.forEach(function(elem) {\n          var tokens, count;\n          if (elem.type === 'tag') {\n            switch (elem.name.toLowerCase()) {\n              case 'th':\n                tokens = formatHeading(elem, fn, options).split('\\n');\n                rows.push(compact(tokens));\n                break;\n\n              case 'td':\n                tokens = fn(elem.children, options).split('\\n');\n                rows.push(compact(tokens));\n                // Fill colspans with empty values\n                if (elem.attribs && elem.attribs.colspan) {\n                  count = elem.attribs.colspan - 1 || 0;\n                  times(count, function() {\n                    rows.push(['']);\n                  });\n                }\n                break;\n            }\n          }\n        });\n        rows = helper.arrayZip(rows);\n        rows.forEach(function(row) {\n          row = row.map(function(col) {\n            return col || '';\n          });\n          table.push(row);\n        });\n        break;\n    }\n  }\n}\n\nfunction formatBlockquote(elem, fn, options) {\n  return '> ' + fn(elem.children, options) + '\\n';\n}\n\nexports.text = formatText;\nexports.image = formatImage;\nexports.lineBreak = formatLineBreak;\nexports.paragraph = formatParagraph;\nexports.anchor = formatAnchor;\nexports.heading = formatHeading;\nexports.table = formatTable;\nexports.orderedList = formatOrderedList;\nexports.unorderedList = formatUnorderedList;\nexports.listItem = formatListItem;\nexports.horizontalLine = formatHorizontalLine;\nexports.blockquote = formatBlockquote;\n"]},"metadata":{},"sourceType":"script"}