{"ast":null,"code":"\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\n\nconst PoolOptions = require(\"./PoolOptions\");\n\nconst ResourceRequest = require(\"./ResourceRequest\");\n\nconst ResourceLoan = require(\"./ResourceLoan\");\n\nconst PooledResource = require(\"./PooledResource\");\n\nconst DefaultEvictor = require(\"./DefaultEvictor\");\n\nconst Deque = require(\"./Deque\");\n\nconst Deferred = require(\"./Deferred\");\n\nconst PriorityQueue = require(\"./PriorityQueue\");\n\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n/**\n * TODO: move me\n */\n\n\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n    factoryValidator(factory);\n    this._config = new PoolOptions(options); // TODO: fix up this ugly glue-ing\n\n    this._Promise = this._config.Promise;\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n\n    this._factoryCreateOperations = new Set();\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n\n    this._factoryDestroyOperations = new Set();\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n\n    this._availableObjects = new Deque();\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n\n    this._testOnBorrowResources = new Set();\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n\n    this._testOnReturnResources = new Set();\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n\n    this._validationOperations = new Set();\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n\n    this._allObjects = new Set();\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n\n    this._resourceLoans = new Map();\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n\n    this._evictionIterator = this._availableObjects.iterator();\n    this._evictor = new Evictor();\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n\n    this._scheduledEviction = null; // create initial resources (if factory.min > 0)\n\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n\n    this._allObjects.delete(pooledResource); // NOTE: this maybe very bad promise usage?\n\n\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n\n    const wrappedDestroyPromise = this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    }); // TODO: maybe ensuring minimum pool size should live outside here\n\n\n    this._ensureMinimum();\n  }\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n\n\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift(); // Mark the resource as in test\n\n\n    pooledResource.test();\n\n    this._testOnBorrowResources.add(pooledResource);\n\n    const validationPromise = this._factory.validate(pooledResource.obj);\n\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(wrappedValidationPromise, this._validationOperations).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n\n        this._destroy(pooledResource);\n\n        this._dispense();\n\n        return;\n      }\n\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n\n\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n\n    return false;\n  }\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n\n\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length; // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;\n    const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);\n\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    } // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n\n\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);\n\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    } // if we aren't testing-on-borrow then lets try to allocate what we can\n\n\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);\n\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n\n\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n\n    if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource); // TODO: do need to trigger anything before we leave?\n\n\n      return false;\n    }\n\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n\n    this._resourceLoans.set(pooledResource.obj, loan);\n\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n\n\n  _trackOperation(operation, set) {\n    set.add(operation);\n    return operation.then(v => {\n      set.delete(operation);\n      return this._Promise.resolve(v);\n    }, e => {\n      set.delete(operation);\n      return this._Promise.reject(e);\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n\n    const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then(resource => {\n      const pooledResource = new PooledResource(resource);\n\n      this._allObjects.add(pooledResource);\n\n      this._addPooledResourceToAvailableObjects(pooledResource);\n    });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {\n      this._dispense(); // Stop bluebird complaining about this side-effect only handler\n      // - a promise was created in a handler but was not returned from it\n      // https://goo.gl/rRqMUw\n\n\n      return null;\n    }).catch(reason => {\n      this.emit(FACTORY_CREATE_ERROR, reason);\n\n      this._dispense();\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n\n    const minShortfall = this._config.min - this._count;\n\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun;) {\n      const iterationResult = this._evictionIterator.next(); // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after chekcing it's length\n\n\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n\n        return;\n      } // if this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n\n\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);\n\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n\n    if (this._started === true) {\n      return;\n    }\n\n    this._started = true;\n\n    this._scheduleEvictorRun();\n\n    this._ensureMinimum();\n  }\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n\n\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n    } // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n\n\n    if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {\n      return this._Promise.reject(new Error(\"max waitingClients count exceeded\"));\n    }\n\n    const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);\n\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n\n\n  use(fn) {\n    return this.acquire().then(resource => {\n      return fn(resource).then(result => {\n        this.release(resource);\n        return result;\n      }, err => {\n        this.destroy(resource);\n        throw err;\n      });\n    });\n  }\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n\n\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n\n\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n\n\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._destroy(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n\n\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled().then(() => {\n      return this.__allResourcesReturned();\n    }).then(() => {\n      this._descheduleEvictorRun();\n    });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n\n    return this._Promise.resolve();\n  } // FIXME: this is a horrific mess\n\n\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values()).map(loan => loan.promise).map(reflector);\n    return this._Promise.all(ps);\n  }\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n\n\n  clear() {\n    const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector); // wait for outstanding factory.create to complete\n\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n\n      const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n\n\n  get _potentiallyAllocableResourceCount() {\n    return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n\n\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n\n\n  get spareResourceCapacity() {\n    return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);\n  }\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n\n\n  get size() {\n    return this._count;\n  }\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n\n\n  get available() {\n    return this._availableObjects.length;\n  }\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n\n\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n\n\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get max() {\n    return this._config.max;\n  }\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get min() {\n    return this._config.min;\n  }\n\n}\n\nmodule.exports = Pool;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/generic-pool/lib/Pool.js"],"names":["EventEmitter","require","factoryValidator","PoolOptions","ResourceRequest","ResourceLoan","PooledResource","DefaultEvictor","Deque","Deferred","PriorityQueue","DequeIterator","reflector","FACTORY_CREATE_ERROR","FACTORY_DESTROY_ERROR","Pool","constructor","Evictor","factory","options","_config","_Promise","Promise","_factory","_draining","_started","_waitingClientsQueue","priorityRange","_factoryCreateOperations","Set","_factoryDestroyOperations","_availableObjects","_testOnBorrowResources","_testOnReturnResources","_validationOperations","_allObjects","_resourceLoans","Map","_evictionIterator","iterator","_evictor","_scheduledEviction","autostart","start","_destroy","pooledResource","invalidate","delete","destroyPromise","destroy","obj","wrappedDestroyPromise","resolve","_trackOperation","catch","reason","emit","_ensureMinimum","_testOnBorrow","length","shift","test","add","validationPromise","validate","wrappedValidationPromise","then","isValid","_dispense","_dispatchPooledResourceToNextWaitingClient","_dispatchResource","numWaitingClients","resourceShortfall","_potentiallyAllocableResourceCount","actualNumberOfResourcesToCreate","Math","min","spareResourceCapacity","i","_createResource","testOnBorrow","desiredNumberOfResourcesToMoveIntoTest","size","actualNumberOfResourcesToMoveIntoTest","actualNumberOfResourcesToDispatch","clientResourceRequest","dequeue","undefined","state","PENDING","_addPooledResourceToAvailableObjects","loan","set","allocate","operation","v","e","reject","factoryPromise","create","wrappedFactoryPromise","resource","minShortfall","_count","_evict","testsToRun","numTestsPerEvictionRun","evictionConfig","softIdleTimeoutMillis","idleTimeoutMillis","testsHaveRun","iterationResult","next","done","reset","value","shouldEvict","evict","remove","_scheduleEvictorRun","evictionRunIntervalMillis","setTimeout","_descheduleEvictorRun","clearTimeout","acquire","priority","Error","maxWaitingClients","resourceRequest","acquireTimeoutMillis","enqueue","promise","use","fn","result","release","err","isBorrowedResource","has","get","deallocate","idle","fifo","push","unshift","drain","__allResourceRequestsSettled","__allResourcesReturned","tail","ps","Array","from","values","map","all","clear","reflectedCreatePromises","reflectedDestroyPromises","max","available","borrowed","pending","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\nconst PoolOptions = require(\"./PoolOptions\");\nconst ResourceRequest = require(\"./ResourceRequest\");\nconst ResourceLoan = require(\"./ResourceLoan\");\nconst PooledResource = require(\"./PooledResource\");\nconst DefaultEvictor = require(\"./DefaultEvictor\");\nconst Deque = require(\"./Deque\");\nconst Deferred = require(\"./Deferred\");\nconst PriorityQueue = require(\"./PriorityQueue\");\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n\n/**\n * TODO: move me\n */\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n\n    factoryValidator(factory);\n\n    this._config = new PoolOptions(options);\n\n    // TODO: fix up this ugly glue-ing\n    this._Promise = this._config.Promise;\n\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n    this._factoryCreateOperations = new Set();\n\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n    this._factoryDestroyOperations = new Set();\n\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n    this._availableObjects = new Deque();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n    this._testOnBorrowResources = new Set();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n    this._testOnReturnResources = new Set();\n\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n    this._validationOperations = new Set();\n\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n    this._allObjects = new Set();\n\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n    this._resourceLoans = new Map();\n\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n    this._evictionIterator = this._availableObjects.iterator();\n\n    this._evictor = new Evictor();\n\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n    this._scheduledEviction = null;\n\n    // create initial resources (if factory.min > 0)\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n    this._allObjects.delete(pooledResource);\n    // NOTE: this maybe very bad promise usage?\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n    const wrappedDestroyPromise = this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(\n      wrappedDestroyPromise,\n      this._factoryDestroyOperations\n    ).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    });\n\n    // TODO: maybe ensuring minimum pool size should live outside here\n    this._ensureMinimum();\n  }\n\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    // Mark the resource as in test\n    pooledResource.test();\n    this._testOnBorrowResources.add(pooledResource);\n    const validationPromise = this._factory.validate(pooledResource.obj);\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(\n      wrappedValidationPromise,\n      this._validationOperations\n    ).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n        this._destroy(pooledResource);\n        this._dispense();\n        return;\n      }\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    return false;\n  }\n\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length;\n\n    // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall =\n      numWaitingClients - this._potentiallyAllocableResourceCount;\n\n    const actualNumberOfResourcesToCreate = Math.min(\n      this.spareResourceCapacity,\n      resourceShortfall\n    );\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    }\n\n    // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest =\n        numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(\n        this._availableObjects.length,\n        desiredNumberOfResourcesToMoveIntoTest\n      );\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    }\n\n    // if we aren't testing-on-borrow then lets try to allocate what we can\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(\n        this._availableObjects.length,\n        numWaitingClients\n      );\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n    if (\n      clientResourceRequest === undefined ||\n      clientResourceRequest.state !== Deferred.PENDING\n    ) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource);\n      // TODO: do need to trigger anything before we leave?\n      return false;\n    }\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n    this._resourceLoans.set(pooledResource.obj, loan);\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n  _trackOperation(operation, set) {\n    set.add(operation);\n\n    return operation.then(\n      v => {\n        set.delete(operation);\n        return this._Promise.resolve(v);\n      },\n      e => {\n        set.delete(operation);\n        return this._Promise.reject(e);\n      }\n    );\n  }\n\n  /**\n   * @private\n   */\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n    const wrappedFactoryPromise = this._Promise\n      .resolve(factoryPromise)\n      .then(resource => {\n        const pooledResource = new PooledResource(resource);\n        this._allObjects.add(pooledResource);\n        this._addPooledResourceToAvailableObjects(pooledResource);\n      });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations)\n      .then(() => {\n        this._dispense();\n        // Stop bluebird complaining about this side-effect only handler\n        // - a promise was created in a handler but was not returned from it\n        // https://goo.gl/rRqMUw\n        return null;\n      })\n      .catch(reason => {\n        this.emit(FACTORY_CREATE_ERROR, reason);\n        this._dispense();\n      });\n  }\n\n  /**\n   * @private\n   */\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n    const minShortfall = this._config.min - this._count;\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(\n      this._config.numTestsPerEvictionRun,\n      this._availableObjects.length\n    );\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun; ) {\n      const iterationResult = this._evictionIterator.next();\n\n      // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after chekcing it's length\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n        return;\n      }\n      // if this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(\n        evictionConfig,\n        resource,\n        this._availableObjects.length\n      );\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n    if (this._started === true) {\n      return;\n    }\n    this._started = true;\n    this._scheduleEvictorRun();\n    this._ensureMinimum();\n  }\n\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(\n        new Error(\"pool is draining and cannot accept work\")\n      );\n    }\n\n    // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n    if (\n      this.spareResourceCapacity < 1 &&\n      this._availableObjects.length < 1 &&\n      this._config.maxWaitingClients !== undefined &&\n      this._waitingClientsQueue.length >= this._config.maxWaitingClients\n    ) {\n      return this._Promise.reject(\n        new Error(\"max waitingClients count exceeded\")\n      );\n    }\n\n    const resourceRequest = new ResourceRequest(\n      this._config.acquireTimeoutMillis,\n      this._Promise\n    );\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n  use(fn) {\n    return this.acquire().then(resource => {\n      return fn(resource).then(\n        result => {\n          this.release(resource);\n          return result;\n        },\n        err => {\n          this.destroy(resource);\n          throw err;\n        }\n      );\n    });\n  }\n\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._destroy(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled()\n      .then(() => {\n        return this.__allResourcesReturned();\n      })\n      .then(() => {\n        this._descheduleEvictorRun();\n      });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n    return this._Promise.resolve();\n  }\n\n  // FIXME: this is a horrific mess\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values())\n      .map(loan => loan.promise)\n      .map(reflector);\n    return this._Promise.all(ps);\n  }\n\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n  clear() {\n    const reflectedCreatePromises = Array.from(\n      this._factoryCreateOperations\n    ).map(reflector);\n\n    // wait for outstanding factory.create to complete\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n      const reflectedDestroyPromises = Array.from(\n        this._factoryDestroyOperations\n      ).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n  get _potentiallyAllocableResourceCount() {\n    return (\n      this._availableObjects.length +\n      this._testOnBorrowResources.size +\n      this._testOnReturnResources.size +\n      this._factoryCreateOperations.size\n    );\n  }\n\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n  get spareResourceCapacity() {\n    return (\n      this._config.max -\n      (this._allObjects.size + this._factoryCreateOperations.size)\n    );\n  }\n\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n  get size() {\n    return this._count;\n  }\n\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n  get max() {\n    return this._config.max;\n  }\n\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n  get min() {\n    return this._config.min;\n  }\n}\n\nmodule.exports = Pool;\n"]},"metadata":{},"sourceType":"script"}