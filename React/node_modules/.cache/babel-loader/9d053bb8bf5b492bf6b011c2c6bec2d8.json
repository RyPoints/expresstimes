{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar crypto = require('crypto');\n\nrequire('date-utils'); // Adds a number of convenience methods to the builtin Date object.\n\n\nvar Logger = require('./log').Logger;\n\nvar constants = require('./constants');\n\nvar cacheConstants = constants.Cache;\nvar TokenResponseFields = constants.TokenResponseFields; // TODO: remove this.\n// There is a PM requirement that developers be able to look in to the cache and manipulate the cache based on\n// the parameters (authority, resource, clientId, userId), in any combination.  They must be able find, add, and remove\n// tokens based on those parameters.  Any default cache that the API supplies must allow for this query pattern.\n// This has the following implications:\n//  The developer must not be required to calculate any special fields, such as hashes or unique keys.\n//\n//  The default cache implementation can not include optimizations that break the previous requirement.\n//  This means that we can only do complete scans of the data and equality can only be calculated based on\n//  equality of all of the individual fields.\n//\n//  The cache interface can not make any assumption about the query efficency of the cache nor can\n//  it help in optimizing those queries.\n//\n//  There is no simple sorting optimization, rather a series of indexes, and index intersection would\n//  be necessary.\n//\n//  If for some reason the developer tries to update the cache with a new entry that may be a refresh\n//  token, they will not know that they need to update all of the refresh tokens or they may get strange\n//  behavior.\n//\n//  Related to the above, there is no definition of a coherent cache.  And if there was there would be\n//  no way for our API to enforce it.  What about duplicates?\n//\n// there be a single cache entry per (authority, resource, clientId)\n// tuple, with no special tokens (i.e. MRRT tokens)\n// Required cache operations\n//\n// Constants\n\nvar METADATA_CLIENTID = '_clientId';\nvar METADATA_AUTHORITY = '_authority';\n\nfunction nop(placeHolder, callback) {\n  callback();\n}\n/*\r\n * This is a place holder cache that does nothing.\r\n */\n\n\nvar nopCache = {\n  add: nop,\n  addMany: nop,\n  remove: nop,\n  removeMany: nop,\n  find: nop\n};\n\nfunction createTokenHash(token) {\n  var hashAlg = crypto.createHash(cacheConstants.HASH_ALGORITHM);\n  hashAlg.update(token, 'utf8');\n  return hashAlg.digest('base64');\n}\n\nfunction createTokenIdMessage(entry) {\n  var accessTokenHash = createTokenHash(entry[TokenResponseFields.ACCESS_TOKEN]);\n  var message = 'AccessTokenId: ' + accessTokenHash;\n\n  if (entry[TokenResponseFields.REFRESH_TOKEN]) {\n    var refreshTokenHash = createTokenHash(entry[TokenResponseFields.REFRESH_TOKEN]);\n    message += ', RefreshTokenId: ' + refreshTokenHash;\n  }\n\n  return message;\n}\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback RefreshEntryFunction\r\n * @memberOf CacheDriver\r\n * @param {object}  tokenResponse    A token response to refresh.\r\n * @param {string}  [resource]       The resource for which to obtain the token if it is different from the original token.\r\n * @param {AcquireTokenCallback} callback   Called on completion with an error or a new entry to add to the cache.\r\n */\n\n/**\r\n * Constructs a new CacheDriver object.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} authority\r\n * @param {TokenCache} [cache]     A token cache to use.  If none is passed then the CacheDriver instance\r\n *                                 will not cache.\r\n * @param {RefreshEntryFunction} refreshFunction\r\n */\n\n\nfunction CacheDriver(callContext, authority, resource, clientId, cache, refreshFunction) {\n  this._callContext = callContext;\n  this._log = new Logger('CacheDriver', callContext._logContext);\n  this._authority = authority;\n  this._resource = resource;\n  this._clientId = clientId;\n  this._cache = cache || nopCache;\n  this._refreshFunction = refreshFunction;\n}\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback QueryCallback\r\n * @memberOf CacheDriver\r\n * @param {Error}  [error]           If the request fails this parameter will contain an Error object.\r\n * @param {Array} [response]   On a succesful request returns an array of matched entries.\r\n */\n\n/**\r\n * The cache driver query function.  Ensures that all queries are authority specific.\r\n * @param  {object}   query    A query object.  Can contain a clientId or userId or both.\r\n * @param  {QueryCallback} callback\r\n */\n\n\nCacheDriver.prototype._find = function (query, callback) {\n  this._cache.find(query, callback);\n};\n/**\r\n * Queries for all entries that might satisfy a request for a cached token.\r\n * @param  {object}   query    A query object.  Can contain a clientId or userId or both.\r\n * @param  {QueryCallback} callback\r\n */\n\n\nCacheDriver.prototype._getPotentialEntries = function (query, callback) {\n  var self = this;\n  var potentialEntriesQuery = {};\n\n  if (query.clientId) {\n    potentialEntriesQuery[METADATA_CLIENTID] = query.clientId;\n  }\n\n  if (query.userId) {\n    potentialEntriesQuery[TokenResponseFields.USER_ID] = query.userId;\n  }\n\n  this._log.verbose('Looking for potential cache entries:');\n\n  this._log.verbose(JSON.stringify(potentialEntriesQuery), true);\n\n  this._find(potentialEntriesQuery, function (err, entries) {\n    self._log.verbose('Found ' + entries.length + ' potential entries.');\n\n    callback(err, entries);\n    return;\n  });\n};\n/**\r\n * Finds all multi resource refresh tokens in the cache.\r\n * Refresh token is bound to userId, clientId. \r\n * @param  {QueryCallback} callback\r\n */\n\n\nCacheDriver.prototype._findMRRTTokensForUser = function (user, callback) {\n  this._find({\n    isMRRT: true,\n    userId: user,\n    _clientId: this._clientId\n  }, callback);\n};\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback SingleEntryCallback\r\n * @memberOf CacheDriver\r\n * @param {Error}  [error]           If the request fails this parameter will contain an Error object.\r\n * @param {object} [response]   On a succesful request returns a single cache entry.\r\n */\n\n/**\r\n * Finds a single entry that matches the query.  If multiple entries are found that satisfy the query\r\n * then an error will be returned.\r\n * @param {object}  query A query object.\r\n * @param {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._loadSingleEntryFromCache = function (query, callback) {\n  var self = this;\n\n  this._getPotentialEntries(query, function (err, potentialEntries) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var returnVal;\n    var isResourceTenantSpecific;\n\n    if (potentialEntries && 0 < potentialEntries.length) {\n      var resourceTenantSpecificEntries = _.where(potentialEntries, {\n        resource: self._resource,\n        _authority: self._authority\n      });\n\n      if (!resourceTenantSpecificEntries || 0 === resourceTenantSpecificEntries.length) {\n        self._log.verbose('No resource specific cache entries found.'); // There are no resource specific entries.  Find an MRRT token.\n\n\n        var mrrtTokens = _.where(potentialEntries, {\n          isMRRT: true\n        });\n\n        if (mrrtTokens && mrrtTokens.length > 0) {\n          self._log.verbose('Found an MRRT token.');\n\n          returnVal = mrrtTokens[0];\n        } else {\n          self._log.verbose('No MRRT tokens found.');\n        }\n      } else if (resourceTenantSpecificEntries.length === 1) {\n        self._log.verbose('Resource specific token found.');\n\n        returnVal = resourceTenantSpecificEntries[0];\n        isResourceTenantSpecific = true;\n      } else {\n        callback(self._log.createError('More than one token matches the criteria.  The result is ambiguous.'));\n        return;\n      }\n    }\n\n    if (returnVal) {\n      self._log.verbose('Returning token from cache lookup');\n\n      self._log.verbose('Returning token from cache lookup, ' + createTokenIdMessage(returnVal), true);\n    }\n\n    callback(null, returnVal, isResourceTenantSpecific);\n  });\n};\n/**\r\n * The response from a token refresh request never contains an id_token and therefore no\r\n * userInfo can be created from the response.  This function creates a new cache entry\r\n * combining the id_token based info and cache metadata from the cache entry that was refreshed with the\r\n * new tokens in the refresh response.\r\n * @param  {object} entry           A cache entry corresponding to the resfreshResponse.\r\n * @param  {object} refreshResponse The response from a token refresh request for the entry parameter.\r\n * @return {object}                 A new cache entry.\r\n */\n\n\nCacheDriver.prototype._createEntryFromRefresh = function (entry, refreshResponse) {\n  var newEntry = _.clone(entry);\n\n  newEntry = _.extend(newEntry, refreshResponse);\n\n  if (entry.isMRRT && this._authority !== entry[METADATA_AUTHORITY]) {\n    newEntry[METADATA_AUTHORITY] = this._authority;\n  }\n\n  this._log.verbose('Created new cache entry from refresh response.');\n\n  return newEntry;\n};\n\nCacheDriver.prototype._replaceEntry = function (entryToReplace, newEntry, callback) {\n  var self = this;\n  this.remove(entryToReplace, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self.add(newEntry, callback);\n  });\n};\n/**\r\n * Given an expired cache entry refreshes it and updates the cache.\r\n * @param  {object}   entry              A cache entry with an MRRT to refresh for another resource.\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._refreshExpiredEntry = function (entry, callback) {\n  var self = this;\n\n  this._refreshFunction(entry, null, function (err, tokenResponse) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var newEntry = self._createEntryFromRefresh(entry, tokenResponse);\n\n    self._replaceEntry(entry, newEntry, function (err) {\n      if (err) {\n        self._log.error('error refreshing expired token', err, true);\n      } else {\n        self._log.info('Returning token refreshed after expiry.');\n      }\n\n      callback(err, newEntry);\n    });\n  });\n};\n/**\r\n * Given a cache entry with an MRRT will acquire a new token for a new resource via the MRRT, and cache it.\r\n * @param  {object}   entry              A cache entry with an MRRT to refresh for another resource.\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._acquireNewTokenFromMrrt = function (entry, callback) {\n  var self = this;\n\n  this._refreshFunction(entry, this._resource, function (err, tokenResponse) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var newEntry = self._createEntryFromRefresh(entry, tokenResponse);\n\n    self.add(newEntry, function (err) {\n      if (err) {\n        self._log.error('error refreshing mrrt', err, true);\n      } else {\n        self._log.info('Returning token derived from mrrt refresh.');\n      }\n\n      callback(err, newEntry);\n    });\n  });\n};\n/**\r\n * Given a token this function will refresh it if it is either expired, or an MRRT.\r\n * @param  {object}   entry              A cache entry to refresh if necessary.\r\n * @param  {Boolean}  isResourceSpecific Indicates whether this token is appropriate for the resource for which\r\n *                                       it was requested or whether it is possibly an MRRT token for which\r\n *                                       a resource specific access token should be acquired.\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._refreshEntryIfNecessary = function (entry, isResourceSpecific, callback) {\n  var expiryDate = entry[TokenResponseFields.EXPIRES_ON]; // Add some buffer in to the time comparison to account for clock skew or latency.\n\n  var nowPlusBuffer = new Date().addMinutes(constants.Misc.CLOCK_BUFFER);\n\n  if (isResourceSpecific && nowPlusBuffer.isAfter(expiryDate)) {\n    this._log.info('Cached token is expired.  Refreshing: ' + expiryDate);\n\n    this._refreshExpiredEntry(entry, callback);\n\n    return;\n  } else if (!isResourceSpecific && entry.isMRRT) {\n    this._log.info('Acquiring new access token from MRRT token.');\n\n    this._acquireNewTokenFromMrrt(entry, callback);\n\n    return;\n  } else {\n    callback(null, entry);\n  }\n};\n/**\r\n * Finds a single entry in the cache that matches the query or fails if more than one match is found.\r\n * @param  {object}   query    A query object\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype.find = function (query, callback) {\n  var self = this;\n  query = query || {};\n\n  this._log.verbose('finding using query');\n\n  this._log.verbose('finding with query:' + JSON.stringify(query), true);\n\n  this._loadSingleEntryFromCache(query, function (err, entry, isResourceTenantSpecific) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (!entry) {\n      callback();\n      return;\n    }\n\n    self._refreshEntryIfNecessary(entry, isResourceTenantSpecific, function (err, newEntry) {\n      callback(err, newEntry);\n      return;\n    });\n  });\n};\n/**\r\n * Removes a single entry from the cache.\r\n * @param  {object}   entry    The entry to remove.\r\n * @param  {Function} callback Called on completion.  The first parameter may contain an error.\r\n */\n\n\nCacheDriver.prototype.remove = function (entry, callback) {\n  this._log.verbose('Removing entry.');\n\n  return this._cache.remove([entry], function (err) {\n    callback(err);\n    return;\n  });\n};\n/**\r\n * Removes a collection of entries from the cache in a single batch operation.\r\n * @param  {Array}   entries  An array of cache entries to remove.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\n\n\nCacheDriver.prototype._removeMany = function (entries, callback) {\n  this._log.verbose('Remove many: ' + entries.length);\n\n  this._cache.remove(entries, function (err) {\n    callback(err);\n    return;\n  });\n};\n/**\r\n * Adds a collection of entries to the cache in a single batch operation.\r\n * @param {Array}   entries  An array of entries to add to the cache.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\n\n\nCacheDriver.prototype._addMany = function (entries, callback) {\n  this._log.verbose('Add many: ' + entries.length);\n\n  this._cache.add(entries, function (err) {\n    callback(err);\n    return;\n  });\n};\n/*\r\n * Tests whether the passed entry is a multi resource refresh token.\r\n * Somewhat mysteriously the presense of a resource field in a returned\r\n * token response indicates that the response is an MRRT.\r\n * @param  {object}  entry\r\n * @return {Boolean}       true if the entry is an MRRT.\r\n */\n\n\nfunction isMRRT(entry) {\n  return entry.resource ? true : false;\n}\n/**\r\n * Given an cache entry this function finds all of the MRRT tokens already in the cache\r\n * and updates them with the refresh_token of the passed in entry.\r\n * @param  {object}   entry    The entry from which to get an updated refresh_token\r\n * @param  {Function} callback Called back on completion.  The first parameter may contain an error.\r\n */\n\n\nCacheDriver.prototype._updateRefreshTokens = function (entry, callback) {\n  var self = this;\n\n  if (isMRRT(entry)) {\n    this._findMRRTTokensForUser(entry.userId, function (err, mrrtTokens) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (!mrrtTokens || 0 === mrrtTokens.length) {\n        callback();\n        return;\n      }\n\n      self._log.verbose('Updating ' + mrrtTokens.length + ' cached refresh tokens.');\n\n      self._removeMany(mrrtTokens, function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        for (var i = 0; i < mrrtTokens.length; i++) {\n          mrrtTokens[i][TokenResponseFields.REFRESH_TOKEN] = entry[TokenResponseFields.REFRESH_TOKEN];\n        }\n\n        self._addMany(mrrtTokens, function (err) {\n          callback(err);\n          return;\n        });\n      });\n    });\n  } else {\n    callback();\n    return;\n  }\n};\n/**\r\n * Checks to see if the entry has cache metadata already.  If it does\r\n * then it probably came from a refresh operation and the metadata\r\n * was copied from the originating entry.\r\n * @param  {object} entry The entry to check\r\n * @return {bool}         Returns true if the entry has already been augmented\r\n *                        with cache metadata.\r\n */\n\n\nCacheDriver.prototype._entryHasMetadata = function (entry) {\n  return _.has(entry, METADATA_CLIENTID) && _.has(entry, METADATA_AUTHORITY);\n};\n\nCacheDriver.prototype._augmentEntryWithCacheMetadata = function (entry) {\n  if (this._entryHasMetadata(entry)) {\n    return;\n  }\n\n  if (isMRRT(entry)) {\n    this._log.verbose('Added entry is MRRT');\n\n    entry.isMRRT = true;\n  } else {\n    entry.resource = this._resource;\n  }\n\n  entry[METADATA_CLIENTID] = this._clientId;\n  entry[METADATA_AUTHORITY] = this._authority;\n};\n/**\r\n * Adds a single entry to the cache.\r\n * @param {object}   entry    The entry to add.\r\n * @param {string}   clientId The id of this client app.\r\n * @param {string}   resource The id of the resource for which the cached token was obtained.\r\n * @param {Function} callback Called back on completion.  The first parameter may contain an error.\r\n */\n\n\nCacheDriver.prototype.add = function (entry, callback) {\n  var self = this;\n\n  this._log.verbose('Adding entry');\n\n  this._log.verbose('Adding entry, ' + createTokenIdMessage(entry));\n\n  this._augmentEntryWithCacheMetadata(entry);\n\n  this._updateRefreshTokens(entry, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self._cache.add([entry], function (err) {\n      callback(err);\n      return;\n    });\n  });\n};\n\nmodule.exports = CacheDriver;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/adal-node/lib/cache-driver.js"],"names":["_","require","crypto","Logger","constants","cacheConstants","Cache","TokenResponseFields","METADATA_CLIENTID","METADATA_AUTHORITY","nop","placeHolder","callback","nopCache","add","addMany","remove","removeMany","find","createTokenHash","token","hashAlg","createHash","HASH_ALGORITHM","update","digest","createTokenIdMessage","entry","accessTokenHash","ACCESS_TOKEN","message","REFRESH_TOKEN","refreshTokenHash","CacheDriver","callContext","authority","resource","clientId","cache","refreshFunction","_callContext","_log","_logContext","_authority","_resource","_clientId","_cache","_refreshFunction","prototype","_find","query","_getPotentialEntries","self","potentialEntriesQuery","userId","USER_ID","verbose","JSON","stringify","err","entries","length","_findMRRTTokensForUser","user","isMRRT","_loadSingleEntryFromCache","potentialEntries","returnVal","isResourceTenantSpecific","resourceTenantSpecificEntries","where","mrrtTokens","createError","_createEntryFromRefresh","refreshResponse","newEntry","clone","extend","_replaceEntry","entryToReplace","_refreshExpiredEntry","tokenResponse","error","info","_acquireNewTokenFromMrrt","_refreshEntryIfNecessary","isResourceSpecific","expiryDate","EXPIRES_ON","nowPlusBuffer","Date","addMinutes","Misc","CLOCK_BUFFER","isAfter","_removeMany","_addMany","_updateRefreshTokens","i","_entryHasMetadata","has","_augmentEntryWithCacheMetadata","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * @copyright\r\n * Copyright © Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n\r\n'use strict';\r\n\r\nvar _ = require('underscore');\r\nvar crypto = require('crypto');\r\nrequire('date-utils');  // Adds a number of convenience methods to the builtin Date object.\r\n\r\nvar Logger = require('./log').Logger;\r\nvar constants = require('./constants');\r\nvar cacheConstants = constants.Cache;\r\nvar TokenResponseFields = constants.TokenResponseFields;\r\n\r\n// TODO: remove this.\r\n// There is a PM requirement that developers be able to look in to the cache and manipulate the cache based on\r\n// the parameters (authority, resource, clientId, userId), in any combination.  They must be able find, add, and remove\r\n// tokens based on those parameters.  Any default cache that the API supplies must allow for this query pattern.\r\n// This has the following implications:\r\n//  The developer must not be required to calculate any special fields, such as hashes or unique keys.\r\n//\r\n//  The default cache implementation can not include optimizations that break the previous requirement.\r\n//  This means that we can only do complete scans of the data and equality can only be calculated based on\r\n//  equality of all of the individual fields.\r\n//\r\n//  The cache interface can not make any assumption about the query efficency of the cache nor can\r\n//  it help in optimizing those queries.\r\n//\r\n//  There is no simple sorting optimization, rather a series of indexes, and index intersection would\r\n//  be necessary.\r\n//\r\n//  If for some reason the developer tries to update the cache with a new entry that may be a refresh\r\n//  token, they will not know that they need to update all of the refresh tokens or they may get strange\r\n//  behavior.\r\n//\r\n//  Related to the above, there is no definition of a coherent cache.  And if there was there would be\r\n//  no way for our API to enforce it.  What about duplicates?\r\n//\r\n// there be a single cache entry per (authority, resource, clientId)\r\n// tuple, with no special tokens (i.e. MRRT tokens)\r\n// Required cache operations\r\n//\r\n\r\n// Constants\r\nvar METADATA_CLIENTID = '_clientId';\r\nvar METADATA_AUTHORITY = '_authority';\r\n\r\nfunction nop(placeHolder, callback) {\r\n  callback();\r\n}\r\n\r\n/*\r\n * This is a place holder cache that does nothing.\r\n */\r\nvar nopCache = {\r\n  add : nop,\r\n  addMany : nop,\r\n  remove : nop,\r\n  removeMany : nop,\r\n  find : nop\r\n};\r\n\r\nfunction createTokenHash(token) {\r\n  var hashAlg = crypto.createHash(cacheConstants.HASH_ALGORITHM);\r\n  hashAlg.update(token, 'utf8');\r\n  return hashAlg.digest('base64');\r\n}\r\n\r\nfunction createTokenIdMessage(entry) {\r\n  var accessTokenHash = createTokenHash(entry[TokenResponseFields.ACCESS_TOKEN]);\r\n  var message = 'AccessTokenId: ' + accessTokenHash;\r\n  if (entry[TokenResponseFields.REFRESH_TOKEN]) {\r\n    var refreshTokenHash = createTokenHash(entry[TokenResponseFields.REFRESH_TOKEN]);\r\n    message += ', RefreshTokenId: ' + refreshTokenHash;\r\n  }\r\n  return message;\r\n}\r\n\r\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback RefreshEntryFunction\r\n * @memberOf CacheDriver\r\n * @param {object}  tokenResponse    A token response to refresh.\r\n * @param {string}  [resource]       The resource for which to obtain the token if it is different from the original token.\r\n * @param {AcquireTokenCallback} callback   Called on completion with an error or a new entry to add to the cache.\r\n */\r\n\r\n/**\r\n * Constructs a new CacheDriver object.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} authority\r\n * @param {TokenCache} [cache]     A token cache to use.  If none is passed then the CacheDriver instance\r\n *                                 will not cache.\r\n * @param {RefreshEntryFunction} refreshFunction\r\n */\r\nfunction CacheDriver(callContext, authority, resource, clientId, cache, refreshFunction) {\r\n  this._callContext = callContext;\r\n  this._log = new Logger('CacheDriver', callContext._logContext);\r\n  this._authority = authority;\r\n  this._resource = resource;\r\n  this._clientId = clientId;\r\n  this._cache = cache || nopCache;\r\n  this._refreshFunction = refreshFunction;\r\n}\r\n\r\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback QueryCallback\r\n * @memberOf CacheDriver\r\n * @param {Error}  [error]           If the request fails this parameter will contain an Error object.\r\n * @param {Array} [response]   On a succesful request returns an array of matched entries.\r\n */\r\n\r\n/**\r\n * The cache driver query function.  Ensures that all queries are authority specific.\r\n * @param  {object}   query    A query object.  Can contain a clientId or userId or both.\r\n * @param  {QueryCallback} callback\r\n */\r\nCacheDriver.prototype._find = function(query, callback) {\r\n  this._cache.find(query, callback);\r\n};\r\n\r\n/**\r\n * Queries for all entries that might satisfy a request for a cached token.\r\n * @param  {object}   query    A query object.  Can contain a clientId or userId or both.\r\n * @param  {QueryCallback} callback\r\n */\r\nCacheDriver.prototype._getPotentialEntries = function(query, callback) {\r\n  var self = this;\r\n  var potentialEntriesQuery = {};\r\n\r\n  if (query.clientId) {\r\n    potentialEntriesQuery[METADATA_CLIENTID] = query.clientId;\r\n  }\r\n  if (query.userId) {\r\n    potentialEntriesQuery[TokenResponseFields.USER_ID] = query.userId;\r\n  }\r\n\r\n  this._log.verbose('Looking for potential cache entries:');\r\n  this._log.verbose(JSON.stringify(potentialEntriesQuery), true);\r\n  this._find(potentialEntriesQuery, function(err, entries) {\r\n    self._log.verbose('Found ' + entries.length + ' potential entries.');\r\n    callback(err, entries);\r\n    return;\r\n  });\r\n};\r\n\r\n/**\r\n * Finds all multi resource refresh tokens in the cache.\r\n * Refresh token is bound to userId, clientId. \r\n * @param  {QueryCallback} callback\r\n */\r\nCacheDriver.prototype._findMRRTTokensForUser = function(user, callback) {\r\n  this._find({ isMRRT : true, userId : user, _clientId : this._clientId}, callback);\r\n};\r\n\r\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback SingleEntryCallback\r\n * @memberOf CacheDriver\r\n * @param {Error}  [error]           If the request fails this parameter will contain an Error object.\r\n * @param {object} [response]   On a succesful request returns a single cache entry.\r\n */\r\n\r\n\r\n/**\r\n * Finds a single entry that matches the query.  If multiple entries are found that satisfy the query\r\n * then an error will be returned.\r\n * @param {object}  query A query object.\r\n * @param {SingleEntryCallback} callback\r\n */\r\nCacheDriver.prototype._loadSingleEntryFromCache = function(query, callback) {\r\n  var self = this;\r\n  this._getPotentialEntries(query, function(err, potentialEntries) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    var returnVal;\r\n    var isResourceTenantSpecific;\r\n\r\n    if (potentialEntries && 0 < potentialEntries.length) {\r\n      var resourceTenantSpecificEntries = _.where(potentialEntries, { resource : self._resource, _authority : self._authority });\r\n\r\n      if (!resourceTenantSpecificEntries || 0 === resourceTenantSpecificEntries.length) {\r\n        self._log.verbose('No resource specific cache entries found.');\r\n\r\n        // There are no resource specific entries.  Find an MRRT token.\r\n        var mrrtTokens = _.where(potentialEntries, { isMRRT : true });\r\n        if (mrrtTokens && mrrtTokens.length > 0) {\r\n          self._log.verbose('Found an MRRT token.');\r\n          returnVal = mrrtTokens[0];\r\n        } else {\r\n          self._log.verbose('No MRRT tokens found.');\r\n        }\r\n\r\n      } else if (resourceTenantSpecificEntries.length === 1) {\r\n        self._log.verbose('Resource specific token found.');\r\n        returnVal = resourceTenantSpecificEntries[0];\r\n        isResourceTenantSpecific = true;\r\n      }else {\r\n        callback(self._log.createError('More than one token matches the criteria.  The result is ambiguous.'));\r\n        return;\r\n      }\r\n    }\r\n    if (returnVal) {\r\n      self._log.verbose('Returning token from cache lookup');\r\n      self._log.verbose('Returning token from cache lookup, ' + createTokenIdMessage(returnVal), true);\r\n    }\r\n    callback(null, returnVal, isResourceTenantSpecific);\r\n  });\r\n};\r\n\r\n/**\r\n * The response from a token refresh request never contains an id_token and therefore no\r\n * userInfo can be created from the response.  This function creates a new cache entry\r\n * combining the id_token based info and cache metadata from the cache entry that was refreshed with the\r\n * new tokens in the refresh response.\r\n * @param  {object} entry           A cache entry corresponding to the resfreshResponse.\r\n * @param  {object} refreshResponse The response from a token refresh request for the entry parameter.\r\n * @return {object}                 A new cache entry.\r\n */\r\nCacheDriver.prototype._createEntryFromRefresh = function(entry, refreshResponse) {\r\n  var newEntry = _.clone(entry);\r\n  newEntry = _.extend(newEntry, refreshResponse);\r\n\r\n  if (entry.isMRRT && this._authority !== entry[METADATA_AUTHORITY]) {\r\n    newEntry[METADATA_AUTHORITY] = this._authority;\r\n  }\r\n\r\n  this._log.verbose('Created new cache entry from refresh response.');\r\n  return newEntry;\r\n};\r\n\r\nCacheDriver.prototype._replaceEntry = function(entryToReplace, newEntry, callback) {\r\n  var self = this;\r\n  this.remove(entryToReplace, function(err) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n    self.add(newEntry, callback);\r\n  });\r\n};\r\n\r\n/**\r\n * Given an expired cache entry refreshes it and updates the cache.\r\n * @param  {object}   entry              A cache entry with an MRRT to refresh for another resource.\r\n * @param  {SingleEntryCallback} callback\r\n */\r\nCacheDriver.prototype._refreshExpiredEntry = function(entry, callback) {\r\n  var self = this;\r\n  this._refreshFunction(entry, null, function(err, tokenResponse) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    var newEntry = self._createEntryFromRefresh(entry, tokenResponse);\r\n    self._replaceEntry(entry, newEntry, function(err) {\r\n      if (err) {\r\n        self._log.error('error refreshing expired token', err, true);\r\n      } else {\r\n        self._log.info('Returning token refreshed after expiry.');\r\n      }\r\n      callback(err, newEntry);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Given a cache entry with an MRRT will acquire a new token for a new resource via the MRRT, and cache it.\r\n * @param  {object}   entry              A cache entry with an MRRT to refresh for another resource.\r\n * @param  {SingleEntryCallback} callback\r\n */\r\nCacheDriver.prototype._acquireNewTokenFromMrrt = function(entry, callback) {\r\n  var self = this;\r\n  this._refreshFunction(entry, this._resource, function(err, tokenResponse) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    var newEntry = self._createEntryFromRefresh(entry, tokenResponse);\r\n    self.add(newEntry, function(err) {\r\n      if (err) {\r\n        self._log.error('error refreshing mrrt', err, true);\r\n      } else {\r\n        self._log.info('Returning token derived from mrrt refresh.');\r\n      }\r\n      callback(err, newEntry);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Given a token this function will refresh it if it is either expired, or an MRRT.\r\n * @param  {object}   entry              A cache entry to refresh if necessary.\r\n * @param  {Boolean}  isResourceSpecific Indicates whether this token is appropriate for the resource for which\r\n *                                       it was requested or whether it is possibly an MRRT token for which\r\n *                                       a resource specific access token should be acquired.\r\n * @param  {SingleEntryCallback} callback\r\n */\r\nCacheDriver.prototype._refreshEntryIfNecessary = function(entry, isResourceSpecific, callback) {\r\n  var expiryDate = entry[TokenResponseFields.EXPIRES_ON];\r\n\r\n  // Add some buffer in to the time comparison to account for clock skew or latency.\r\n  var nowPlusBuffer = (new Date()).addMinutes(constants.Misc.CLOCK_BUFFER);\r\n\r\n  if (isResourceSpecific && nowPlusBuffer.isAfter(expiryDate)) {\r\n    this._log.info('Cached token is expired.  Refreshing: ' + expiryDate);\r\n    this._refreshExpiredEntry(entry, callback);\r\n    return;\r\n  } else if (!isResourceSpecific && entry.isMRRT) {\r\n    this._log.info('Acquiring new access token from MRRT token.');\r\n    this._acquireNewTokenFromMrrt(entry, callback);\r\n    return;\r\n  } else {\r\n    callback(null, entry);\r\n  }\r\n};\r\n\r\n/**\r\n * Finds a single entry in the cache that matches the query or fails if more than one match is found.\r\n * @param  {object}   query    A query object\r\n * @param  {SingleEntryCallback} callback\r\n */\r\nCacheDriver.prototype.find = function(query, callback) {\r\n  var self = this;\r\n  query = query || {};\r\n  this._log.verbose('finding using query');\r\n  this._log.verbose('finding with query:' + JSON.stringify(query), true);\r\n  this._loadSingleEntryFromCache(query, function(err, entry, isResourceTenantSpecific) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (!entry) {\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    self._refreshEntryIfNecessary(entry, isResourceTenantSpecific, function(err, newEntry) {\r\n      callback(err, newEntry);\r\n      return;\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Removes a single entry from the cache.\r\n * @param  {object}   entry    The entry to remove.\r\n * @param  {Function} callback Called on completion.  The first parameter may contain an error.\r\n */\r\nCacheDriver.prototype.remove = function(entry, callback) {\r\n  this._log.verbose('Removing entry.');\r\n  return this._cache.remove([entry], function(err) {\r\n    callback(err);\r\n    return;\r\n  });\r\n};\r\n\r\n/**\r\n * Removes a collection of entries from the cache in a single batch operation.\r\n * @param  {Array}   entries  An array of cache entries to remove.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\r\nCacheDriver.prototype._removeMany = function(entries, callback) {\r\n  this._log.verbose('Remove many: ' + entries.length);\r\n  this._cache.remove(entries, function(err) {\r\n    callback(err);\r\n    return;\r\n  });\r\n};\r\n\r\n/**\r\n * Adds a collection of entries to the cache in a single batch operation.\r\n * @param {Array}   entries  An array of entries to add to the cache.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\r\nCacheDriver.prototype._addMany = function(entries, callback) {\r\n  this._log.verbose('Add many: ' + entries.length);\r\n  this._cache.add(entries, function(err) {\r\n    callback(err);\r\n    return;\r\n  });\r\n};\r\n\r\n/*\r\n * Tests whether the passed entry is a multi resource refresh token.\r\n * Somewhat mysteriously the presense of a resource field in a returned\r\n * token response indicates that the response is an MRRT.\r\n * @param  {object}  entry\r\n * @return {Boolean}       true if the entry is an MRRT.\r\n */\r\nfunction isMRRT(entry) {\r\n  return entry.resource ? true : false;\r\n}\r\n\r\n/**\r\n * Given an cache entry this function finds all of the MRRT tokens already in the cache\r\n * and updates them with the refresh_token of the passed in entry.\r\n * @param  {object}   entry    The entry from which to get an updated refresh_token\r\n * @param  {Function} callback Called back on completion.  The first parameter may contain an error.\r\n */\r\nCacheDriver.prototype._updateRefreshTokens = function(entry, callback) {\r\n  var self = this;\r\n  if (isMRRT(entry)) {\r\n    this._findMRRTTokensForUser(entry.userId, function(err, mrrtTokens) {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      if (!mrrtTokens || 0 === mrrtTokens.length) {\r\n        callback();\r\n        return;\r\n      }\r\n\r\n      self._log.verbose('Updating ' + mrrtTokens.length + ' cached refresh tokens.');\r\n      self._removeMany(mrrtTokens, function(err) {\r\n        if (err) {\r\n          callback(err);\r\n          return;\r\n        }\r\n\r\n        for (var i = 0; i < mrrtTokens.length; i++) {\r\n          mrrtTokens[i][TokenResponseFields.REFRESH_TOKEN] = entry[TokenResponseFields.REFRESH_TOKEN];\r\n        }\r\n\r\n        self._addMany(mrrtTokens, function(err) {\r\n          callback(err);\r\n          return;\r\n        });\r\n      });\r\n    });\r\n  } else {\r\n    callback();\r\n    return;\r\n  }\r\n};\r\n\r\n/**\r\n * Checks to see if the entry has cache metadata already.  If it does\r\n * then it probably came from a refresh operation and the metadata\r\n * was copied from the originating entry.\r\n * @param  {object} entry The entry to check\r\n * @return {bool}         Returns true if the entry has already been augmented\r\n *                        with cache metadata.\r\n */\r\nCacheDriver.prototype._entryHasMetadata = function(entry) {\r\n  return (_.has(entry, METADATA_CLIENTID) && _.has(entry, METADATA_AUTHORITY));\r\n};\r\n\r\nCacheDriver.prototype._augmentEntryWithCacheMetadata = function(entry) {\r\n  if (this._entryHasMetadata(entry)) {\r\n    return;\r\n  }\r\n\r\n  if (isMRRT(entry)) {\r\n    this._log.verbose('Added entry is MRRT');\r\n    entry.isMRRT = true;\r\n  } else {\r\n    entry.resource = this._resource;\r\n  }\r\n\r\n  entry[METADATA_CLIENTID] = this._clientId;\r\n  entry[METADATA_AUTHORITY] = this._authority;\r\n};\r\n\r\n/**\r\n * Adds a single entry to the cache.\r\n * @param {object}   entry    The entry to add.\r\n * @param {string}   clientId The id of this client app.\r\n * @param {string}   resource The id of the resource for which the cached token was obtained.\r\n * @param {Function} callback Called back on completion.  The first parameter may contain an error.\r\n */\r\nCacheDriver.prototype.add = function(entry, callback) {\r\n  var self = this;\r\n  this._log.verbose('Adding entry');\r\n  this._log.verbose('Adding entry, ' + createTokenIdMessage(entry));\r\n\r\n  this._augmentEntryWithCacheMetadata(entry);\r\n\r\n  this._updateRefreshTokens(entry, function(err) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    self._cache.add([entry], function(err) {\r\n      callback(err);\r\n      return;\r\n    });\r\n  });\r\n};\r\n\r\nmodule.exports = CacheDriver;"]},"metadata":{},"sourceType":"script"}