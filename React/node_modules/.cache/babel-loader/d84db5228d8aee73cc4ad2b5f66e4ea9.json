{"ast":null,"code":"'use strict';\n/*\n * cls-bluebird\n * Module entry point\n */\n// Modules\n\nvar isBluebird = require('is-bluebird'); // Require Bluebird library\n// Ignore errors if cannot be required\n\n\nvar Bluebird;\n\ntry {\n  Bluebird = require('bluebird');\n} catch (err) {} // Imports\n\n\nvar shimMethod = require('./shimMethod'),\n    shimOnCancel = require('./shimOnCancel'),\n    shimCall = require('./shimCall'),\n    shimUsing = require('./shimUsing'),\n    shimCoroutine = require('./shimCoroutine'); // Exports\n\n/**\n * Patch bluebird to run maintain CLS context for a specific namespace.\n * If a Bluebird Promise constructor is provided, it is patched.\n * If not provided, the version returned by `require('bluebird')` is used.\n *\n * @param {Object} ns - CLS namespace object\n * @param {Function} [Promise] - Bluebird Promise constructor to patch (optional)\n * @returns {Function} - Bluebird Promise constructor\n * @throws {TypeError} - If `ns` or `Promise` are not of correct type\n * @throws {Error} - If `Promise` not provided and cannot require `bluebird` module\n */\n\n\nmodule.exports = function patchBluebird(ns, Promise) {\n  // Check namespace is valid\n  if (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new TypeError('Must provide CLS namespace to patch Bluebird against'); // Check Promise implementation is some variation of Bluebird\n  // If none provided, use default Bluebird\n\n  if (!Promise) {\n    Promise = Bluebird;\n    if (!Promise) throw new Error('Could not require Bluebird');\n  } else if (!isBluebird.ctor(Promise)) {\n    throw new TypeError('Promise implementation provided must be Bluebird');\n  } // Patch all methods to carry CLS context\n\n\n  var v3 = isBluebird.ctor.v3(Promise);\n  /*\n   * Core\n   *\n   * Not patched as always run callback synchronously:\n   *   new Promise()\n   *   Promise.try() / Promise.attempt()\n   *\n   * Not patched as do not take a callback:\n   *   Promise.bind() / .bind()\n   *   Promise.resolve() / Promise.fulfilled() / Promise.cast()\n   *   Promise.reject() / Promise.rejected()\n   *\n   * Not patched as call another patched method synchronously\n   *   .error() - calls .catch()\n   *\n   * Not patched as are wrappers:\n   *   Promise.method()\n   *\n   * NB Due to bug in bluebird v2 https://github.com/petkaantonov/bluebird/issues/1153\n   * `Promise.join()` calls the callback synchronously if input is only values or\n   * resolved promises, but async if any promises are pending.\n   * So handler is sometimes bound to CLS context unnecessarily, but this does no harm\n   * beyond the very slight performance overhead of an extra `ns.bind()` call.\n   */\n\n  shimProto('then', v3 ? [0, 1] : [0, 1, 2]);\n  shimProto('spread', v3 ? [0] : [0, 1]);\n  shimProto('finally', [0]);\n  Promise.prototype.lastly = Promise.prototype.finally;\n  shimStatic('join', [-1]);\n\n  if (!v3) {\n    // Only patched in bluebird v2.\n    // In bluebird v3 `.catch()` calls `.then()` immediately which binds callback.\n    shimProto('catch', [-1]);\n    Promise.prototype.caught = Promise.prototype.catch;\n  }\n  /*\n   * Synchronous inspection\n   *\n   * Not patched as do not take a callback:\n   *   .isFulfilled()\n   *   .isRejected()\n   *   .isPending()\n   *   .isCancelled()\n   *   .isResolved()\n   *   .value()\n   *   .reason()\n   *   .reflect()\n   */\n\n  /*\n   * Collections\n   *\n   * Not patched as do not take a callback:\n   *   Promise.all() / .all()\n   *   Promise.props() / .props()\n   *   Promise.any() / .any()\n   *   Promise.some() / .some()\n   *   Promise.race() / .race()\n   */\n\n\n  shimBoth('map', [0]);\n  shimBoth('filter', [0]);\n  shimBoth('reduce', [0]);\n  shimBoth('each', [0]); // In bluebird v2, there is no `Promise.mapSeries()`/`.mapSeries()` method\n\n  if (v3) shimBoth('mapSeries', [0]);\n  /*\n   * Resource management\n   *\n   * NB disposer callbacks are bound to context at time disposer created, not when utilized in `using()`\n   */\n\n  shimUsing(Promise, ns, v3); // shims `Promise.using()`\n\n  shimProto('disposer', [0]);\n  /*\n   * Promisification\n   *\n   * Not patched as always run callback synchronously:\n   *   Promise.fromCallback()\n   *   Promise.fromNode()\n   *\n   * Not patched as they are wrappers:\n   *   Promise.promisify()\n   *   Promise.promisifyAll()\n   */\n\n  shimProto('asCallback', [0]);\n  Promise.prototype.nodeify = Promise.prototype.asCallback;\n  /*\n   * Timers\n   *\n   * Not patched as do not take a callback:\n   *   Promise.delay() / .delay()\n   *   .timeout()\n   */\n\n  /*\n   * Cancellation\n   *\n   * Not patched as does not take a callback:\n   *   .cancel() / .break()\n   *   .isCancellable()\n   *   .cancellable() (bluebird v2 only)\n   *   .uncancellable() (bluebird v2 only)\n   *\n   * NB In bluebird v3 `onCancel` handler will be called\n   * in CLS context of call to `onCancel()`.\n   */\n  // Patch `Promise.prototype._resolveFromExecutor`\n  // in order to patch `onCancel` handler in `new Promise()`.\n\n  if (v3) shimOnCancel(Promise, ns);\n  /*\n   * Generators\n   *\n   * Not patched as does not take a callback:\n   *   Promise.coroutine.addYieldHandler()\n   *\n   * NB `options.yieldHandler` will run in whatever CLS context is active at time of `yield`\n   */\n\n  var addYieldHandler = Promise.coroutine.addYieldHandler;\n  shimCoroutine('coroutine', Promise, ns, v3); // shims `Promise.coroutine()`\n\n  Promise.coroutine.addYieldHandler = addYieldHandler;\n  /*\n   * Utility\n   *\n   * Not patched as do not take a callback:\n   *   .get()\n   *   .return() / .thenReturn()\n   *   .throw() / .thenThrow()\n   *   .catchReturn()\n   *   .catchThrow()\n   *   Promise.getNewLibraryCopy()\n   *   Promise.noConflict()\n   *   Promise.setScheduler()\n   */\n\n  shimProto('tap', [0]);\n  if (v3) shimProto('tapCatch', [-1]);\n  shimCall(Promise, ns); // shims `.call()`\n\n  /*\n   * Configuration\n   *\n   * Not patched as do not take a callback:\n   *   Promise.config()\n   *   .suppressUnhandledRejections()\n   *   Promise.longStackTraces()\n   *   Promise.hasLongStackTraces()\n   *\n   * Not patched as meaningless to do so:\n   *   Promise.onPossiblyUnhandledRejection()\n   *   Promise.onUnhandledRejectionHandled()\n   *\n   * NB Error handlers will run with unknown CLS context.\n   * CLS context should not be relied upon to be the context at the time error was thrown.\n   * Catch errors with `.catch()` instead!\n   */\n\n  shimProto('done', v3 ? [0, 1] : [0, 1, 2]);\n  /*\n   * Progression (bluebird v2 only)\n   */\n\n  if (!v3) shimProto('progressed', [0]);\n  /*\n   * Undocumented\n   *\n   * Not patched as do not take a callback:\n   *   Promise.is()\n   *   Promise.settle() / .settle()\n   *   Promise.defer() / Promise.pending()\n   *   .toString()\n   *   .toJSON()\n   */\n  // `.fork()` does not exist in bluebird v3\n\n  if (!v3) shimProto('fork', [0, 1, 2]);\n  shimCoroutine('spawn', Promise, ns, v3); // shims `Promise.spawn()`\n  // Return patched Bluebird constructor\n\n  return Promise;\n  /*\n   * Patching functions\n   */\n\n  function shimStatic(methodName, args) {\n    shimMethod(Promise, methodName, args, ns);\n  }\n\n  function shimProto(methodName, args) {\n    shimMethod(Promise.prototype, methodName, args, ns);\n  }\n\n  function shimBoth(methodName, args) {\n    shimProto(methodName, args);\n    shimStatic(methodName, args.map(function (arg) {\n      return arg < 0 ? arg : arg + 1;\n    }));\n  }\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/cls-bluebird/lib/index.js"],"names":["isBluebird","require","Bluebird","err","shimMethod","shimOnCancel","shimCall","shimUsing","shimCoroutine","module","exports","patchBluebird","ns","Promise","bind","run","TypeError","Error","ctor","v3","shimProto","prototype","lastly","finally","shimStatic","caught","catch","shimBoth","nodeify","asCallback","addYieldHandler","coroutine","methodName","args","map","arg"],"mappings":"AAAA;AAEA;;;;AAKA;;AACA,IAAIA,UAAU,GAAGC,OAAO,CAAC,aAAD,CAAxB,C,CAEA;AACA;;;AACA,IAAIC,QAAJ;;AACA,IAAI;AACHA,EAAAA,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAlB;AACA,CAFD,CAEE,OAAOE,GAAP,EAAY,CAAE,C,CAEhB;;;AACA,IAAIC,UAAU,GAAGH,OAAO,CAAC,cAAD,CAAxB;AAAA,IACCI,YAAY,GAAGJ,OAAO,CAAC,gBAAD,CADvB;AAAA,IAECK,QAAQ,GAAGL,OAAO,CAAC,YAAD,CAFnB;AAAA,IAGCM,SAAS,GAAGN,OAAO,CAAC,aAAD,CAHpB;AAAA,IAICO,aAAa,GAAGP,OAAO,CAAC,iBAAD,CAJxB,C,CAMA;;AAEA;;;;;;;;;;;;;AAWAQ,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAuBC,EAAvB,EAA2BC,OAA3B,EAAoC;AACpD;AACA,MAAI,CAACD,EAAD,IAAO,OAAOA,EAAP,KAAc,QAArB,IAAiC,OAAOA,EAAE,CAACE,IAAV,KAAmB,UAApD,IAAkE,OAAOF,EAAE,CAACG,GAAV,KAAkB,UAAxF,EAAoG,MAAM,IAAIC,SAAJ,CAAc,sDAAd,CAAN,CAFhD,CAIpD;AACA;;AACA,MAAI,CAACH,OAAL,EAAc;AACbA,IAAAA,OAAO,GAAGX,QAAV;AACA,QAAI,CAACW,OAAL,EAAc,MAAM,IAAII,KAAJ,CAAU,4BAAV,CAAN;AACd,GAHD,MAGO,IAAI,CAACjB,UAAU,CAACkB,IAAX,CAAgBL,OAAhB,CAAL,EAA+B;AACrC,UAAM,IAAIG,SAAJ,CAAc,kDAAd,CAAN;AACA,GAXmD,CAapD;;;AACA,MAAIG,EAAE,GAAGnB,UAAU,CAACkB,IAAX,CAAgBC,EAAhB,CAAmBN,OAAnB,CAAT;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBAO,EAAAA,SAAS,CAAC,MAAD,EAASD,EAAE,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAH,GAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAvB,CAAT;AACAC,EAAAA,SAAS,CAAC,QAAD,EAAWD,EAAE,GAAG,CAAC,CAAD,CAAH,GAAS,CAAC,CAAD,EAAI,CAAJ,CAAtB,CAAT;AACAC,EAAAA,SAAS,CAAC,SAAD,EAAY,CAAC,CAAD,CAAZ,CAAT;AACAP,EAAAA,OAAO,CAACQ,SAAR,CAAkBC,MAAlB,GAA2BT,OAAO,CAACQ,SAAR,CAAkBE,OAA7C;AACAC,EAAAA,UAAU,CAAC,MAAD,EAAS,CAAC,CAAC,CAAF,CAAT,CAAV;;AAEA,MAAI,CAACL,EAAL,EAAS;AACR;AACA;AACAC,IAAAA,SAAS,CAAC,OAAD,EAAU,CAAC,CAAC,CAAF,CAAV,CAAT;AACAP,IAAAA,OAAO,CAACQ,SAAR,CAAkBI,MAAlB,GAA2BZ,OAAO,CAACQ,SAAR,CAAkBK,KAA7C;AACA;AAED;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;AAWAC,EAAAA,QAAQ,CAAC,KAAD,EAAQ,CAAC,CAAD,CAAR,CAAR;AACAA,EAAAA,QAAQ,CAAC,QAAD,EAAW,CAAC,CAAD,CAAX,CAAR;AACAA,EAAAA,QAAQ,CAAC,QAAD,EAAW,CAAC,CAAD,CAAX,CAAR;AACAA,EAAAA,QAAQ,CAAC,MAAD,EAAS,CAAC,CAAD,CAAT,CAAR,CAlFoD,CAoFpD;;AACA,MAAIR,EAAJ,EAAQQ,QAAQ,CAAC,WAAD,EAAc,CAAC,CAAD,CAAd,CAAR;AAER;;;;;;AAMApB,EAAAA,SAAS,CAACM,OAAD,EAAUD,EAAV,EAAcO,EAAd,CAAT,CA7FoD,CA6FxB;;AAC5BC,EAAAA,SAAS,CAAC,UAAD,EAAa,CAAC,CAAD,CAAb,CAAT;AAEA;;;;;;;;;;;;AAYAA,EAAAA,SAAS,CAAC,YAAD,EAAe,CAAC,CAAD,CAAf,CAAT;AACAP,EAAAA,OAAO,CAACQ,SAAR,CAAkBO,OAAlB,GAA4Bf,OAAO,CAACQ,SAAR,CAAkBQ,UAA9C;AAEA;;;;;;;;AAQA;;;;;;;;;;;;AAaA;AACA;;AACA,MAAIV,EAAJ,EAAQd,YAAY,CAACQ,OAAD,EAAUD,EAAV,CAAZ;AAER;;;;;;;;;AASA,MAAIkB,eAAe,GAAGjB,OAAO,CAACkB,SAAR,CAAkBD,eAAxC;AACAtB,EAAAA,aAAa,CAAC,WAAD,EAAcK,OAAd,EAAuBD,EAAvB,EAA2BO,EAA3B,CAAb,CAlJoD,CAkJP;;AAC7CN,EAAAA,OAAO,CAACkB,SAAR,CAAkBD,eAAlB,GAAoCA,eAApC;AAEA;;;;;;;;;;;;;;AAcAV,EAAAA,SAAS,CAAC,KAAD,EAAQ,CAAC,CAAD,CAAR,CAAT;AACA,MAAID,EAAJ,EAAQC,SAAS,CAAC,UAAD,EAAa,CAAC,CAAC,CAAF,CAAb,CAAT;AACRd,EAAAA,QAAQ,CAACO,OAAD,EAAUD,EAAV,CAAR,CArKoD,CAqK7B;;AAEvB;;;;;;;;;;;;;;;;;;AAkBAQ,EAAAA,SAAS,CAAC,MAAD,EAASD,EAAE,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAH,GAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAvB,CAAT;AAEA;;;;AAIA,MAAI,CAACA,EAAL,EAASC,SAAS,CAAC,YAAD,EAAe,CAAC,CAAD,CAAf,CAAT;AAET;;;;;;;;;;AAWA;;AACA,MAAI,CAACD,EAAL,EAASC,SAAS,CAAC,MAAD,EAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAT,CAAT;AAETZ,EAAAA,aAAa,CAAC,OAAD,EAAUK,OAAV,EAAmBD,EAAnB,EAAuBO,EAAvB,CAAb,CA/MoD,CA+MX;AAEzC;;AACA,SAAON,OAAP;AAEA;;;;AAGA,WAASW,UAAT,CAAoBQ,UAApB,EAAgCC,IAAhC,EAAsC;AACrC7B,IAAAA,UAAU,CAACS,OAAD,EAAUmB,UAAV,EAAsBC,IAAtB,EAA4BrB,EAA5B,CAAV;AACA;;AAED,WAASQ,SAAT,CAAmBY,UAAnB,EAA+BC,IAA/B,EAAqC;AACpC7B,IAAAA,UAAU,CAACS,OAAO,CAACQ,SAAT,EAAoBW,UAApB,EAAgCC,IAAhC,EAAsCrB,EAAtC,CAAV;AACA;;AAED,WAASe,QAAT,CAAkBK,UAAlB,EAA8BC,IAA9B,EAAoC;AACnCb,IAAAA,SAAS,CAACY,UAAD,EAAaC,IAAb,CAAT;AACAT,IAAAA,UAAU,CAACQ,UAAD,EAAaC,IAAI,CAACC,GAAL,CAAS,UAASC,GAAT,EAAc;AAAE,aAAOA,GAAG,GAAG,CAAN,GAAUA,GAAV,GAAgBA,GAAG,GAAG,CAA7B;AAAiC,KAA1D,CAAb,CAAV;AACA;AACD,CAnOD","sourcesContent":["'use strict';\n\n/*\n * cls-bluebird\n * Module entry point\n */\n\n// Modules\nvar isBluebird = require('is-bluebird');\n\n// Require Bluebird library\n// Ignore errors if cannot be required\nvar Bluebird;\ntry {\n\tBluebird = require('bluebird');\n} catch (err) {}\n\n// Imports\nvar shimMethod = require('./shimMethod'),\n\tshimOnCancel = require('./shimOnCancel'),\n\tshimCall = require('./shimCall'),\n\tshimUsing = require('./shimUsing'),\n\tshimCoroutine = require('./shimCoroutine');\n\n// Exports\n\n/**\n * Patch bluebird to run maintain CLS context for a specific namespace.\n * If a Bluebird Promise constructor is provided, it is patched.\n * If not provided, the version returned by `require('bluebird')` is used.\n *\n * @param {Object} ns - CLS namespace object\n * @param {Function} [Promise] - Bluebird Promise constructor to patch (optional)\n * @returns {Function} - Bluebird Promise constructor\n * @throws {TypeError} - If `ns` or `Promise` are not of correct type\n * @throws {Error} - If `Promise` not provided and cannot require `bluebird` module\n */\nmodule.exports = function patchBluebird(ns, Promise) {\n\t// Check namespace is valid\n\tif (!ns || typeof ns !== 'object' || typeof ns.bind !== 'function' || typeof ns.run !== 'function') throw new TypeError('Must provide CLS namespace to patch Bluebird against');\n\n\t// Check Promise implementation is some variation of Bluebird\n\t// If none provided, use default Bluebird\n\tif (!Promise) {\n\t\tPromise = Bluebird;\n\t\tif (!Promise) throw new Error('Could not require Bluebird');\n\t} else if (!isBluebird.ctor(Promise)) {\n\t\tthrow new TypeError('Promise implementation provided must be Bluebird');\n\t}\n\n\t// Patch all methods to carry CLS context\n\tvar v3 = isBluebird.ctor.v3(Promise);\n\n\t/*\n\t * Core\n\t *\n\t * Not patched as always run callback synchronously:\n\t *   new Promise()\n\t *   Promise.try() / Promise.attempt()\n\t *\n\t * Not patched as do not take a callback:\n\t *   Promise.bind() / .bind()\n\t *   Promise.resolve() / Promise.fulfilled() / Promise.cast()\n\t *   Promise.reject() / Promise.rejected()\n\t *\n\t * Not patched as call another patched method synchronously\n\t *   .error() - calls .catch()\n\t *\n\t * Not patched as are wrappers:\n\t *   Promise.method()\n\t *\n\t * NB Due to bug in bluebird v2 https://github.com/petkaantonov/bluebird/issues/1153\n\t * `Promise.join()` calls the callback synchronously if input is only values or\n\t * resolved promises, but async if any promises are pending.\n\t * So handler is sometimes bound to CLS context unnecessarily, but this does no harm\n\t * beyond the very slight performance overhead of an extra `ns.bind()` call.\n\t */\n\n\tshimProto('then', v3 ? [0, 1] : [0, 1, 2]);\n\tshimProto('spread', v3 ? [0] : [0, 1]);\n\tshimProto('finally', [0]);\n\tPromise.prototype.lastly = Promise.prototype.finally;\n\tshimStatic('join', [-1]);\n\n\tif (!v3) {\n\t\t// Only patched in bluebird v2.\n\t\t// In bluebird v3 `.catch()` calls `.then()` immediately which binds callback.\n\t\tshimProto('catch', [-1]);\n\t\tPromise.prototype.caught = Promise.prototype.catch;\n\t}\n\n\t/*\n\t * Synchronous inspection\n\t *\n\t * Not patched as do not take a callback:\n\t *   .isFulfilled()\n\t *   .isRejected()\n\t *   .isPending()\n\t *   .isCancelled()\n\t *   .isResolved()\n\t *   .value()\n\t *   .reason()\n\t *   .reflect()\n\t */\n\n\t/*\n\t * Collections\n\t *\n\t * Not patched as do not take a callback:\n\t *   Promise.all() / .all()\n\t *   Promise.props() / .props()\n\t *   Promise.any() / .any()\n\t *   Promise.some() / .some()\n\t *   Promise.race() / .race()\n\t */\n\n\tshimBoth('map', [0]);\n\tshimBoth('filter', [0]);\n\tshimBoth('reduce', [0]);\n\tshimBoth('each', [0]);\n\n\t// In bluebird v2, there is no `Promise.mapSeries()`/`.mapSeries()` method\n\tif (v3) shimBoth('mapSeries', [0]);\n\n\t/*\n\t * Resource management\n\t *\n\t * NB disposer callbacks are bound to context at time disposer created, not when utilized in `using()`\n\t */\n\n\tshimUsing(Promise, ns, v3); // shims `Promise.using()`\n\tshimProto('disposer', [0]);\n\n\t/*\n\t * Promisification\n\t *\n\t * Not patched as always run callback synchronously:\n\t *   Promise.fromCallback()\n\t *   Promise.fromNode()\n\t *\n\t * Not patched as they are wrappers:\n\t *   Promise.promisify()\n\t *   Promise.promisifyAll()\n\t */\n\n\tshimProto('asCallback', [0]);\n\tPromise.prototype.nodeify = Promise.prototype.asCallback;\n\n\t/*\n\t * Timers\n\t *\n\t * Not patched as do not take a callback:\n\t *   Promise.delay() / .delay()\n\t *   .timeout()\n\t */\n\n\t/*\n\t * Cancellation\n\t *\n\t * Not patched as does not take a callback:\n\t *   .cancel() / .break()\n\t *   .isCancellable()\n\t *   .cancellable() (bluebird v2 only)\n\t *   .uncancellable() (bluebird v2 only)\n\t *\n\t * NB In bluebird v3 `onCancel` handler will be called\n\t * in CLS context of call to `onCancel()`.\n\t */\n\n\t// Patch `Promise.prototype._resolveFromExecutor`\n\t// in order to patch `onCancel` handler in `new Promise()`.\n\tif (v3) shimOnCancel(Promise, ns);\n\n\t/*\n\t * Generators\n\t *\n\t * Not patched as does not take a callback:\n\t *   Promise.coroutine.addYieldHandler()\n\t *\n\t * NB `options.yieldHandler` will run in whatever CLS context is active at time of `yield`\n\t */\n\n\tvar addYieldHandler = Promise.coroutine.addYieldHandler;\n\tshimCoroutine('coroutine', Promise, ns, v3); // shims `Promise.coroutine()`\n\tPromise.coroutine.addYieldHandler = addYieldHandler;\n\n\t/*\n\t * Utility\n\t *\n\t * Not patched as do not take a callback:\n\t *   .get()\n\t *   .return() / .thenReturn()\n\t *   .throw() / .thenThrow()\n\t *   .catchReturn()\n\t *   .catchThrow()\n\t *   Promise.getNewLibraryCopy()\n\t *   Promise.noConflict()\n\t *   Promise.setScheduler()\n\t */\n\n\tshimProto('tap', [0]);\n\tif (v3) shimProto('tapCatch', [-1]);\n\tshimCall(Promise, ns); // shims `.call()`\n\n\t/*\n\t * Configuration\n\t *\n\t * Not patched as do not take a callback:\n\t *   Promise.config()\n\t *   .suppressUnhandledRejections()\n\t *   Promise.longStackTraces()\n\t *   Promise.hasLongStackTraces()\n\t *\n\t * Not patched as meaningless to do so:\n\t *   Promise.onPossiblyUnhandledRejection()\n\t *   Promise.onUnhandledRejectionHandled()\n\t *\n\t * NB Error handlers will run with unknown CLS context.\n\t * CLS context should not be relied upon to be the context at the time error was thrown.\n\t * Catch errors with `.catch()` instead!\n\t */\n\n\tshimProto('done', v3 ? [0, 1] : [0, 1, 2]);\n\n\t/*\n\t * Progression (bluebird v2 only)\n\t */\n\n\tif (!v3) shimProto('progressed', [0]);\n\n\t/*\n\t * Undocumented\n\t *\n\t * Not patched as do not take a callback:\n\t *   Promise.is()\n\t *   Promise.settle() / .settle()\n\t *   Promise.defer() / Promise.pending()\n\t *   .toString()\n\t *   .toJSON()\n\t */\n\n\t// `.fork()` does not exist in bluebird v3\n\tif (!v3) shimProto('fork', [0, 1, 2]);\n\n\tshimCoroutine('spawn', Promise, ns, v3); // shims `Promise.spawn()`\n\n\t// Return patched Bluebird constructor\n\treturn Promise;\n\n\t/*\n\t * Patching functions\n\t */\n\tfunction shimStatic(methodName, args) {\n\t\tshimMethod(Promise, methodName, args, ns);\n\t}\n\n\tfunction shimProto(methodName, args) {\n\t\tshimMethod(Promise.prototype, methodName, args, ns);\n\t}\n\n\tfunction shimBoth(methodName, args) {\n\t\tshimProto(methodName, args);\n\t\tshimStatic(methodName, args.map(function(arg) { return arg < 0 ? arg : arg + 1; }));\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}