{"ast":null,"code":"//////////////////////////////////////////\n// Needle -- HTTP Client for Node.js\n// Written by Tom√°s Pollak <tomas@forkhq.com>\n// (c) 2012-2017 - Fork Ltd.\n// MIT Licensed\n//////////////////////////////////////////\nvar fs = require('fs'),\n    http = require('http'),\n    https = require('https'),\n    url = require('url'),\n    stream = require('stream'),\n    debug = require('debug')('needle'),\n    stringify = require('./querystring').build,\n    multipart = require('./multipart'),\n    auth = require('./auth'),\n    cookies = require('./cookies'),\n    parsers = require('./parsers'),\n    decoder = require('./decoder'); //////////////////////////////////////////\n// variabilia\n\n\nvar version = require('../package.json').version;\n\nvar user_agent = 'Needle/' + version;\nuser_agent += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';\nvar tls_options = 'agent pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity'; // older versions of node (< 0.11.4) prevent the runtime from exiting\n// because of connections in keep-alive state. so if this is the case\n// we'll default new requests to set a Connection: close header.\n\nvar close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity; // see if we have Object.assign. otherwise fall back to util._extend\n\nvar extend = Object.assign ? Object.assign : require('util')._extend; // these are the status codes that Needle interprets as redirects.\n\nvar redirect_codes = [301, 302, 303, 307]; //////////////////////////////////////////\n// decompressors for gzip/deflate bodies\n\nvar decompressors = {};\n\ntry {\n  var zlib = require('zlib');\n\n  decompressors['x-deflate'] = zlib.Inflate;\n  decompressors['deflate'] = zlib.Inflate;\n  decompressors['x-gzip'] = zlib.Gunzip;\n  decompressors['gzip'] = zlib.Gunzip; // Enable Z_SYNC_FLUSH to avoid Z_BUF_ERROR errors (Node PR #2595)\n\n  var zlib_options = {\n    flush: zlib.Z_SYNC_FLUSH,\n    finishFlush: zlib.Z_SYNC_FLUSH\n  };\n} catch (e) {}\n/* zlib not available */\n//////////////////////////////////////////\n// options and aliases\n\n\nvar defaults = {\n  // data\n  boundary: '--------------------NODENEEDLEHTTPCLIENT',\n  encoding: 'utf8',\n  parse_response: 'all',\n  // same as true. valid options: 'json', 'xml' or false/null\n  proxy: null,\n  // headers\n  accept: '*/*',\n  user_agent: user_agent,\n  // numbers\n  open_timeout: 10000,\n  response_timeout: 0,\n  read_timeout: 0,\n  follow_max: 0,\n  stream_length: -1,\n  // booleans\n  decode_response: true,\n  parse_cookies: true,\n  follow_set_cookies: false,\n  follow_set_referer: false,\n  follow_keep_method: false,\n  follow_if_same_host: false,\n  follow_if_same_protocol: false\n};\nvar aliased = {\n  options: {\n    decode: 'decode_response',\n    parse: 'parse_response',\n    timeout: 'open_timeout',\n    follow: 'follow_max'\n  },\n  inverted: {}\n}; // only once, invert aliased keys so we can get passed options.\n\nObject.keys(aliased.options).map(function (k) {\n  var value = aliased.options[k];\n  aliased.inverted[value] = k;\n}); //////////////////////////////////////////\n// helpers\n\nfunction keys_by_type(type) {\n  return Object.keys(defaults).map(function (el) {\n    if (defaults[el] !== null && defaults[el].constructor == type) return el;\n  }).filter(function (el) {\n    return el;\n  });\n}\n\nfunction parse_content_type(header) {\n  if (!header || header === '') return {};\n  var found,\n      charset = 'iso-8859-1',\n      arr = header.split(';');\n  if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/))) charset = found[1];\n  return {\n    type: arr[0],\n    charset: charset\n  };\n}\n\nfunction is_stream(obj) {\n  return typeof obj.pipe === 'function';\n}\n\nfunction get_stream_length(stream, given_length, cb) {\n  if (given_length > 0) return cb(given_length);\n  if (stream.end !== void 0 && stream.end !== Infinity && stream.start !== void 0) return cb(stream.end + 1 - (stream.start || 0));\n  fs.stat(stream.path, function (err, stat) {\n    cb(stat ? stat.size - (stream.start || 0) : null);\n  });\n} //////////////////////////////////////////\n// the main act\n\n\nfunction Needle(method, uri, data, options, callback) {\n  // if (!(this instanceof Needle)) {\n  //   return new Needle(method, uri, data, options, callback);\n  // }\n  if (typeof uri !== 'string') throw new TypeError('URL must be a string, not ' + uri);\n  this.method = method;\n  this.uri = uri;\n  this.data = data;\n\n  if (typeof options == 'function') {\n    this.callback = options;\n    this.options = {};\n  } else {\n    this.callback = callback;\n    this.options = options;\n  }\n}\n\nNeedle.prototype.setup = function (uri, options) {\n  function get_option(key, fallback) {\n    // if original is in options, return that value\n    if (typeof options[key] != 'undefined') return options[key]; // otherwise, return value from alias or fallback/undefined\n\n    return typeof options[aliased.inverted[key]] != 'undefined' ? options[aliased.inverted[key]] : fallback;\n  }\n\n  function check_value(expected, key) {\n    var value = get_option(key),\n        type = typeof value;\n    if (type != 'undefined' && type != expected) throw new TypeError(type + ' received for ' + key + ', but expected a ' + expected);\n    return type == expected ? value : defaults[key];\n  } //////////////////////////////////////////////////\n  // the basics\n\n\n  var config = {\n    http_opts: {\n      localAddress: get_option('localAddress', undefined)\n    },\n    // passed later to http.request() directly\n    output: options.output,\n    proxy: get_option('proxy', defaults.proxy),\n    parser: get_option('parse_response', defaults.parse_response),\n    encoding: options.encoding || (options.multipart ? 'binary' : defaults.encoding)\n  };\n  keys_by_type(Boolean).forEach(function (key) {\n    config[key] = check_value('boolean', key);\n  });\n  keys_by_type(Number).forEach(function (key) {\n    config[key] = check_value('number', key);\n  }); // populate http_opts with given TLS options\n\n  tls_options.split(' ').forEach(function (key) {\n    if (typeof options[key] != 'undefined') {\n      config.http_opts[key] = options[key];\n      if (typeof options.agent == 'undefined') config.http_opts.agent = false; // otherwise tls options are skipped\n    }\n  }); //////////////////////////////////////////////////\n  // headers, cookies\n\n  config.headers = {\n    'accept': options.accept || defaults.accept,\n    'user-agent': options.user_agent || defaults.user_agent\n  };\n  if (options.content_type) config.headers['content-type'] = options.content_type; // set connection header if opts.connection was passed, or if node < 0.11.4 (close)\n\n  if (options.connection || close_by_default) config.headers['connection'] = options.connection || 'close';\n  if ((options.compressed || defaults.compressed) && typeof zlib != 'undefined') config.headers['accept-encoding'] = 'gzip,deflate';\n  if (options.cookies) config.headers['cookie'] = cookies.write(options.cookies); //////////////////////////////////////////////////\n  // basic/digest auth\n\n  if (uri.match(/[^\\/]@/)) {\n    // url contains user:pass@host, so parse it.\n    var parts = (url.parse(uri).auth || '').split(':');\n    options.username = parts[0];\n    options.password = parts[1];\n  }\n\n  if (options.username) {\n    if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {\n      config.credentials = [options.username, options.password];\n    } else {\n      config.headers['authorization'] = auth.basic(options.username, options.password);\n    }\n  } // if proxy is present, set auth header from either url or proxy_user option.\n\n\n  if (config.proxy) {\n    if (config.proxy.indexOf('http') === -1) config.proxy = 'http://' + config.proxy;\n\n    if (config.proxy.indexOf('@') !== -1) {\n      var proxy = (url.parse(config.proxy).auth || '').split(':');\n      options.proxy_user = proxy[0];\n      options.proxy_pass = proxy[1];\n    }\n\n    if (options.proxy_user) config.headers['proxy-authorization'] = auth.basic(options.proxy_user, options.proxy_pass);\n  } // now that all our headers are set, overwrite them if instructed.\n\n\n  for (var h in options.headers) config.headers[h.toLowerCase()] = options.headers[h];\n\n  return config;\n};\n\nNeedle.prototype.start = function () {\n  var out = new stream.PassThrough({\n    objectMode: false\n  }),\n      uri = this.uri,\n      data = this.data,\n      method = this.method,\n      callback = typeof this.options == 'function' ? this.options : this.callback,\n      options = this.options || {}; // if no 'http' is found on URL, prepend it.\n\n  if (uri.indexOf('http') === -1) uri = uri.replace(/^(\\/\\/)?/, 'http://');\n  var self = this,\n      body,\n      waiting = false,\n      config = this.setup(uri, options); // unless options.json was set to false, assume boss also wants JSON if content-type matches.\n\n  var json = options.json || options.json !== false && config.headers['content-type'] == 'application/json';\n\n  if (data) {\n    if (options.multipart) {\n      // boss says we do multipart. so we do it.\n      var boundary = options.boundary || defaults.boundary;\n      waiting = true;\n      multipart.build(data, boundary, function (err, parts) {\n        if (err) throw err;\n        config.headers['content-type'] = 'multipart/form-data; boundary=' + boundary;\n        next(parts);\n      });\n    } else if (is_stream(data)) {\n      if (method.toUpperCase() == 'GET') throw new Error('Refusing to pipe() a stream via GET. Did you mean .post?');\n\n      if (config.stream_length > 0 || config.stream_length === 0 && data.path) {\n        // ok, let's get the stream's length and set it as the content-length header.\n        // this prevents some servers from cutting us off before all the data is sent.\n        waiting = true;\n        get_stream_length(data, config.stream_length, function (length) {\n          data.length = length;\n          next(data);\n        });\n      } else {\n        // if the boss doesn't want us to get the stream's length, or if it doesn't\n        // have a file descriptor for that purpose, then just head on.\n        body = data;\n      }\n    } else if (Buffer.isBuffer(data)) {\n      body = data; // use the raw buffer as request body.\n    } else if (method.toUpperCase() == 'GET' && !json) {\n      // append the data to the URI as a querystring.\n      uri = uri.replace(/\\?.*|$/, '?' + stringify(data));\n    } else {\n      // string or object data, no multipart.\n      // if string, leave it as it is, otherwise, stringify.\n      body = typeof data === 'string' ? data : json ? JSON.stringify(data) : stringify(data); // ensure we have a buffer so bytecount is correct.\n\n      body = Buffer.from(body, config.encoding);\n    }\n  }\n\n  function next(body) {\n    if (body) {\n      if (body.length) config.headers['content-length'] = body.length; // if no content-type was passed, determine if json or not.\n\n      if (!config.headers['content-type']) {\n        config.headers['content-type'] = json ? 'application/json; charset=utf-8' : 'application/x-www-form-urlencoded'; // no charset says W3 spec.\n      }\n    } // unless a specific accept header was set, assume json: true wants JSON back.\n\n\n    if (options.json && !options.accept && !(options.headers || {}).accept) config.headers['accept'] = 'application/json';\n    self.send_request(1, method, uri, config, body, out, callback);\n  }\n\n  if (!waiting) next(body);\n  return out;\n};\n\nNeedle.prototype.get_request_opts = function (method, uri, config) {\n  var opts = config.http_opts,\n      proxy = config.proxy,\n      remote = proxy ? url.parse(proxy) : url.parse(uri);\n  opts.protocol = remote.protocol;\n  opts.host = remote.hostname;\n  opts.port = remote.port || (remote.protocol == 'https:' ? 443 : 80);\n  opts.path = proxy ? uri : remote.pathname + (remote.search || '');\n  opts.method = method;\n  opts.headers = config.headers;\n\n  if (!opts.headers['host']) {\n    // if using proxy, make sure the host header shows the final destination\n    var target = proxy ? url.parse(uri) : remote;\n    opts.headers['host'] = target.hostname; // and if a non standard port was passed, append it to the port header\n\n    if (target.port && [80, 443].indexOf(target.port) === -1) {\n      opts.headers['host'] += ':' + target.port;\n    }\n  }\n\n  return opts;\n};\n\nNeedle.prototype.should_follow = function (location, config, original) {\n  if (!location) return false; // returns true if location contains matching property (host or protocol)\n\n  function matches(property) {\n    var property = original[property];\n    return location.indexOf(property) !== -1;\n  } // first, check whether the requested location is actually different from the original\n\n\n  if (location === original) return false;\n  if (config.follow_if_same_host && !matches('host')) return false; // host does not match, so not following\n\n  if (config.follow_if_same_protocol && !matches('protocol')) return false; // procotol does not match, so not following\n\n  return true;\n};\n\nNeedle.prototype.send_request = function (count, method, uri, config, post_data, out, callback) {\n  var timer,\n      returned = 0,\n      self = this,\n      request_opts = this.get_request_opts(method, uri, config),\n      protocol = request_opts.protocol == 'https:' ? https : http;\n\n  function done(err, resp) {\n    if (returned++ > 0) return debug('Already finished, stopping here.');\n    if (timer) clearTimeout(timer);\n    request.removeListener('error', had_error);\n    if (callback) return callback(err, resp, resp ? resp.body : undefined); // NOTE: this event used to be called 'end', but the behaviour was confusing\n    // when errors ocurred, because the stream would still emit an 'end' event.\n\n    out.emit('done', err);\n  }\n\n  function had_error(err) {\n    debug('Request error', err);\n    out.emit('err', err);\n    done(err || new Error('Unknown error when making request.'));\n  }\n\n  function set_timeout(type, milisecs) {\n    if (timer) clearTimeout(timer);\n    if (milisecs <= 0) return;\n    timer = setTimeout(function () {\n      out.emit('timeout', type);\n      request.abort(); // also invoke done() to terminate job on read_timeout\n\n      if (type == 'read') done(new Error(type + ' timeout'));\n    }, milisecs);\n  } // handle errors on the underlying socket, that may be closed while writing\n  // for an example case, see test/long_string_spec.js. we make sure this\n  // scenario ocurred by verifying the socket's writable & destroyed states.\n\n\n  function on_socket_end() {\n    if (!this.writable && this.destroyed === false) {\n      this.destroy();\n      had_error(new Error('Remote end closed socket abruptly.'));\n    }\n  }\n\n  debug('Making request #' + count, request_opts);\n  var request = protocol.request(request_opts, function (resp) {\n    var headers = resp.headers;\n    debug('Got response', resp.statusCode, headers);\n    out.emit('response', resp);\n    set_timeout('read', config.read_timeout); // if we got cookies, parse them unless we were instructed not to. make sure to include any\n    // cookies that might have been set on previous redirects.\n\n    if (config.parse_cookies && (headers['set-cookie'] || config.stored_cookies)) {\n      resp.cookies = extend(config.stored_cookies || {}, cookies.read(headers['set-cookie']));\n      debug('Got cookies', resp.cookies);\n    } // if redirect code is found, determine if we should follow it according to the given options.\n\n\n    if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {\n      // clear timer before following redirects to prevent unexpected setTimeout consequence\n      clearTimeout(timer);\n\n      if (count <= config.follow_max) {\n        out.emit('redirect', headers.location); // unless 'follow_keep_method' is true, rewrite the request to GET before continuing.\n\n        if (!config.follow_keep_method) {\n          method = 'GET';\n          post_data = null;\n          delete config.headers['content-length']; // in case the original was a multipart POST request.\n        } // if follow_set_cookies is true, make sure to put any cookies in the next request's headers.\n\n\n        if (config.follow_set_cookies && resp.cookies) {\n          config.stored_cookies = resp.cookies;\n          config.headers['cookie'] = cookies.write(resp.cookies);\n        }\n\n        if (config.follow_set_referer) config.headers['referer'] = encodeURI(uri); // the original, not the destination URL.\n\n        config.headers['host'] = null; // clear previous Host header to avoid conflicts.\n\n        debug('Redirecting to ' + url.resolve(uri, headers.location));\n        return self.send_request(++count, method, url.resolve(uri, headers.location), config, post_data, out, callback);\n      } else if (config.follow_max > 0) {\n        return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));\n      }\n    } // if auth is requested and credentials were not passed, resend request, provided we have user/pass.\n\n\n    if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {\n      if (!config.headers['authorization']) {\n        // only if authentication hasn't been sent\n        var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts);\n\n        if (auth_header) {\n          config.headers['authorization'] = auth_header;\n          return self.send_request(count, method, uri, config, post_data, out, callback);\n        }\n      }\n    } // ok, so we got a valid (non-redirect & authorized) response. let's notify the stream guys.\n\n\n    out.emit('header', resp.statusCode, headers);\n    out.emit('headers', headers);\n    var pipeline = [],\n        mime = parse_content_type(headers['content-type']),\n        text_response = mime.type && mime.type.indexOf('text/') != -1; // To start, if our body is compressed and we're able to inflate it, do it.\n\n    if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {\n      var decompressor = decompressors[headers['content-encoding']](zlib_options); // make sure we catch errors triggered by the decompressor.\n\n      decompressor.on('error', had_error);\n      pipeline.push(decompressor);\n    } // If parse is enabled and we have a parser for it, then go for it.\n\n\n    if (config.parser && parsers[mime.type]) {\n      // If a specific parser was requested, make sure we don't parse other types.\n      var parser_name = config.parser.toString().toLowerCase();\n\n      if (['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {\n        // OK, so either we're parsing all content types or the one requested matches.\n        out.parser = parsers[mime.type].name;\n        pipeline.push(parsers[mime.type].fn()); // Set objectMode on out stream to improve performance.\n\n        out._writableState.objectMode = true;\n        out._readableState.objectMode = true;\n      } // If we're not parsing, and unless decoding was disabled, we'll try\n      // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.\n\n    } else if (text_response && config.decode_response && mime.charset && !mime.charset.match(/utf-?8$/i)) {\n      pipeline.push(decoder(mime.charset));\n    } // And `out` is the stream we finally push the decoded/parsed output to.\n\n\n    pipeline.push(out); // Now, release the kraken!\n\n    var tmp = resp;\n\n    while (pipeline.length) {\n      tmp = tmp.pipe(pipeline.shift());\n    } // If the user has requested and output file, pipe the output stream to it.\n    // In stream mode, we will still get the response stream to play with.\n\n\n    if (config.output && resp.statusCode == 200) {\n      // for some reason, simply piping resp to the writable stream doesn't\n      // work all the time (stream gets cut in the middle with no warning).\n      // so we'll manually need to do the readable/write(chunk) trick.\n      var file = fs.createWriteStream(config.output);\n      file.on('error', had_error);\n      out.on('end', function () {\n        if (file.writable) file.end();\n      });\n      file.on('close', function () {\n        delete out.file;\n      });\n      out.on('readable', function () {\n        var chunk;\n\n        while ((chunk = this.read()) !== null) {\n          if (file.writable) file.write(chunk); // if callback was requested, also push it to resp.body\n\n          if (resp.body) resp.body.push(chunk);\n        }\n      });\n      out.file = file;\n    } // Only aggregate the full body if a callback was requested.\n\n\n    if (callback) {\n      resp.raw = [];\n      resp.body = [];\n      resp.bytes = 0; // Gather and count the amount of (raw) bytes using a PassThrough stream.\n\n      var clean_pipe = new stream.PassThrough();\n      resp.pipe(clean_pipe);\n      clean_pipe.on('readable', function () {\n        var chunk;\n\n        while ((chunk = this.read()) != null) {\n          resp.bytes += chunk.length;\n          resp.raw.push(chunk);\n        }\n      }); // Listen on the 'readable' event to aggregate the chunks, but only if\n      // file output wasn't requested. Otherwise we'd have two stream readers.\n\n      if (!config.output || resp.statusCode != 200) {\n        out.on('readable', function () {\n          var chunk;\n\n          while ((chunk = this.read()) !== null) {\n            // We're either pushing buffers or objects, never strings.\n            if (typeof chunk == 'string') chunk = Buffer.from(chunk); // Push all chunks to resp.body. We'll bind them in resp.end().\n\n            resp.body.push(chunk);\n          }\n        });\n      }\n    } // And set the .body property once all data is in.\n\n\n    out.on('end', function () {\n      if (resp.body) {\n        // callback mode\n        // we want to be able to access to the raw data later, so keep a reference.\n        resp.raw = Buffer.concat(resp.raw); // if parse was successful, we should have an array with one object\n\n        if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {\n          // that's our body right there.\n          resp.body = resp.body[0]; // set the parser property on our response. we may want to check.\n\n          if (out.parser) resp.parser = out.parser;\n        } else {\n          // we got one or several buffers. string or binary.\n          resp.body = Buffer.concat(resp.body); // if we're here and parsed is true, it means we tried to but it didn't work.\n          // so given that we got a text response, let's stringify it.\n\n          if (text_response || out.parser) {\n            resp.body = resp.body.toString();\n          }\n        }\n      } // if an output file is being written to, make sure the callback\n      // is triggered after all data has been written to it.\n\n\n      if (out.file) {\n        out.file.on('close', function () {\n          done(null, resp, resp.body);\n        });\n      } else {\n        // elvis has left the building.\n        done(null, resp, resp.body);\n      }\n    });\n  }); // end request call\n  // unless open_timeout was disabled, set a timeout to abort the request.\n\n  set_timeout('open', config.open_timeout); // handle errors on the request object. things might get bumpy.\n\n  request.on('error', had_error); // make sure timer is cleared if request is aborted (issue #257)\n\n  request.once('abort', function () {\n    if (timer) clearTimeout(timer);\n  }); // handle socket 'end' event to ensure we don't get delayed EPIPE errors.\n\n  request.once('socket', function (socket) {\n    if (socket.connecting) {\n      socket.once('connect', function () {\n        set_timeout('response', config.response_timeout);\n      });\n    } else {\n      set_timeout('response', config.response_timeout);\n    } // console.log(socket);\n\n\n    if (!socket.on_socket_end) {\n      socket.on_socket_end = on_socket_end;\n      socket.once('end', function () {\n        process.nextTick(on_socket_end.bind(socket));\n      });\n    }\n  });\n\n  if (post_data) {\n    if (is_stream(post_data)) {\n      post_data.pipe(request);\n    } else {\n      request.write(post_data, config.encoding);\n      request.end();\n    }\n  } else {\n    request.end();\n  }\n\n  out.request = request;\n  return out;\n}; //////////////////////////////////////////\n// exports\n\n\nif (typeof Promise !== 'undefined') {\n  module.exports = function () {\n    var verb,\n        args = [].slice.call(arguments);\n    if (args[0].match(/\\.|\\//)) // first argument looks like a URL\n      verb = args.length > 2 ? 'post' : 'get';else verb = args.shift();\n    if (verb.match(/get|head/) && args.length == 2) args.splice(1, 0, null); // assume no data if head/get with two args (url, options)\n\n    return new Promise(function (resolve, reject) {\n      module.exports.request(verb, args[0], args[1], args[2], function (err, resp) {\n        return err ? reject(err) : resolve(resp);\n      });\n    });\n  };\n}\n\nmodule.exports.version = version;\n\nmodule.exports.defaults = function (obj) {\n  for (var key in obj) {\n    var target_key = aliased.options[key] || key;\n\n    if (defaults.hasOwnProperty(target_key) && typeof obj[key] != 'undefined') {\n      if (target_key != 'parse_response' && target_key != 'proxy') {\n        // ensure type matches the original, except for proxy/parse_response that can be null/bool or string\n        var valid_type = defaults[target_key].constructor.name;\n        if (obj[key].constructor.name != valid_type) throw new TypeError('Invalid type for ' + key + ', should be ' + valid_type);\n      }\n\n      defaults[target_key] = obj[key];\n    }\n  }\n\n  return defaults;\n};\n\n'head get'.split(' ').forEach(function (method) {\n  module.exports[method] = function (uri, options, callback) {\n    return new Needle(method, uri, null, options, callback).start();\n  };\n});\n'post put patch delete'.split(' ').forEach(function (method) {\n  module.exports[method] = function (uri, data, options, callback) {\n    return new Needle(method, uri, data, options, callback).start();\n  };\n});\n\nmodule.exports.request = function (method, uri, data, opts, callback) {\n  return new Needle(method, uri, data, opts, callback).start();\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/chokidar/node_modules/fsevents/node_modules/needle/lib/needle.js"],"names":["fs","require","http","https","url","stream","debug","stringify","build","multipart","auth","cookies","parsers","decoder","version","user_agent","process","platform","arch","tls_options","close_by_default","Agent","defaultMaxSockets","Infinity","extend","Object","assign","_extend","redirect_codes","decompressors","zlib","Inflate","Gunzip","zlib_options","flush","Z_SYNC_FLUSH","finishFlush","e","defaults","boundary","encoding","parse_response","proxy","accept","open_timeout","response_timeout","read_timeout","follow_max","stream_length","decode_response","parse_cookies","follow_set_cookies","follow_set_referer","follow_keep_method","follow_if_same_host","follow_if_same_protocol","aliased","options","decode","parse","timeout","follow","inverted","keys","map","k","value","keys_by_type","type","el","constructor","filter","parse_content_type","header","found","charset","arr","split","length","match","is_stream","obj","pipe","get_stream_length","given_length","cb","end","start","stat","path","err","size","Needle","method","uri","data","callback","TypeError","prototype","setup","get_option","key","fallback","check_value","expected","config","http_opts","localAddress","undefined","output","parser","Boolean","forEach","Number","agent","headers","content_type","connection","compressed","write","parts","username","password","credentials","basic","indexOf","proxy_user","proxy_pass","h","toLowerCase","out","PassThrough","objectMode","replace","self","body","waiting","json","next","toUpperCase","Error","Buffer","isBuffer","JSON","from","send_request","get_request_opts","opts","remote","protocol","host","hostname","port","pathname","search","target","should_follow","location","original","matches","property","count","post_data","timer","returned","request_opts","done","resp","clearTimeout","request","removeListener","had_error","emit","set_timeout","milisecs","setTimeout","abort","on_socket_end","writable","destroyed","destroy","statusCode","stored_cookies","read","encodeURI","resolve","auth_header","pipeline","mime","text_response","decompressor","on","push","parser_name","toString","name","fn","_writableState","_readableState","tmp","shift","file","createWriteStream","chunk","raw","bytes","clean_pipe","concat","once","socket","connecting","nextTick","bind","Promise","module","exports","verb","args","slice","call","arguments","splice","reject","target_key","hasOwnProperty","valid_type"],"mappings":"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","sourcesContent":["//////////////////////////////////////////\n// Needle -- HTTP Client for Node.js\n// Written by Tom√°s Pollak <tomas@forkhq.com>\n// (c) 2012-2017 - Fork Ltd.\n// MIT Licensed\n//////////////////////////////////////////\n\nvar fs          = require('fs'),\n    http        = require('http'),\n    https       = require('https'),\n    url         = require('url'),\n    stream      = require('stream'),\n    debug       = require('debug')('needle'),\n    stringify   = require('./querystring').build,\n    multipart   = require('./multipart'),\n    auth        = require('./auth'),\n    cookies     = require('./cookies'),\n    parsers     = require('./parsers'),\n    decoder     = require('./decoder');\n\n//////////////////////////////////////////\n// variabilia\n\nvar version     = require('../package.json').version;\n\nvar user_agent  = 'Needle/' + version;\nuser_agent     += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';\n\nvar tls_options = 'agent pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity';\n\n// older versions of node (< 0.11.4) prevent the runtime from exiting\n// because of connections in keep-alive state. so if this is the case\n// we'll default new requests to set a Connection: close header.\nvar close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity;\n\n// see if we have Object.assign. otherwise fall back to util._extend\nvar extend = Object.assign ? Object.assign : require('util')._extend;\n\n// these are the status codes that Needle interprets as redirects.\nvar redirect_codes = [301, 302, 303, 307];\n\n//////////////////////////////////////////\n// decompressors for gzip/deflate bodies\n\nvar decompressors = {};\n\ntry {\n\n  var zlib = require('zlib');\n  decompressors['x-deflate'] = zlib.Inflate;\n  decompressors['deflate']   = zlib.Inflate;\n  decompressors['x-gzip']    = zlib.Gunzip;\n  decompressors['gzip']      = zlib.Gunzip;\n\n  // Enable Z_SYNC_FLUSH to avoid Z_BUF_ERROR errors (Node PR #2595)\n  var zlib_options = {\n    flush: zlib.Z_SYNC_FLUSH,\n    finishFlush: zlib.Z_SYNC_FLUSH\n  }\n\n} catch(e) { /* zlib not available */ }\n\n//////////////////////////////////////////\n// options and aliases\n\nvar defaults = {\n  // data\n  boundary                : '--------------------NODENEEDLEHTTPCLIENT',\n  encoding                : 'utf8',\n  parse_response          : 'all', // same as true. valid options: 'json', 'xml' or false/null\n  proxy                   : null,\n\n  // headers\n  accept                  : '*/*',\n  user_agent              : user_agent,\n\n  // numbers\n  open_timeout            : 10000,\n  response_timeout        : 0,\n  read_timeout            : 0,\n  follow_max              : 0,\n  stream_length           : -1,\n\n  // booleans\n  decode_response         : true,\n  parse_cookies           : true,\n  follow_set_cookies      : false,\n  follow_set_referer      : false,\n  follow_keep_method      : false,\n  follow_if_same_host     : false,\n  follow_if_same_protocol : false\n}\n\nvar aliased = {\n  options: {\n    decode  : 'decode_response',\n    parse   : 'parse_response',\n    timeout : 'open_timeout',\n    follow  : 'follow_max'\n  },\n  inverted: {}\n}\n\n// only once, invert aliased keys so we can get passed options.\nObject.keys(aliased.options).map(function(k) {\n  var value = aliased.options[k];\n  aliased.inverted[value] = k;\n});\n\n//////////////////////////////////////////\n// helpers\n\nfunction keys_by_type(type) {\n  return Object.keys(defaults).map(function(el) {\n    if (defaults[el] !== null && defaults[el].constructor == type)\n      return el;\n  }).filter(function(el) { return el })\n}\n\nfunction parse_content_type(header) {\n  if (!header || header === '') return {};\n\n  var found, charset = 'iso-8859-1', arr = header.split(';');\n\n  if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/)))\n    charset = found[1];\n\n  return { type: arr[0], charset: charset };\n}\n\nfunction is_stream(obj) {\n  return typeof obj.pipe === 'function';\n}\n\nfunction get_stream_length(stream, given_length, cb) {\n  if (given_length > 0)\n    return cb(given_length);\n\n  if (stream.end !== void 0 && stream.end !== Infinity && stream.start !== void 0)\n    return cb((stream.end + 1) - (stream.start || 0));\n\n  fs.stat(stream.path, function(err, stat) {\n    cb(stat ? stat.size - (stream.start || 0) : null);\n  });\n}\n\n//////////////////////////////////////////\n// the main act\n\nfunction Needle(method, uri, data, options, callback) {\n  // if (!(this instanceof Needle)) {\n  //   return new Needle(method, uri, data, options, callback);\n  // }\n\n  if (typeof uri !== 'string')\n    throw new TypeError('URL must be a string, not ' + uri);\n\n  this.method   = method;\n  this.uri      = uri;\n  this.data     = data;\n\n  if (typeof options == 'function') {\n    this.callback = options;\n    this.options  = {};\n  } else {\n    this.callback = callback;\n    this.options  = options;\n  }\n\n}\n\nNeedle.prototype.setup = function(uri, options) {\n\n  function get_option(key, fallback) {\n    // if original is in options, return that value\n    if (typeof options[key] != 'undefined') return options[key];\n\n    // otherwise, return value from alias or fallback/undefined\n    return typeof options[aliased.inverted[key]] != 'undefined'\n                ? options[aliased.inverted[key]] : fallback;\n  }\n\n  function check_value(expected, key) {\n    var value = get_option(key),\n        type  = typeof value;\n\n    if (type != 'undefined' && type != expected)\n      throw new TypeError(type + ' received for ' + key + ', but expected a ' + expected);\n\n    return (type == expected) ? value : defaults[key];\n  }\n\n  //////////////////////////////////////////////////\n  // the basics\n\n  var config = {\n    http_opts : {\n      localAddress: get_option('localAddress', undefined)\n    }, // passed later to http.request() directly\n    output    : options.output,\n    proxy     : get_option('proxy', defaults.proxy),\n    parser    : get_option('parse_response', defaults.parse_response),\n    encoding  : options.encoding || (options.multipart ? 'binary' : defaults.encoding)\n  }\n\n  keys_by_type(Boolean).forEach(function(key) {\n    config[key] = check_value('boolean', key);\n  })\n\n  keys_by_type(Number).forEach(function(key) {\n    config[key] = check_value('number', key);\n  })\n\n  // populate http_opts with given TLS options\n  tls_options.split(' ').forEach(function(key) {\n    if (typeof options[key] != 'undefined') {\n      config.http_opts[key] = options[key];\n      if (typeof options.agent == 'undefined')\n        config.http_opts.agent = false; // otherwise tls options are skipped\n    }\n  });\n\n  //////////////////////////////////////////////////\n  // headers, cookies\n\n  config.headers = {\n    'accept'     : options.accept     || defaults.accept,\n    'user-agent' : options.user_agent || defaults.user_agent\n  }\n\n  if (options.content_type)\n    config.headers['content-type'] = options.content_type;\n\n  // set connection header if opts.connection was passed, or if node < 0.11.4 (close)\n  if (options.connection || close_by_default)\n    config.headers['connection'] = options.connection || 'close';\n\n  if ((options.compressed || defaults.compressed) && typeof zlib != 'undefined')\n    config.headers['accept-encoding'] = 'gzip,deflate';\n\n  if (options.cookies)\n    config.headers['cookie'] = cookies.write(options.cookies);\n\n  //////////////////////////////////////////////////\n  // basic/digest auth\n\n  if (uri.match(/[^\\/]@/)) { // url contains user:pass@host, so parse it.\n    var parts = (url.parse(uri).auth || '').split(':');\n    options.username = parts[0];\n    options.password = parts[1];\n  }\n\n  if (options.username) {\n    if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {\n      config.credentials = [options.username, options.password];\n    } else {\n      config.headers['authorization'] = auth.basic(options.username, options.password);\n    }\n  }\n\n  // if proxy is present, set auth header from either url or proxy_user option.\n  if (config.proxy) {\n    if (config.proxy.indexOf('http') === -1)\n      config.proxy = 'http://' + config.proxy;\n\n    if (config.proxy.indexOf('@') !== -1) {\n      var proxy = (url.parse(config.proxy).auth || '').split(':');\n      options.proxy_user = proxy[0];\n      options.proxy_pass = proxy[1];\n    }\n\n    if (options.proxy_user)\n      config.headers['proxy-authorization'] = auth.basic(options.proxy_user, options.proxy_pass);\n  }\n\n  // now that all our headers are set, overwrite them if instructed.\n  for (var h in options.headers)\n    config.headers[h.toLowerCase()] = options.headers[h];\n\n  return config;\n}\n\nNeedle.prototype.start = function() {\n\n  var out      = new stream.PassThrough({ objectMode: false }),\n      uri      = this.uri,\n      data     = this.data,\n      method   = this.method,\n      callback = (typeof this.options == 'function') ? this.options : this.callback,\n      options  = this.options || {};\n\n  // if no 'http' is found on URL, prepend it.\n  if (uri.indexOf('http') === -1)\n    uri = uri.replace(/^(\\/\\/)?/, 'http://');\n\n  var self = this, body, waiting = false, config = this.setup(uri, options);\n\n  // unless options.json was set to false, assume boss also wants JSON if content-type matches.\n  var json = options.json || (options.json !== false && config.headers['content-type'] == 'application/json');\n\n  if (data) {\n\n    if (options.multipart) { // boss says we do multipart. so we do it.\n      var boundary = options.boundary || defaults.boundary;\n\n      waiting = true;\n      multipart.build(data, boundary, function(err, parts) {\n        if (err) throw(err);\n\n        config.headers['content-type'] = 'multipart/form-data; boundary=' + boundary;\n        next(parts);\n      });\n\n    } else if (is_stream(data)) {\n\n      if (method.toUpperCase() == 'GET')\n        throw new Error('Refusing to pipe() a stream via GET. Did you mean .post?');\n\n      if (config.stream_length > 0 || (config.stream_length === 0 && data.path)) {\n        // ok, let's get the stream's length and set it as the content-length header.\n        // this prevents some servers from cutting us off before all the data is sent.\n        waiting = true;\n        get_stream_length(data, config.stream_length, function(length) {\n          data.length = length;\n          next(data);\n        })\n\n      } else {\n        // if the boss doesn't want us to get the stream's length, or if it doesn't\n        // have a file descriptor for that purpose, then just head on.\n        body = data;\n      }\n\n    } else if (Buffer.isBuffer(data)) {\n\n      body = data; // use the raw buffer as request body.\n\n    } else if (method.toUpperCase() == 'GET' && !json) {\n\n      // append the data to the URI as a querystring.\n      uri = uri.replace(/\\?.*|$/, '?' + stringify(data));\n\n    } else { // string or object data, no multipart.\n\n      // if string, leave it as it is, otherwise, stringify.\n      body = (typeof(data) === 'string') ? data\n             : json ? JSON.stringify(data) : stringify(data);\n\n      // ensure we have a buffer so bytecount is correct.\n      body = Buffer.from(body, config.encoding);\n    }\n\n  }\n\n  function next(body) {\n    if (body) {\n      if (body.length) config.headers['content-length'] = body.length;\n\n      // if no content-type was passed, determine if json or not.\n      if (!config.headers['content-type']) {\n        config.headers['content-type'] = json\n        ? 'application/json; charset=utf-8'\n        : 'application/x-www-form-urlencoded'; // no charset says W3 spec.\n      }\n    }\n\n    // unless a specific accept header was set, assume json: true wants JSON back.\n    if (options.json && (!options.accept && !(options.headers || {}).accept))\n      config.headers['accept'] = 'application/json';\n\n    self.send_request(1, method, uri, config, body, out, callback);\n  }\n\n  if (!waiting) next(body);\n  return out;\n}\n\nNeedle.prototype.get_request_opts = function(method, uri, config) {\n  var opts      = config.http_opts,\n      proxy     = config.proxy,\n      remote    = proxy ? url.parse(proxy) : url.parse(uri);\n\n  opts.protocol = remote.protocol;\n  opts.host     = remote.hostname;\n  opts.port     = remote.port || (remote.protocol == 'https:' ? 443 : 80);\n  opts.path     = proxy ? uri : remote.pathname + (remote.search || '');\n  opts.method   = method;\n  opts.headers  = config.headers;\n\n  if (!opts.headers['host']) {\n    // if using proxy, make sure the host header shows the final destination\n    var target = proxy ? url.parse(uri) : remote;\n    opts.headers['host'] = target.hostname;\n\n    // and if a non standard port was passed, append it to the port header\n    if (target.port && [80, 443].indexOf(target.port) === -1) {\n      opts.headers['host'] += ':' + target.port;\n    }\n  }\n\n  return opts;\n}\n\nNeedle.prototype.should_follow = function(location, config, original) {\n  if (!location) return false;\n\n  // returns true if location contains matching property (host or protocol)\n  function matches(property) {\n    var property = original[property];\n    return location.indexOf(property) !== -1;\n  }\n\n  // first, check whether the requested location is actually different from the original\n  if (location === original)\n    return false;\n\n  if (config.follow_if_same_host && !matches('host'))\n    return false; // host does not match, so not following\n\n  if (config.follow_if_same_protocol && !matches('protocol'))\n    return false; // procotol does not match, so not following\n\n  return true;\n}\n\nNeedle.prototype.send_request = function(count, method, uri, config, post_data, out, callback) {\n\n  var timer,\n      returned     = 0,\n      self         = this,\n      request_opts = this.get_request_opts(method, uri, config),\n      protocol     = request_opts.protocol == 'https:' ? https : http;\n\n  function done(err, resp) {\n    if (returned++ > 0)\n      return debug('Already finished, stopping here.');\n\n    if (timer) clearTimeout(timer);\n    request.removeListener('error', had_error);\n\n    if (callback)\n      return callback(err, resp, resp ? resp.body : undefined);\n\n    // NOTE: this event used to be called 'end', but the behaviour was confusing\n    // when errors ocurred, because the stream would still emit an 'end' event.\n    out.emit('done', err);\n  }\n\n  function had_error(err) {\n    debug('Request error', err);\n    out.emit('err', err);\n    done(err || new Error('Unknown error when making request.'));\n  }\n\n  function set_timeout(type, milisecs) {\n    if (timer) clearTimeout(timer);\n    if (milisecs <= 0) return;\n\n    timer = setTimeout(function() {\n      out.emit('timeout', type);\n      request.abort();\n      // also invoke done() to terminate job on read_timeout\n      if (type == 'read') done(new Error(type + ' timeout'));\n    }, milisecs);\n  }\n\n  // handle errors on the underlying socket, that may be closed while writing\n  // for an example case, see test/long_string_spec.js. we make sure this\n  // scenario ocurred by verifying the socket's writable & destroyed states.\n  function on_socket_end() {\n    if (!this.writable && this.destroyed === false) {\n      this.destroy();\n      had_error(new Error('Remote end closed socket abruptly.'))\n    }\n  }\n\n  debug('Making request #' + count, request_opts);\n  var request = protocol.request(request_opts, function(resp) {\n\n    var headers = resp.headers;\n    debug('Got response', resp.statusCode, headers);\n    out.emit('response', resp);\n\n    set_timeout('read', config.read_timeout);\n\n    // if we got cookies, parse them unless we were instructed not to. make sure to include any\n    // cookies that might have been set on previous redirects.\n    if (config.parse_cookies && (headers['set-cookie'] || config.stored_cookies)) {\n      resp.cookies = extend(config.stored_cookies || {}, cookies.read(headers['set-cookie']));\n      debug('Got cookies', resp.cookies);\n    }\n\n    // if redirect code is found, determine if we should follow it according to the given options.\n    if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {\n      // clear timer before following redirects to prevent unexpected setTimeout consequence\n      clearTimeout(timer);\n\n      if (count <= config.follow_max) {\n        out.emit('redirect', headers.location);\n\n        // unless 'follow_keep_method' is true, rewrite the request to GET before continuing.\n        if (!config.follow_keep_method) {\n          method    = 'GET';\n          post_data = null;\n          delete config.headers['content-length']; // in case the original was a multipart POST request.\n        }\n\n        // if follow_set_cookies is true, make sure to put any cookies in the next request's headers.\n        if (config.follow_set_cookies && resp.cookies) {\n          config.stored_cookies    = resp.cookies;\n          config.headers['cookie'] = cookies.write(resp.cookies);\n        }\n\n        if (config.follow_set_referer)\n          config.headers['referer'] = encodeURI(uri); // the original, not the destination URL.\n\n        config.headers['host'] = null; // clear previous Host header to avoid conflicts.\n\n        debug('Redirecting to ' + url.resolve(uri, headers.location));\n        return self.send_request(++count, method, url.resolve(uri, headers.location), config, post_data, out, callback);\n      } else if (config.follow_max > 0) {\n        return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));\n      }\n    }\n\n    // if auth is requested and credentials were not passed, resend request, provided we have user/pass.\n    if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {\n      if (!config.headers['authorization']) { // only if authentication hasn't been sent\n        var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts);\n\n        if (auth_header) {\n          config.headers['authorization'] = auth_header;\n          return self.send_request(count, method, uri, config, post_data, out, callback);\n        }\n      }\n    }\n\n    // ok, so we got a valid (non-redirect & authorized) response. let's notify the stream guys.\n    out.emit('header', resp.statusCode, headers);\n    out.emit('headers', headers);\n\n    var pipeline      = [],\n        mime          = parse_content_type(headers['content-type']),\n        text_response = mime.type && mime.type.indexOf('text/') != -1;\n\n    // To start, if our body is compressed and we're able to inflate it, do it.\n    if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {\n\n      var decompressor = decompressors[headers['content-encoding']](zlib_options);\n\n      // make sure we catch errors triggered by the decompressor.\n      decompressor.on('error', had_error);\n      pipeline.push(decompressor);\n    }\n\n    // If parse is enabled and we have a parser for it, then go for it.\n    if (config.parser && parsers[mime.type]) {\n\n      // If a specific parser was requested, make sure we don't parse other types.\n      var parser_name = config.parser.toString().toLowerCase();\n      if (['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {\n\n        // OK, so either we're parsing all content types or the one requested matches.\n        out.parser = parsers[mime.type].name;\n        pipeline.push(parsers[mime.type].fn());\n\n        // Set objectMode on out stream to improve performance.\n        out._writableState.objectMode = true;\n        out._readableState.objectMode = true;\n      }\n\n    // If we're not parsing, and unless decoding was disabled, we'll try\n    // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.\n    } else if (text_response && config.decode_response\n      && mime.charset && !mime.charset.match(/utf-?8$/i)) {\n        pipeline.push(decoder(mime.charset));\n    }\n\n    // And `out` is the stream we finally push the decoded/parsed output to.\n    pipeline.push(out);\n\n    // Now, release the kraken!\n    var tmp = resp;\n    while (pipeline.length) {\n      tmp = tmp.pipe(pipeline.shift());\n    }\n\n    // If the user has requested and output file, pipe the output stream to it.\n    // In stream mode, we will still get the response stream to play with.\n    if (config.output && resp.statusCode == 200) {\n\n      // for some reason, simply piping resp to the writable stream doesn't\n      // work all the time (stream gets cut in the middle with no warning).\n      // so we'll manually need to do the readable/write(chunk) trick.\n      var file = fs.createWriteStream(config.output);\n      file.on('error', had_error);\n\n      out.on('end', function() {\n        if (file.writable) file.end();\n      });\n\n      file.on('close', function() {\n        delete out.file;\n      })\n\n      out.on('readable', function() {\n        var chunk;\n        while ((chunk = this.read()) !== null) {\n          if (file.writable) file.write(chunk);\n\n          // if callback was requested, also push it to resp.body\n          if (resp.body) resp.body.push(chunk);\n        }\n      })\n\n      out.file = file;\n    }\n\n    // Only aggregate the full body if a callback was requested.\n    if (callback) {\n      resp.raw   = [];\n      resp.body  = [];\n      resp.bytes = 0;\n\n      // Gather and count the amount of (raw) bytes using a PassThrough stream.\n      var clean_pipe = new stream.PassThrough();\n      resp.pipe(clean_pipe);\n\n      clean_pipe.on('readable', function() {\n        var chunk;\n        while ((chunk = this.read()) != null) {\n          resp.bytes += chunk.length;\n          resp.raw.push(chunk);\n        }\n      })\n\n      // Listen on the 'readable' event to aggregate the chunks, but only if\n      // file output wasn't requested. Otherwise we'd have two stream readers.\n      if (!config.output || resp.statusCode != 200) {\n        out.on('readable', function() {\n          var chunk;\n          while ((chunk = this.read()) !== null) {\n            // We're either pushing buffers or objects, never strings.\n            if (typeof chunk == 'string') chunk = Buffer.from(chunk);\n\n            // Push all chunks to resp.body. We'll bind them in resp.end().\n            resp.body.push(chunk);\n          }\n        })\n      }\n    }\n\n    // And set the .body property once all data is in.\n    out.on('end', function() {\n      if (resp.body) { // callback mode\n\n        // we want to be able to access to the raw data later, so keep a reference.\n        resp.raw = Buffer.concat(resp.raw);\n\n        // if parse was successful, we should have an array with one object\n        if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {\n\n          // that's our body right there.\n          resp.body = resp.body[0];\n\n          // set the parser property on our response. we may want to check.\n          if (out.parser) resp.parser = out.parser;\n\n        } else { // we got one or several buffers. string or binary.\n          resp.body = Buffer.concat(resp.body);\n\n          // if we're here and parsed is true, it means we tried to but it didn't work.\n          // so given that we got a text response, let's stringify it.\n          if (text_response || out.parser) {\n            resp.body = resp.body.toString();\n          }\n        }\n      }\n\n      // if an output file is being written to, make sure the callback\n      // is triggered after all data has been written to it.\n      if (out.file) {\n        out.file.on('close', function() {\n          done(null, resp, resp.body);\n        })\n      } else { // elvis has left the building.\n        done(null, resp, resp.body);\n      }\n\n    });\n\n  }); // end request call\n\n  // unless open_timeout was disabled, set a timeout to abort the request.\n  set_timeout('open', config.open_timeout);\n\n  // handle errors on the request object. things might get bumpy.\n  request.on('error', had_error);\n\n  // make sure timer is cleared if request is aborted (issue #257)\n  request.once('abort', function() {\n    if (timer) clearTimeout(timer);\n  })\n\n  // handle socket 'end' event to ensure we don't get delayed EPIPE errors.\n  request.once('socket', function(socket) {\n    if (socket.connecting) {\n      socket.once('connect', function() {\n        set_timeout('response', config.response_timeout);\n      })\n    } else {\n      set_timeout('response', config.response_timeout);\n    }\n\n    // console.log(socket);\n    if (!socket.on_socket_end) {\n      socket.on_socket_end = on_socket_end;\n      socket.once('end', function() { process.nextTick(on_socket_end.bind(socket)) });\n    }\n  })\n\n  if (post_data) {\n    if (is_stream(post_data)) {\n      post_data.pipe(request);\n    } else {\n      request.write(post_data, config.encoding);\n      request.end();\n    }\n  } else {\n    request.end();\n  }\n\n  out.request = request;\n  return out;\n}\n\n//////////////////////////////////////////\n// exports\n\nif (typeof Promise !== 'undefined') {\n  module.exports = function() {\n    var verb, args = [].slice.call(arguments);\n\n    if (args[0].match(/\\.|\\//)) // first argument looks like a URL\n      verb = (args.length > 2) ? 'post' : 'get';\n    else\n      verb = args.shift();\n\n    if (verb.match(/get|head/) && args.length == 2)\n      args.splice(1, 0, null); // assume no data if head/get with two args (url, options)\n\n    return new Promise(function(resolve, reject) {\n      module.exports.request(verb, args[0], args[1], args[2], function(err, resp) {\n        return err ? reject(err) : resolve(resp);\n      });\n    })\n  }\n}\n\nmodule.exports.version = version;\n\nmodule.exports.defaults = function(obj) {\n  for (var key in obj) {\n    var target_key = aliased.options[key] || key;\n\n    if (defaults.hasOwnProperty(target_key) && typeof obj[key] != 'undefined') {\n      if (target_key != 'parse_response' && target_key != 'proxy') {\n        // ensure type matches the original, except for proxy/parse_response that can be null/bool or string\n        var valid_type = defaults[target_key].constructor.name;\n\n        if (obj[key].constructor.name != valid_type)\n          throw new TypeError('Invalid type for ' + key + ', should be ' + valid_type);\n      }\n      defaults[target_key] = obj[key];\n    }\n  }\n\n  return defaults;\n}\n\n'head get'.split(' ').forEach(function(method) {\n  module.exports[method] = function(uri, options, callback) {\n    return new Needle(method, uri, null, options, callback).start();\n  }\n})\n\n'post put patch delete'.split(' ').forEach(function(method) {\n  module.exports[method] = function(uri, data, options, callback) {\n    return new Needle(method, uri, data, options, callback).start();\n  }\n})\n\nmodule.exports.request = function(method, uri, data, opts, callback) {\n  return new Needle(method, uri, data, opts, callback).start();\n};\n"]},"metadata":{},"sourceType":"script"}