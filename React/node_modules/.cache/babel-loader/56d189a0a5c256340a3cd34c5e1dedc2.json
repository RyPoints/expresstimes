{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst Buffer = require('buffer').Buffer;\n\nconst realZlib = require('zlib');\n\nconst constants = exports.constants = require('./constants.js');\n\nconst MiniPass = require('minipass');\n\nconst OriginalBufferConcat = Buffer.concat;\n\nclass ZlibError extends Error {\n  constructor(msg, errno) {\n    super('zlib: ' + msg);\n    this.errno = errno;\n    this.code = codes.get(errno);\n  }\n\n  get name() {\n    return 'ZlibError';\n  }\n\n} // translation table for return codes.\n\n\nconst codes = new Map([[constants.Z_OK, 'Z_OK'], [constants.Z_STREAM_END, 'Z_STREAM_END'], [constants.Z_NEED_DICT, 'Z_NEED_DICT'], [constants.Z_ERRNO, 'Z_ERRNO'], [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'], [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'], [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'], [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'], [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']]);\nconst validFlushFlags = new Set([constants.Z_NO_FLUSH, constants.Z_PARTIAL_FLUSH, constants.Z_SYNC_FLUSH, constants.Z_FULL_FLUSH, constants.Z_FINISH, constants.Z_BLOCK]);\nconst strategies = new Set([constants.Z_FILTERED, constants.Z_HUFFMAN_ONLY, constants.Z_RLE, constants.Z_FIXED, constants.Z_DEFAULT_STRATEGY]); // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nconst _opts = Symbol('opts');\n\nconst _flushFlag = Symbol('flushFlag');\n\nconst _finishFlush = Symbol('finishFlush');\n\nconst _handle = Symbol('handle');\n\nconst _onError = Symbol('onError');\n\nconst _level = Symbol('level');\n\nconst _strategy = Symbol('strategy');\n\nconst _ended = Symbol('ended');\n\nclass Zlib extends MiniPass {\n  constructor(opts, mode) {\n    super(opts);\n    this[_ended] = false;\n    this[_opts] = opts = opts || {};\n\n    if (opts.flush && !validFlushFlags.has(opts.flush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.flush);\n    }\n\n    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.finishFlush);\n    }\n\n    this[_flushFlag] = opts.flush || constants.Z_NO_FLUSH;\n    this[_finishFlush] = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : constants.Z_FINISH;\n\n    if (opts.chunkSize) {\n      if (opts.chunkSize < constants.Z_MIN_CHUNK) {\n        throw new RangeError('Invalid chunk size: ' + opts.chunkSize);\n      }\n    }\n\n    if (opts.windowBits) {\n      if (opts.windowBits < constants.Z_MIN_WINDOWBITS || opts.windowBits > constants.Z_MAX_WINDOWBITS) {\n        throw new RangeError('Invalid windowBits: ' + opts.windowBits);\n      }\n    }\n\n    if (opts.level) {\n      if (opts.level < constants.Z_MIN_LEVEL || opts.level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + opts.level);\n      }\n    }\n\n    if (opts.memLevel) {\n      if (opts.memLevel < constants.Z_MIN_MEMLEVEL || opts.memLevel > constants.Z_MAX_MEMLEVEL) {\n        throw new RangeError('Invalid memLevel: ' + opts.memLevel);\n      }\n    }\n\n    if (opts.strategy && !strategies.has(opts.strategy)) throw new TypeError('Invalid strategy: ' + opts.strategy);\n\n    if (opts.dictionary) {\n      if (!(opts.dictionary instanceof Buffer)) {\n        throw new TypeError('Invalid dictionary: it should be a Buffer instance');\n      }\n    }\n\n    this[_handle] = new realZlib[mode](opts);\n\n    this[_onError] = err => {\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close();\n      const error = new ZlibError(err.message, err.errno);\n      this.emit('error', error);\n    };\n\n    this[_handle].on('error', this[_onError]);\n\n    const level = typeof opts.level === 'number' ? opts.level : constants.Z_DEFAULT_COMPRESSION;\n    var strategy = typeof opts.strategy === 'number' ? opts.strategy : constants.Z_DEFAULT_STRATEGY; // API changed in node v9\n\n    /* istanbul ignore next */\n\n    this[_level] = level;\n    this[_strategy] = strategy;\n    this.once('end', this.close);\n  }\n\n  close() {\n    if (this[_handle]) {\n      this[_handle].close();\n\n      this[_handle] = null;\n      this.emit('close');\n    }\n  }\n\n  params(level, strategy) {\n    if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all\n\n    /* istanbul ignore if */\n\n    if (!this[_handle].params) throw new Error('not supported in this implementation');\n\n    if (level < constants.Z_MIN_LEVEL || level > constants.Z_MAX_LEVEL) {\n      throw new RangeError('Invalid compression level: ' + level);\n    }\n\n    if (!strategies.has(strategy)) throw new TypeError('Invalid strategy: ' + strategy);\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH);\n      assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n\n      const origFlush = this[_handle].flush;\n\n      this[_handle].flush = (flushFlag, cb) => {\n        this[_handle].flush = origFlush;\n        this.flush(flushFlag);\n        cb();\n      };\n\n      this[_handle].params(level, strategy);\n      /* istanbul ignore else */\n\n\n      if (this[_handle]) {\n        this[_level] = level;\n        this[_strategy] = strategy;\n      }\n    }\n  }\n\n  reset() {\n    assert(this[_handle], 'zlib binding closed');\n    return this[_handle].reset();\n  }\n\n  flush(kind) {\n    if (kind === undefined) kind = constants.Z_FULL_FLUSH;\n    if (this.ended) return;\n    const flushFlag = this[_flushFlag];\n    this[_flushFlag] = kind;\n    this.write(Buffer.alloc(0));\n    this[_flushFlag] = flushFlag;\n  }\n\n  end(chunk, encoding, cb) {\n    if (chunk) this.write(chunk, encoding);\n    this.flush(this[_finishFlush]);\n    this[_ended] = true;\n    return super.end(null, null, cb);\n  }\n\n  get ended() {\n    return this[_ended];\n  }\n\n  write(chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n    assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n\n    const nativeHandle = this[_handle]._handle;\n    const originalNativeClose = nativeHandle.close;\n\n    nativeHandle.close = () => {};\n\n    const originalClose = this[_handle].close;\n\n    this[_handle].close = () => {}; // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n\n\n    Buffer.concat = args => args;\n\n    let result;\n\n    try {\n      result = this[_handle]._processChunk(chunk, this[_flushFlag]);\n    } catch (err) {\n      this[_onError](err);\n    } finally {\n      Buffer.concat = OriginalBufferConcat;\n\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle;\n        nativeHandle.close = originalNativeClose;\n        this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n\n        this[_handle].removeAllListeners('error');\n      }\n    }\n\n    let writeReturn;\n\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]));\n\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i]);\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result));\n      }\n    }\n\n    if (cb) cb();\n    return writeReturn;\n  }\n\n} // minimal 2-byte header\n\n\nclass Deflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Deflate');\n  }\n\n}\n\nclass Inflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Inflate');\n  }\n\n} // gzip - bigger header, same deflate compression\n\n\nclass Gzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gzip');\n  }\n\n}\n\nclass Gunzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gunzip');\n  }\n\n} // raw - no header\n\n\nclass DeflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'DeflateRaw');\n  }\n\n}\n\nclass InflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'InflateRaw');\n  }\n\n} // auto-detect header.\n\n\nclass Unzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Unzip');\n  }\n\n}\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/chokidar/node_modules/fsevents/node_modules/minizlib/index.js"],"names":["assert","require","Buffer","realZlib","constants","exports","MiniPass","OriginalBufferConcat","concat","ZlibError","Error","constructor","msg","errno","code","codes","get","name","Map","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_VERSION_ERROR","validFlushFlags","Set","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","strategies","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","_opts","Symbol","_flushFlag","_finishFlush","_handle","_onError","_level","_strategy","_ended","Zlib","opts","mode","flush","has","TypeError","finishFlush","chunkSize","Z_MIN_CHUNK","RangeError","windowBits","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","level","Z_MIN_LEVEL","Z_MAX_LEVEL","memLevel","Z_MIN_MEMLEVEL","Z_MAX_MEMLEVEL","strategy","dictionary","err","close","error","message","emit","on","Z_DEFAULT_COMPRESSION","once","params","origFlush","flushFlag","cb","reset","kind","undefined","ended","write","alloc","end","chunk","encoding","from","nativeHandle","originalNativeClose","originalClose","args","result","_processChunk","removeAllListeners","writeReturn","Array","isArray","length","i","Deflate","Inflate","Gzip","Gunzip","DeflateRaw","InflateRaw","Unzip"],"mappings":"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","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst MiniPass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nclass ZlibError extends Error {\n  constructor (msg, errno) {\n    super('zlib: ' + msg)\n    this.errno = errno\n    this.code = codes.get(errno)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// translation table for return codes.\nconst codes = new Map([\n  [constants.Z_OK, 'Z_OK'],\n  [constants.Z_STREAM_END, 'Z_STREAM_END'],\n  [constants.Z_NEED_DICT, 'Z_NEED_DICT'],\n  [constants.Z_ERRNO, 'Z_ERRNO'],\n  [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'],\n  [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'],\n  [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'],\n  [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'],\n  [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']\n])\n\nconst validFlushFlags = new Set([\n  constants.Z_NO_FLUSH,\n  constants.Z_PARTIAL_FLUSH,\n  constants.Z_SYNC_FLUSH,\n  constants.Z_FULL_FLUSH,\n  constants.Z_FINISH,\n  constants.Z_BLOCK\n])\n\nconst strategies = new Set([\n  constants.Z_FILTERED,\n  constants.Z_HUFFMAN_ONLY,\n  constants.Z_RLE,\n  constants.Z_FIXED,\n  constants.Z_DEFAULT_STRATEGY\n])\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlush = Symbol('finishFlush')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\n\nclass Zlib extends MiniPass {\n  constructor (opts, mode) {\n    super(opts)\n    this[_ended] = false\n    this[_opts] = opts = opts || {}\n    if (opts.flush && !validFlushFlags.has(opts.flush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.flush)\n    }\n    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.finishFlush)\n    }\n\n    this[_flushFlag] = opts.flush || constants.Z_NO_FLUSH\n    this[_finishFlush] = typeof opts.finishFlush !== 'undefined' ?\n      opts.finishFlush : constants.Z_FINISH\n\n    if (opts.chunkSize) {\n      if (opts.chunkSize < constants.Z_MIN_CHUNK) {\n        throw new RangeError('Invalid chunk size: ' + opts.chunkSize)\n      }\n    }\n\n    if (opts.windowBits) {\n      if (opts.windowBits < constants.Z_MIN_WINDOWBITS ||\n          opts.windowBits > constants.Z_MAX_WINDOWBITS) {\n        throw new RangeError('Invalid windowBits: ' + opts.windowBits)\n      }\n    }\n\n    if (opts.level) {\n      if (opts.level < constants.Z_MIN_LEVEL ||\n          opts.level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + opts.level)\n      }\n    }\n\n    if (opts.memLevel) {\n      if (opts.memLevel < constants.Z_MIN_MEMLEVEL ||\n          opts.memLevel > constants.Z_MAX_MEMLEVEL) {\n        throw new RangeError('Invalid memLevel: ' + opts.memLevel)\n      }\n    }\n\n    if (opts.strategy && !(strategies.has(opts.strategy)))\n      throw new TypeError('Invalid strategy: ' + opts.strategy)\n\n    if (opts.dictionary) {\n      if (!(opts.dictionary instanceof Buffer)) {\n        throw new TypeError('Invalid dictionary: it should be a Buffer instance')\n      }\n    }\n\n    this[_handle] = new realZlib[mode](opts)\n\n    this[_onError] = (err) => {\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n\n      const error = new ZlibError(err.message, err.errno)\n      this.emit('error', error)\n    }\n    this[_handle].on('error', this[_onError])\n\n    const level = typeof opts.level === 'number' ? opts.level\n                : constants.Z_DEFAULT_COMPRESSION\n\n    var strategy = typeof opts.strategy === 'number' ? opts.strategy\n                 : constants.Z_DEFAULT_STRATEGY\n\n    // API changed in node v9\n    /* istanbul ignore next */\n\n    this[_level] = level\n    this[_strategy] = strategy\n\n    this.once('end', this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  params (level, strategy) {\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (level < constants.Z_MIN_LEVEL ||\n        level > constants.Z_MAX_LEVEL) {\n      throw new RangeError('Invalid compression level: ' + level)\n    }\n\n    if (!(strategies.has(strategy)))\n      throw new TypeError('Invalid strategy: ' + strategy)\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this[_handle].flush = origFlush\n        this.flush(flushFlag)\n        cb()\n      }\n      this[_handle].params(level, strategy)\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n\n  reset () {\n    assert(this[_handle], 'zlib binding closed')\n    return this[_handle].reset()\n  }\n\n  flush (kind) {\n    if (kind === undefined)\n      kind = constants.Z_FULL_FLUSH\n\n    if (this.ended)\n      return\n\n    const flushFlag = this[_flushFlag]\n    this[_flushFlag] = kind\n    this.write(Buffer.alloc(0))\n    this[_flushFlag] = flushFlag\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlush])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      result = this[_handle]._processChunk(chunk, this[_flushFlag])\n    } catch (err) {\n      this[_onError](err)\n    } finally {\n      Buffer.concat = OriginalBufferConcat\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n      }\n    }\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i])\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n"]},"metadata":{},"sourceType":"script"}