{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst adal = require(\"adal-node\");\n\nconst msRest = require(\"@azure/ms-rest-js\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs_1 = require(\"fs\");\n\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\n\nconst applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\n\nconst applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\n\nconst deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\n\nconst userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\n\nconst authConstants_1 = require(\"./util/authConstants\");\n\nconst subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\n\nconst msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\n\nconst msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\n * @constant {Array<string>} managementPlaneTokenAudiences - Urls for management plane token\n * audience across different azure environments.\n */\n\n\nconst managementPlaneTokenAudiences = [\"https://management.core.windows.net/\", \"https://management.core.chinacloudapi.cn/\", \"https://management.core.usgovcloudapi.net/\", \"https://management.core.cloudapi.de/\", \"https://management.azure.com/\", \"https://management.core.windows.net\", \"https://management.core.chinacloudapi.cn\", \"https://management.core.usgovcloudapi.net\", \"https://management.core.cloudapi.de\", \"https://management.azure.com\"];\n\nfunction turnOnLogging() {\n  const log = adal.Logging;\n  log.setLoggingOptions({\n    level: 3,\n    log: function (level, message, error) {\n      level;\n      console.info(message);\n\n      if (error) {\n        console.error(error);\n      }\n    }\n  });\n}\n\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n  turnOnLogging();\n}\n/**\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\n *\n * @param {string} username The user name for the Organization Id account.\n * @param {string} password The password for the Organization Id account.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {string} [options.domain] The domain or tenant id containing this application. Default value \"common\".\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\n\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.clientId) {\n      options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n    }\n\n    if (!options.domain) {\n      options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    let creds;\n    let tenantList = [];\n    let subscriptionList = [];\n\n    try {\n      creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment);\n      yield creds.getToken(); // The token cache gets propulated for all the tenants as a part of building the tenantList.\n\n      tenantList = yield subscriptionUtils_1.buildTenantList(creds);\n      subscriptionList = yield _getSubscriptions(creds, tenantList, options.tokenAudience);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    return Promise.resolve({\n      credentials: creds,\n      subscriptions: subscriptionList\n    });\n  });\n}\n\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrinicpalId/clientId across all the applicable tenants.\n *\n * @param {string} clientId The active directory application client id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} secret The application secret for the service principal.\n * @param {string} domain The domain or tenant id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    let creds;\n    let subscriptionList = [];\n\n    try {\n      creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment);\n      yield creds.getToken();\n      subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    return Promise.resolve({\n      credentials: creds,\n      subscriptions: subscriptionList\n    });\n  });\n}\n\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrinicpalId/clientId across all the applicable tenants.\n *\n * @param {string} clientId The active directory application client id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} certificateStringOrFilePath A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\n * - CertificateFilePath: **Absolute** file path of the .pem file.\n * @param {string} domain The domain or tenant id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    let creds;\n    let subscriptionList = [];\n\n    try {\n      creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n      yield creds.getToken();\n      subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    return Promise.resolve({\n      credentials: creds,\n      subscriptions: subscriptionList\n    });\n  });\n}\n\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\n\nfunction validateAuthFileContent(credsObj, filePath) {\n  if (!credsObj) {\n    throw new Error(\"Please provide a credsObj to validate.\");\n  }\n\n  if (!filePath) {\n    throw new Error(\"Please provide a filePath.\");\n  }\n\n  if (!credsObj.clientId) {\n    throw new Error(`\"clientId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n    throw new Error(`Either \"clientSecret\" or \"clientCertificate\" must be present in the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.subscriptionId) {\n    throw new Error(`\"subscriptionId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.tenantId) {\n    throw new Error(`\"tenantId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.activeDirectoryEndpointUrl) {\n    throw new Error(`\"activeDirectoryEndpointUrl\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.resourceManagerEndpointUrl) {\n    throw new Error(`\"resourceManagerEndpointUrl\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.activeDirectoryGraphResourceId) {\n    throw new Error(`\"activeDirectoryGraphResourceId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.sqlManagementEndpointUrl) {\n    throw new Error(`\"sqlManagementEndpointUrl\" is missing from the auth file: ${filePath}.`);\n  }\n}\n\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n  if (!authFileUrl || authFileUrl && typeof authFileUrl.valueOf() !== \"string\") {\n    throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  if (!envUrl || envUrl && typeof envUrl.valueOf() !== \"string\") {\n    throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n  envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n  return authFileUrl.toLowerCase() === envUrl.toLowerCase();\n}\n/**\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\n * If you want to create the sp for a different cloud/environment then please execute:\n * 1. az cloud list\n * 2. az cloud set –n <name of the environment>\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\n *  **OR**\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\n * If the service principal is already created then login with service principal info:\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\n * 5. az account show --sdk-auth > auth.json\n *\n * Authenticates using the service principal information provided in the auth file. This method will set\n * the subscriptionId from the auth file to the user provided environment variable in the options\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\n *\n * @param {object} [options] - Optional parameters\n * @param {string} [options.filePath] - Absolute file path to the auth file. If not provided\n * then please set the environment variable AZURE_AUTH_LOCATION.\n * @param {string} [options.subscriptionEnvVariableName] - The subscriptionId environment variable\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\n\nfunction withAuthFileWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) options = {\n      filePath: \"\"\n    };\n    const filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n    const subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n\n    if (!filePath) {\n      const msg = `Either provide an absolute file path to the auth file or set/export the environment variable - ${authConstants_1.AuthConstants.AZURE_AUTH_LOCATION}.`;\n      return Promise.reject(new Error(msg));\n    }\n\n    let content,\n        credsObj = {};\n    const optionsForSp = {};\n\n    try {\n      content = fs_1.readFileSync(filePath, {\n        encoding: \"utf8\"\n      });\n      credsObj = JSON.parse(content);\n      validateAuthFileContent(credsObj, filePath);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    if (!credsObj.managementEndpointUrl) {\n      credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n    } // setting the subscriptionId from auth file to the environment variable\n\n\n    process.env[subscriptionEnvVariableName] = credsObj.subscriptionId; // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n\n    const envFound = {\n      name: \"\"\n    };\n    const envNames = Object.keys(ms_rest_azure_env_1.Environment);\n\n    for (let i = 0; i < envNames.length; i++) {\n      const env = envNames[i];\n      const environmentObj = ms_rest_azure_env_1.Environment[env];\n\n      if (environmentObj && environmentObj.managementEndpointUrl && foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl)) {\n        envFound.name = environmentObj.name;\n        break;\n      }\n    }\n\n    if (envFound.name) {\n      optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n    } else {\n      // create a new environment with provided info.\n      const envParams = {\n        // try to find a logical name or set the filepath as the env name.\n        name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n      };\n      const keys = Object.keys(credsObj);\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/ig) === null) {\n          if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n            envParams[key] = credsObj[key] + \"/\";\n          } else {\n            envParams[key] = credsObj[key];\n          }\n        }\n      }\n\n      if (!envParams.activeDirectoryResourceId) {\n        envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n      }\n\n      if (!envParams.portalUrl) {\n        envParams.portalUrl = \"https://portal.azure.com\";\n      }\n\n      optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n    }\n\n    if (credsObj.clientSecret) {\n      return withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp);\n    }\n\n    return withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp);\n  });\n}\n\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a\n * DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n *\n * @param {object} [options] Object representing optional parameters.\n *\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n *\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferrably in a guid format).\n *\n * @param {string} [options.domain] The domain or tenant id containing this application. Default value is \"common\".\n *\n * @param {Environment} [options.environment] The azure environment to authenticate with. Default environment is \"Public Azure\".\n *\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @param {object} [options.language] The language code specifying how the message should be localized to. Default value \"en-us\".\n *\n * @param {object|function} [options.userCodeResponseLogger] A logger that logs the user code response message required for interactive login. When\n * this option is specified the usercode response message will not be logged to console.\n *\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withInteractiveWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    if (!options.domain) {\n      options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n    }\n\n    if (!options.clientId) {\n      options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n    }\n\n    if (!options.tokenCache) {\n      options.tokenCache = new adal.MemoryCache();\n    }\n\n    if (!options.language) {\n      options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n    }\n\n    if (!options.tokenAudience) {\n      options.tokenAudience = options.environment.activeDirectoryResourceId;\n    }\n\n    const interactiveOptions = {};\n    interactiveOptions.tokenAudience = options.tokenAudience;\n    interactiveOptions.environment = options.environment;\n    interactiveOptions.domain = options.domain;\n    interactiveOptions.clientId = options.clientId;\n    interactiveOptions.tokenCache = options.tokenCache;\n    interactiveOptions.language = options.language;\n    interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n    const authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n    const authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n    interactiveOptions.context = authContext;\n    let userCodeResponse;\n    let creds;\n\n    function tryAcquireToken(interactiveOptions, resolve, reject) {\n      authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, (err, userCodeRes) => {\n        if (err) {\n          if (err.error === \"authorization_pending\") {\n            setTimeout(() => {\n              tryAcquireToken(interactiveOptions, resolve, reject);\n            }, 1000);\n          } else {\n            return reject(err);\n          }\n        }\n\n        userCodeResponse = userCodeRes;\n\n        if (interactiveOptions.userCodeResponseLogger) {\n          interactiveOptions.userCodeResponseLogger(userCodeResponse.message);\n        } else {\n          console.log(userCodeResponse.message);\n        }\n\n        return resolve(userCodeResponse);\n      });\n    }\n\n    const getUserCode = new Promise((resolve, reject) => {\n      return tryAcquireToken(interactiveOptions, resolve, reject);\n    });\n    return getUserCode.then(() => {\n      return new Promise((resolve, reject) => {\n        return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, (error, tokenResponse) => {\n          if (error) {\n            return reject(error);\n          }\n\n          interactiveOptions.userName = tokenResponse.userId;\n          interactiveOptions.authorizationScheme = tokenResponse.tokenType;\n\n          try {\n            creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n          } catch (err) {\n            return reject(err);\n          }\n\n          return resolve(creds);\n        });\n      });\n    }).then(creds => {\n      return subscriptionUtils_1.buildTenantList(creds);\n    }).then(tenants => {\n      return _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n    }).then(subscriptions => {\n      return Promise.resolve({\n        credentials: creds,\n        subscriptions: subscriptions\n      });\n    });\n  });\n}\n\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\n\nfunction withAuthFile(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withAuthFileWithAuthResponse(options).then(authRes => {\n      return Promise.resolve(authRes.credentials);\n    }).catch(err => {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withAuthFileWithAuthResponse(options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withAuthFile = withAuthFile;\n\nfunction interactive(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withInteractiveWithAuthResponse(options).then(authRes => {\n      return Promise.resolve(authRes.credentials);\n    }).catch(err => {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withInteractiveWithAuthResponse(options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.interactive = interactive;\n\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then(authRes => {\n      return Promise.resolve(authRes.credentials);\n    }).catch(err => {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\n\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then(authRes => {\n      return Promise.resolve(authRes.credentials);\n    }).catch(err => {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\n\nfunction withUsernamePassword(username, password, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withUsernamePasswordWithAuthResponse(username, password, options).then(authRes => {\n      return Promise.resolve(authRes.credentials);\n    }).catch(err => {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withUsernamePassword = withUsernamePassword;\n/**\n * We only need to get the subscription list if the tokenAudience is for a management client.\n */\n\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n  if (tokenAudience && !managementPlaneTokenAudiences.some(item => {\n    return item === tokenAudience.toLowerCase();\n  })) {\n    return Promise.resolve([]);\n  }\n\n  return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\n *\n * @param {string} domain - required. The tenant id.\n * @param {object} options - Optional parameters\n * @param {string} [options.port] - port on which the MSI service is running on the host VM. Default port is 50342\n * @param {string} [options.resource] - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\n * @param {string} [options.aadEndpoint] - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\n * @param {any} callback - the callback function.\n */\n\n\nfunction _withMSI(options) {\n  if (!options) {\n    options = {};\n  }\n\n  return new Promise((resolve, reject) => {\n    const creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n    creds.getToken().then(_tokenResponse => {\n      // We ignore the token response, it's put in the cache.\n      return resolve(creds);\n    }).catch(error => {\n      reject(error);\n    });\n  });\n}\n\nfunction loginWithVmMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return _withMSI(options);\n  } else {\n    msRest.promiseToCallback(_withMSI(options))((err, tokenRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\n * Private method\n */\n\nfunction _withAppServiceMSI(options) {\n  if (!options) {\n    options = {};\n  }\n\n  return new Promise((resolve, reject) => {\n    const creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n    creds.getToken().then(_tokenResponse => {\n      // We ignore the token response, it's put in the cache.\n      return resolve(creds);\n    }).catch(error => {\n      reject(error);\n    });\n  });\n}\n\nfunction loginWithAppServiceMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return _withAppServiceMSI(options);\n  } else {\n    msRest.promiseToCallback(_withAppServiceMSI(options))((err, tokenRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\n * not return anything or a `JSON object` if the command did return something.\n * @param cmd The az cli command to execute.\n */\n\nfunction execAz(cmd) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      child_process_1.exec(`az ${cmd} --out json`, {\n        encoding: \"utf8\"\n      }, (error, stdout) => {\n        if (error) {\n          return reject(error);\n        }\n\n        if (stdout) {\n          try {\n            return resolve(JSON.parse(stdout));\n          } catch (err) {\n            const msg = `An error occured while parsing the output \"${stdout}\", of ` + `the cmd \"${cmd}\": ${err.stack}.`;\n            return reject(new Error(msg));\n          }\n        }\n\n        return resolve();\n      });\n    });\n  });\n}\n\nexports.execAz = execAz;","map":{"version":3,"sources":["../../lib/login.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst adal = require(\"adal-node\");\nconst msRest = require(\"@azure/ms-rest-js\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\nconst applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\nconst applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\nconst deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\nconst userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\nconst authConstants_1 = require(\"./util/authConstants\");\nconst subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\nconst msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\nconst msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\n * @constant {Array<string>} managementPlaneTokenAudiences - Urls for management plane token\n * audience across different azure environments.\n */\nconst managementPlaneTokenAudiences = [\n    \"https://management.core.windows.net/\",\n    \"https://management.core.chinacloudapi.cn/\",\n    \"https://management.core.usgovcloudapi.net/\",\n    \"https://management.core.cloudapi.de/\",\n    \"https://management.azure.com/\",\n    \"https://management.core.windows.net\",\n    \"https://management.core.chinacloudapi.cn\",\n    \"https://management.core.usgovcloudapi.net\",\n    \"https://management.core.cloudapi.de\",\n    \"https://management.azure.com\"\n];\nfunction turnOnLogging() {\n    const log = adal.Logging;\n    log.setLoggingOptions({\n        level: 3,\n        log: function (level, message, error) {\n            level;\n            console.info(message);\n            if (error) {\n                console.error(error);\n            }\n        }\n    });\n}\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n    turnOnLogging();\n}\n/**\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\n *\n * @param {string} username The user name for the Organization Id account.\n * @param {string} password The password for the Organization Id account.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {string} [options.domain] The domain or tenant id containing this application. Default value \"common\".\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.clientId) {\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n        }\n        if (!options.domain) {\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        let creds;\n        let tenantList = [];\n        let subscriptionList = [];\n        try {\n            creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment);\n            yield creds.getToken();\n            // The token cache gets propulated for all the tenants as a part of building the tenantList.\n            tenantList = yield subscriptionUtils_1.buildTenantList(creds);\n            subscriptionList = yield _getSubscriptions(creds, tenantList, options.tokenAudience);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        return Promise.resolve({ credentials: creds, subscriptions: subscriptionList });\n    });\n}\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrinicpalId/clientId across all the applicable tenants.\n *\n * @param {string} clientId The active directory application client id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} secret The application secret for the service principal.\n * @param {string} domain The domain or tenant id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        let creds;\n        let subscriptionList = [];\n        try {\n            creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment);\n            yield creds.getToken();\n            subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        return Promise.resolve({ credentials: creds, subscriptions: subscriptionList });\n    });\n}\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrinicpalId/clientId across all the applicable tenants.\n *\n * @param {string} clientId The active directory application client id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} certificateStringOrFilePath A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\n * - CertificateFilePath: **Absolute** file path of the .pem file.\n * @param {string} domain The domain or tenant id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        let creds;\n        let subscriptionList = [];\n        try {\n            creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n            yield creds.getToken();\n            subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        return Promise.resolve({ credentials: creds, subscriptions: subscriptionList });\n    });\n}\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\nfunction validateAuthFileContent(credsObj, filePath) {\n    if (!credsObj) {\n        throw new Error(\"Please provide a credsObj to validate.\");\n    }\n    if (!filePath) {\n        throw new Error(\"Please provide a filePath.\");\n    }\n    if (!credsObj.clientId) {\n        throw new Error(`\"clientId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n        throw new Error(`Either \"clientSecret\" or \"clientCertificate\" must be present in the auth file: ${filePath}.`);\n    }\n    if (!credsObj.subscriptionId) {\n        throw new Error(`\"subscriptionId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.tenantId) {\n        throw new Error(`\"tenantId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.activeDirectoryEndpointUrl) {\n        throw new Error(`\"activeDirectoryEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.resourceManagerEndpointUrl) {\n        throw new Error(`\"resourceManagerEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.activeDirectoryGraphResourceId) {\n        throw new Error(`\"activeDirectoryGraphResourceId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.sqlManagementEndpointUrl) {\n        throw new Error(`\"sqlManagementEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n}\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n    if (!authFileUrl || (authFileUrl && typeof authFileUrl.valueOf() !== \"string\")) {\n        throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n    }\n    if (!envUrl || (envUrl && typeof envUrl.valueOf() !== \"string\")) {\n        throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n    }\n    authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n    envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n    return (authFileUrl.toLowerCase() === envUrl.toLowerCase());\n}\n/**\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\n * If you want to create the sp for a different cloud/environment then please execute:\n * 1. az cloud list\n * 2. az cloud set –n <name of the environment>\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\n *  **OR**\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\n * If the service principal is already created then login with service principal info:\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\n * 5. az account show --sdk-auth > auth.json\n *\n * Authenticates using the service principal information provided in the auth file. This method will set\n * the subscriptionId from the auth file to the user provided environment variable in the options\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\n *\n * @param {object} [options] - Optional parameters\n * @param {string} [options.filePath] - Absolute file path to the auth file. If not provided\n * then please set the environment variable AZURE_AUTH_LOCATION.\n * @param {string} [options.subscriptionEnvVariableName] - The subscriptionId environment variable\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withAuthFileWithAuthResponse(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options)\n            options = { filePath: \"\" };\n        const filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n        const subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n        if (!filePath) {\n            const msg = `Either provide an absolute file path to the auth file or set/export the environment variable - ${authConstants_1.AuthConstants.AZURE_AUTH_LOCATION}.`;\n            return Promise.reject(new Error(msg));\n        }\n        let content, credsObj = {};\n        const optionsForSp = {};\n        try {\n            content = fs_1.readFileSync(filePath, { encoding: \"utf8\" });\n            credsObj = JSON.parse(content);\n            validateAuthFileContent(credsObj, filePath);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        if (!credsObj.managementEndpointUrl) {\n            credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n        }\n        // setting the subscriptionId from auth file to the environment variable\n        process.env[subscriptionEnvVariableName] = credsObj.subscriptionId;\n        // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n        const envFound = {\n            name: \"\"\n        };\n        const envNames = Object.keys(ms_rest_azure_env_1.Environment);\n        for (let i = 0; i < envNames.length; i++) {\n            const env = envNames[i];\n            const environmentObj = ms_rest_azure_env_1.Environment[env];\n            if (environmentObj &&\n                environmentObj.managementEndpointUrl &&\n                foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl)) {\n                envFound.name = environmentObj.name;\n                break;\n            }\n        }\n        if (envFound.name) {\n            optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n        }\n        else {\n            // create a new environment with provided info.\n            const envParams = {\n                // try to find a logical name or set the filepath as the env name.\n                name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n            };\n            const keys = Object.keys(credsObj);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/ig) === null) {\n                    if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n                        envParams[key] = credsObj[key] + \"/\";\n                    }\n                    else {\n                        envParams[key] = credsObj[key];\n                    }\n                }\n            }\n            if (!envParams.activeDirectoryResourceId) {\n                envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n            }\n            if (!envParams.portalUrl) {\n                envParams.portalUrl = \"https://portal.azure.com\";\n            }\n            optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n        }\n        if (credsObj.clientSecret) {\n            return withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp);\n        }\n        return withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp);\n    });\n}\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a\n * DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n *\n * @param {object} [options] Object representing optional parameters.\n *\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n *\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferrably in a guid format).\n *\n * @param {string} [options.domain] The domain or tenant id containing this application. Default value is \"common\".\n *\n * @param {Environment} [options.environment] The azure environment to authenticate with. Default environment is \"Public Azure\".\n *\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @param {object} [options.language] The language code specifying how the message should be localized to. Default value \"en-us\".\n *\n * @param {object|function} [options.userCodeResponseLogger] A logger that logs the user code response message required for interactive login. When\n * this option is specified the usercode response message will not be logged to console.\n *\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withInteractiveWithAuthResponse(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        if (!options.domain) {\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n        }\n        if (!options.clientId) {\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n        }\n        if (!options.tokenCache) {\n            options.tokenCache = new adal.MemoryCache();\n        }\n        if (!options.language) {\n            options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n        }\n        if (!options.tokenAudience) {\n            options.tokenAudience = options.environment.activeDirectoryResourceId;\n        }\n        const interactiveOptions = {};\n        interactiveOptions.tokenAudience = options.tokenAudience;\n        interactiveOptions.environment = options.environment;\n        interactiveOptions.domain = options.domain;\n        interactiveOptions.clientId = options.clientId;\n        interactiveOptions.tokenCache = options.tokenCache;\n        interactiveOptions.language = options.language;\n        interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n        const authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n        const authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n        interactiveOptions.context = authContext;\n        let userCodeResponse;\n        let creds;\n        function tryAcquireToken(interactiveOptions, resolve, reject) {\n            authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, (err, userCodeRes) => {\n                if (err) {\n                    if (err.error === \"authorization_pending\") {\n                        setTimeout(() => {\n                            tryAcquireToken(interactiveOptions, resolve, reject);\n                        }, 1000);\n                    }\n                    else {\n                        return reject(err);\n                    }\n                }\n                userCodeResponse = userCodeRes;\n                if (interactiveOptions.userCodeResponseLogger) {\n                    interactiveOptions.userCodeResponseLogger(userCodeResponse.message);\n                }\n                else {\n                    console.log(userCodeResponse.message);\n                }\n                return resolve(userCodeResponse);\n            });\n        }\n        const getUserCode = new Promise((resolve, reject) => {\n            return tryAcquireToken(interactiveOptions, resolve, reject);\n        });\n        return getUserCode.then(() => {\n            return new Promise((resolve, reject) => {\n                return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, (error, tokenResponse) => {\n                    if (error) {\n                        return reject(error);\n                    }\n                    interactiveOptions.userName = tokenResponse.userId;\n                    interactiveOptions.authorizationScheme = tokenResponse.tokenType;\n                    try {\n                        creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n                    }\n                    catch (err) {\n                        return reject(err);\n                    }\n                    return resolve(creds);\n                });\n            });\n        }).then((creds) => {\n            return subscriptionUtils_1.buildTenantList(creds);\n        }).then((tenants) => {\n            return _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n        }).then((subscriptions) => {\n            return Promise.resolve({ credentials: creds, subscriptions: subscriptions });\n        });\n    });\n}\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\nfunction withAuthFile(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withAuthFileWithAuthResponse(options).then((authRes) => {\n            return Promise.resolve(authRes.credentials);\n        }).catch((err) => {\n            return Promise.reject(err);\n        });\n    }\n    else {\n        msRest.promiseToCallback(withAuthFileWithAuthResponse(options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withAuthFile = withAuthFile;\nfunction interactive(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withInteractiveWithAuthResponse(options).then((authRes) => {\n            return Promise.resolve(authRes.credentials);\n        }).catch((err) => {\n            return Promise.reject(err);\n        });\n    }\n    else {\n        msRest.promiseToCallback(withInteractiveWithAuthResponse(options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.interactive = interactive;\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then((authRes) => {\n            return Promise.resolve(authRes.credentials);\n        }).catch((err) => {\n            return Promise.reject(err);\n        });\n    }\n    else {\n        msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then((authRes) => {\n            return Promise.resolve(authRes.credentials);\n        }).catch((err) => {\n            return Promise.reject(err);\n        });\n    }\n    else {\n        msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\nfunction withUsernamePassword(username, password, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withUsernamePasswordWithAuthResponse(username, password, options).then((authRes) => {\n            return Promise.resolve(authRes.credentials);\n        }).catch((err) => {\n            return Promise.reject(err);\n        });\n    }\n    else {\n        msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withUsernamePassword = withUsernamePassword;\n/**\n * We only need to get the subscription list if the tokenAudience is for a management client.\n */\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n    if (tokenAudience &&\n        !managementPlaneTokenAudiences.some((item) => { return item === tokenAudience.toLowerCase(); })) {\n        return Promise.resolve(([]));\n    }\n    return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\n *\n * @param {string} domain - required. The tenant id.\n * @param {object} options - Optional parameters\n * @param {string} [options.port] - port on which the MSI service is running on the host VM. Default port is 50342\n * @param {string} [options.resource] - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\n * @param {string} [options.aadEndpoint] - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\n * @param {any} callback - the callback function.\n */\nfunction _withMSI(options) {\n    if (!options) {\n        options = {};\n    }\n    return new Promise((resolve, reject) => {\n        const creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n        creds.getToken().then((_tokenResponse) => {\n            // We ignore the token response, it's put in the cache.\n            return resolve(creds);\n        }).catch(error => {\n            reject(error);\n        });\n    });\n}\nfunction loginWithVmMSI(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    const cb = callback;\n    if (!callback) {\n        return _withMSI(options);\n    }\n    else {\n        msRest.promiseToCallback(_withMSI(options))((err, tokenRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, tokenRes);\n        });\n    }\n}\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\n * Private method\n */\nfunction _withAppServiceMSI(options) {\n    if (!options) {\n        options = {};\n    }\n    return new Promise((resolve, reject) => {\n        const creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n        creds.getToken().then((_tokenResponse) => {\n            // We ignore the token response, it's put in the cache.\n            return resolve(creds);\n        }).catch(error => {\n            reject(error);\n        });\n    });\n}\nfunction loginWithAppServiceMSI(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    const cb = callback;\n    if (!callback) {\n        return _withAppServiceMSI(options);\n    }\n    else {\n        msRest.promiseToCallback(_withAppServiceMSI(options))((err, tokenRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, tokenRes);\n        });\n    }\n}\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\n * not return anything or a `JSON object` if the command did return something.\n * @param cmd The az cli command to execute.\n */\nfunction execAz(cmd) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            child_process_1.exec(`az ${cmd} --out json`, { encoding: \"utf8\" }, (error, stdout) => {\n                if (error) {\n                    return reject(error);\n                }\n                if (stdout) {\n                    try {\n                        return resolve(JSON.parse(stdout));\n                    }\n                    catch (err) {\n                        const msg = `An error occured while parsing the output \"${stdout}\", of ` +\n                            `the cmd \"${cmd}\": ${err.stack}.`;\n                        return reject(new Error(msg));\n                    }\n                }\n                return resolve();\n            });\n        });\n    });\n}\nexports.execAz = execAz;\n//# sourceMappingURL=login.js.map"]},"metadata":{},"sourceType":"script"}