{"ast":null,"code":"'use strict'; // http://dev.mysql.com/doc/internals/en/query-event.html\n\nconst keys = {\n  FLAGS2: 0,\n  SQL_MODE: 1,\n  CATALOG: 2,\n  AUTO_INCREMENT: 3,\n  CHARSET: 4,\n  TIME_ZONE: 5,\n  CATALOG_NZ: 6,\n  LC_TIME_NAMES: 7,\n  CHARSET_DATABASE: 8,\n  TABLE_MAP_FOR_UPDATE: 9,\n  MASTER_DATA_WRITTEN: 10,\n  INVOKERS: 11,\n  UPDATED_DB_NAMES: 12,\n  MICROSECONDS: 3\n};\n\nmodule.exports = function parseStatusVars(buffer) {\n  const result = {};\n  let offset = 0;\n  let key, length, prevOffset;\n\n  while (offset < buffer.length) {\n    key = buffer[offset++];\n\n    switch (key) {\n      case keys.FLAGS2:\n        result.flags = buffer.readUInt32LE(offset);\n        offset += 4;\n        break;\n\n      case keys.SQL_MODE:\n        // value is 8 bytes, but all dcumented flags are in first 4 bytes\n        result.sqlMode = buffer.readUInt32LE(offset);\n        offset += 8;\n        break;\n\n      case keys.CATALOG:\n        length = buffer[offset++];\n        result.catalog = buffer.toString('utf8', offset, offset + length);\n        offset += length + 1; // null byte after string\n\n        break;\n\n      case keys.CHARSET:\n        result.clientCharset = buffer.readUInt16LE(offset);\n        result.connectionCollation = buffer.readUInt16LE(offset + 2);\n        result.serverCharset = buffer.readUInt16LE(offset + 4);\n        offset += 6;\n        break;\n\n      case keys.TIME_ZONE:\n        length = buffer[offset++];\n        result.timeZone = buffer.toString('utf8', offset, offset + length);\n        offset += length; // no null byte\n\n        break;\n\n      case keys.CATALOG_NZ:\n        length = buffer[offset++];\n        result.catalogNz = buffer.toString('utf8', offset, offset + length);\n        offset += length; // no null byte\n\n        break;\n\n      case keys.LC_TIME_NAMES:\n        result.lcTimeNames = buffer.readUInt16LE(offset);\n        offset += 2;\n        break;\n\n      case keys.CHARSET_DATABASE:\n        result.schemaCharset = buffer.readUInt16LE(offset);\n        offset += 2;\n        break;\n\n      case keys.TABLE_MAP_FOR_UPDATE:\n        result.mapForUpdate1 = buffer.readUInt32LE(offset);\n        result.mapForUpdate2 = buffer.readUInt32LE(offset + 4);\n        offset += 8;\n        break;\n\n      case keys.MASTER_DATA_WRITTEN:\n        result.masterDataWritten = buffer.readUInt32LE(offset);\n        offset += 4;\n        break;\n\n      case keys.INVOKERS:\n        length = buffer[offset++];\n        result.invokerUsername = buffer.toString('utf8', offset, offset + length);\n        offset += length;\n        length = buffer[offset++];\n        result.invokerHostname = buffer.toString('utf8', offset, offset + length);\n        offset += length;\n        break;\n\n      case keys.UPDATED_DB_NAMES:\n        length = buffer[offset++]; // length - number of null-terminated strings\n\n        result.updatedDBs = []; // we'll store them as array here\n\n        for (; length; --length) {\n          prevOffset = offset; // fast forward to null terminating byte\n\n          while (buffer[offset++] && offset < buffer.length) {// empty body, everything inside while condition\n          }\n\n          result.updatedDBs.push(buffer.toString('utf8', prevOffset, offset - 1));\n        }\n\n        break;\n\n      case keys.MICROSECONDS:\n        result.microseconds = // REVIEW: INVALID UNKNOWN VARIABLE!\n        buffer.readInt16LE(offset) + (buffer[offset + 2] << 16);\n        offset += 3;\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/mysql2/lib/packets/binlog_query_statusvars.js"],"names":["keys","FLAGS2","SQL_MODE","CATALOG","AUTO_INCREMENT","CHARSET","TIME_ZONE","CATALOG_NZ","LC_TIME_NAMES","CHARSET_DATABASE","TABLE_MAP_FOR_UPDATE","MASTER_DATA_WRITTEN","INVOKERS","UPDATED_DB_NAMES","MICROSECONDS","module","exports","parseStatusVars","buffer","result","offset","key","length","prevOffset","flags","readUInt32LE","sqlMode","catalog","toString","clientCharset","readUInt16LE","connectionCollation","serverCharset","timeZone","catalogNz","lcTimeNames","schemaCharset","mapForUpdate1","mapForUpdate2","masterDataWritten","invokerUsername","invokerHostname","updatedDBs","push","microseconds","readInt16LE"],"mappings":"AAAA,a,CAEA;;AAEA,MAAMA,IAAI,GAAG;AACXC,EAAAA,MAAM,EAAE,CADG;AAEXC,EAAAA,QAAQ,EAAE,CAFC;AAGXC,EAAAA,OAAO,EAAE,CAHE;AAIXC,EAAAA,cAAc,EAAE,CAJL;AAKXC,EAAAA,OAAO,EAAE,CALE;AAMXC,EAAAA,SAAS,EAAE,CANA;AAOXC,EAAAA,UAAU,EAAE,CAPD;AAQXC,EAAAA,aAAa,EAAE,CARJ;AASXC,EAAAA,gBAAgB,EAAE,CATP;AAUXC,EAAAA,oBAAoB,EAAE,CAVX;AAWXC,EAAAA,mBAAmB,EAAE,EAXV;AAYXC,EAAAA,QAAQ,EAAE,EAZC;AAaXC,EAAAA,gBAAgB,EAAE,EAbP;AAcXC,EAAAA,YAAY,EAAE;AAdH,CAAb;;AAiBAC,MAAM,CAACC,OAAP,GAAiB,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;AAChD,QAAMC,MAAM,GAAG,EAAf;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,GAAJ,EAASC,MAAT,EAAiBC,UAAjB;;AACA,SAAOH,MAAM,GAAGF,MAAM,CAACI,MAAvB,EAA+B;AAC7BD,IAAAA,GAAG,GAAGH,MAAM,CAACE,MAAM,EAAP,CAAZ;;AACA,YAAQC,GAAR;AACE,WAAKrB,IAAI,CAACC,MAAV;AACEkB,QAAAA,MAAM,CAACK,KAAP,GAAeN,MAAM,CAACO,YAAP,CAAoBL,MAApB,CAAf;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA;;AACF,WAAKpB,IAAI,CAACE,QAAV;AACE;AACAiB,QAAAA,MAAM,CAACO,OAAP,GAAiBR,MAAM,CAACO,YAAP,CAAoBL,MAApB,CAAjB;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA;;AACF,WAAKpB,IAAI,CAACG,OAAV;AACEmB,QAAAA,MAAM,GAAGJ,MAAM,CAACE,MAAM,EAAP,CAAf;AACAD,QAAAA,MAAM,CAACQ,OAAP,GAAiBT,MAAM,CAACU,QAAP,CAAgB,MAAhB,EAAwBR,MAAxB,EAAgCA,MAAM,GAAGE,MAAzC,CAAjB;AACAF,QAAAA,MAAM,IAAIE,MAAM,GAAG,CAAnB,CAHF,CAGwB;;AACtB;;AACF,WAAKtB,IAAI,CAACK,OAAV;AACEc,QAAAA,MAAM,CAACU,aAAP,GAAuBX,MAAM,CAACY,YAAP,CAAoBV,MAApB,CAAvB;AACAD,QAAAA,MAAM,CAACY,mBAAP,GAA6Bb,MAAM,CAACY,YAAP,CAAoBV,MAAM,GAAG,CAA7B,CAA7B;AACAD,QAAAA,MAAM,CAACa,aAAP,GAAuBd,MAAM,CAACY,YAAP,CAAoBV,MAAM,GAAG,CAA7B,CAAvB;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA;;AACF,WAAKpB,IAAI,CAACM,SAAV;AACEgB,QAAAA,MAAM,GAAGJ,MAAM,CAACE,MAAM,EAAP,CAAf;AACAD,QAAAA,MAAM,CAACc,QAAP,GAAkBf,MAAM,CAACU,QAAP,CAAgB,MAAhB,EAAwBR,MAAxB,EAAgCA,MAAM,GAAGE,MAAzC,CAAlB;AACAF,QAAAA,MAAM,IAAIE,MAAV,CAHF,CAGoB;;AAClB;;AACF,WAAKtB,IAAI,CAACO,UAAV;AACEe,QAAAA,MAAM,GAAGJ,MAAM,CAACE,MAAM,EAAP,CAAf;AACAD,QAAAA,MAAM,CAACe,SAAP,GAAmBhB,MAAM,CAACU,QAAP,CAAgB,MAAhB,EAAwBR,MAAxB,EAAgCA,MAAM,GAAGE,MAAzC,CAAnB;AACAF,QAAAA,MAAM,IAAIE,MAAV,CAHF,CAGoB;;AAClB;;AACF,WAAKtB,IAAI,CAACQ,aAAV;AACEW,QAAAA,MAAM,CAACgB,WAAP,GAAqBjB,MAAM,CAACY,YAAP,CAAoBV,MAApB,CAArB;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA;;AACF,WAAKpB,IAAI,CAACS,gBAAV;AACEU,QAAAA,MAAM,CAACiB,aAAP,GAAuBlB,MAAM,CAACY,YAAP,CAAoBV,MAApB,CAAvB;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA;;AACF,WAAKpB,IAAI,CAACU,oBAAV;AACES,QAAAA,MAAM,CAACkB,aAAP,GAAuBnB,MAAM,CAACO,YAAP,CAAoBL,MAApB,CAAvB;AACAD,QAAAA,MAAM,CAACmB,aAAP,GAAuBpB,MAAM,CAACO,YAAP,CAAoBL,MAAM,GAAG,CAA7B,CAAvB;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA;;AACF,WAAKpB,IAAI,CAACW,mBAAV;AACEQ,QAAAA,MAAM,CAACoB,iBAAP,GAA2BrB,MAAM,CAACO,YAAP,CAAoBL,MAApB,CAA3B;AACAA,QAAAA,MAAM,IAAI,CAAV;AACA;;AACF,WAAKpB,IAAI,CAACY,QAAV;AACEU,QAAAA,MAAM,GAAGJ,MAAM,CAACE,MAAM,EAAP,CAAf;AACAD,QAAAA,MAAM,CAACqB,eAAP,GAAyBtB,MAAM,CAACU,QAAP,CACvB,MADuB,EAEvBR,MAFuB,EAGvBA,MAAM,GAAGE,MAHc,CAAzB;AAKAF,QAAAA,MAAM,IAAIE,MAAV;AACAA,QAAAA,MAAM,GAAGJ,MAAM,CAACE,MAAM,EAAP,CAAf;AACAD,QAAAA,MAAM,CAACsB,eAAP,GAAyBvB,MAAM,CAACU,QAAP,CACvB,MADuB,EAEvBR,MAFuB,EAGvBA,MAAM,GAAGE,MAHc,CAAzB;AAKAF,QAAAA,MAAM,IAAIE,MAAV;AACA;;AACF,WAAKtB,IAAI,CAACa,gBAAV;AACES,QAAAA,MAAM,GAAGJ,MAAM,CAACE,MAAM,EAAP,CAAf,CADF,CAEE;;AACAD,QAAAA,MAAM,CAACuB,UAAP,GAAoB,EAApB,CAHF,CAG0B;;AACxB,eAAOpB,MAAP,EAAe,EAAEA,MAAjB,EAAyB;AACvBC,UAAAA,UAAU,GAAGH,MAAb,CADuB,CAEvB;;AACA,iBAAOF,MAAM,CAACE,MAAM,EAAP,CAAN,IAAoBA,MAAM,GAAGF,MAAM,CAACI,MAA3C,EAAmD,CACjD;AACD;;AACDH,UAAAA,MAAM,CAACuB,UAAP,CAAkBC,IAAlB,CACEzB,MAAM,CAACU,QAAP,CAAgB,MAAhB,EAAwBL,UAAxB,EAAoCH,MAAM,GAAG,CAA7C,CADF;AAGD;;AACD;;AACF,WAAKpB,IAAI,CAACc,YAAV;AACEK,QAAAA,MAAM,CAACyB,YAAP,GACE;AACA1B,QAAAA,MAAM,CAAC2B,WAAP,CAAmBzB,MAAnB,KAA8BF,MAAM,CAACE,MAAM,GAAG,CAAV,CAAN,IAAsB,EAApD,CAFF;AAGAA,QAAAA,MAAM,IAAI,CAAV;AAnFJ;AAqFD;;AACD,SAAOD,MAAP;AACD,CA7FD","sourcesContent":["'use strict';\n\n// http://dev.mysql.com/doc/internals/en/query-event.html\n\nconst keys = {\n  FLAGS2: 0,\n  SQL_MODE: 1,\n  CATALOG: 2,\n  AUTO_INCREMENT: 3,\n  CHARSET: 4,\n  TIME_ZONE: 5,\n  CATALOG_NZ: 6,\n  LC_TIME_NAMES: 7,\n  CHARSET_DATABASE: 8,\n  TABLE_MAP_FOR_UPDATE: 9,\n  MASTER_DATA_WRITTEN: 10,\n  INVOKERS: 11,\n  UPDATED_DB_NAMES: 12,\n  MICROSECONDS: 3\n};\n\nmodule.exports = function parseStatusVars(buffer) {\n  const result = {};\n  let offset = 0;\n  let key, length, prevOffset;\n  while (offset < buffer.length) {\n    key = buffer[offset++];\n    switch (key) {\n      case keys.FLAGS2:\n        result.flags = buffer.readUInt32LE(offset);\n        offset += 4;\n        break;\n      case keys.SQL_MODE:\n        // value is 8 bytes, but all dcumented flags are in first 4 bytes\n        result.sqlMode = buffer.readUInt32LE(offset);\n        offset += 8;\n        break;\n      case keys.CATALOG:\n        length = buffer[offset++];\n        result.catalog = buffer.toString('utf8', offset, offset + length);\n        offset += length + 1; // null byte after string\n        break;\n      case keys.CHARSET:\n        result.clientCharset = buffer.readUInt16LE(offset);\n        result.connectionCollation = buffer.readUInt16LE(offset + 2);\n        result.serverCharset = buffer.readUInt16LE(offset + 4);\n        offset += 6;\n        break;\n      case keys.TIME_ZONE:\n        length = buffer[offset++];\n        result.timeZone = buffer.toString('utf8', offset, offset + length);\n        offset += length; // no null byte\n        break;\n      case keys.CATALOG_NZ:\n        length = buffer[offset++];\n        result.catalogNz = buffer.toString('utf8', offset, offset + length);\n        offset += length; // no null byte\n        break;\n      case keys.LC_TIME_NAMES:\n        result.lcTimeNames = buffer.readUInt16LE(offset);\n        offset += 2;\n        break;\n      case keys.CHARSET_DATABASE:\n        result.schemaCharset = buffer.readUInt16LE(offset);\n        offset += 2;\n        break;\n      case keys.TABLE_MAP_FOR_UPDATE:\n        result.mapForUpdate1 = buffer.readUInt32LE(offset);\n        result.mapForUpdate2 = buffer.readUInt32LE(offset + 4);\n        offset += 8;\n        break;\n      case keys.MASTER_DATA_WRITTEN:\n        result.masterDataWritten = buffer.readUInt32LE(offset);\n        offset += 4;\n        break;\n      case keys.INVOKERS:\n        length = buffer[offset++];\n        result.invokerUsername = buffer.toString(\n          'utf8',\n          offset,\n          offset + length\n        );\n        offset += length;\n        length = buffer[offset++];\n        result.invokerHostname = buffer.toString(\n          'utf8',\n          offset,\n          offset + length\n        );\n        offset += length;\n        break;\n      case keys.UPDATED_DB_NAMES:\n        length = buffer[offset++];\n        // length - number of null-terminated strings\n        result.updatedDBs = []; // we'll store them as array here\n        for (; length; --length) {\n          prevOffset = offset;\n          // fast forward to null terminating byte\n          while (buffer[offset++] && offset < buffer.length) {\n            // empty body, everything inside while condition\n          }\n          result.updatedDBs.push(\n            buffer.toString('utf8', prevOffset, offset - 1)\n          );\n        }\n        break;\n      case keys.MICROSECONDS:\n        result.microseconds =\n          // REVIEW: INVALID UNKNOWN VARIABLE!\n          buffer.readInt16LE(offset) + (buffer[offset + 2] << 16);\n        offset += 3;\n    }\n  }\n  return result;\n};\n"]},"metadata":{},"sourceType":"script"}