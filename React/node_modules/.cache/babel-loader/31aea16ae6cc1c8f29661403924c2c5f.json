{"ast":null,"code":"var debug = require('debug')('retry-as-promised'),\n    error = require('debug')('retry-as-promised:error'),\n    Promise = require('bluebird');\n\nmodule.exports = function retryAsPromised(callback, options) {\n  if (!callback || !options) throw new Error('retry-as-promised must be passed a callback and a options set or a number');\n\n  if (typeof options === 'number') {\n    options = {\n      max: options\n    };\n  } // Super cheap clone\n\n\n  options = {\n    $current: options.$current || 1,\n    max: options.max,\n    timeout: options.timeout || undefined,\n    match: options.match || [],\n    backoffBase: options.backoffBase === undefined ? 100 : options.backoffBase,\n    backoffExponent: options.backoffExponent || 1.1,\n    report: options.report || null,\n    name: options.name || callback.name || 'unknown'\n  }; // Massage match option into array so we can blindly treat it as such later\n\n  if (!Array.isArray(options.match)) options.match = [options.match];\n  if (options.report) options.report('Trying ' + options.name + ' #' + options.$current + ' at ' + new Date().toLocaleTimeString(), options);\n  return new Promise(function (resolve, reject) {\n    var timeout, backoffTimeout;\n\n    if (options.timeout) {\n      timeout = setTimeout(function () {\n        if (backoffTimeout) clearTimeout(backoffTimeout);\n        reject(Promise.TimeoutError(options.name + ' timed out'));\n      }, options.timeout);\n    }\n\n    Promise.resolve(callback({\n      current: options.$current\n    })).then(resolve).tap(function () {\n      if (timeout) clearTimeout(timeout);\n      if (backoffTimeout) clearTimeout(backoffTimeout);\n    }).catch(function (err) {\n      if (timeout) clearTimeout(timeout);\n      if (backoffTimeout) clearTimeout(backoffTimeout);\n      error(err && err.toString() || err);\n      if (options.report) options.report('Try ' + options.name + ' #' + options.$current + ' failed: ' + err.toString(), options, err); // Should not retry if max has been reached\n\n      var shouldRetry = options.$current < options.max;\n\n      if (shouldRetry && options.match.length && err) {\n        // If match is defined we should fail if it is not met\n        shouldRetry = options.match.reduce(function (shouldRetry, match) {\n          if (shouldRetry) return shouldRetry;\n\n          if (match === err.toString() || match === err.message || typeof match === \"function\" && err instanceof match || match instanceof RegExp && (match.test(err.message) || match.test(err.toString()))) {\n            shouldRetry = true;\n          }\n\n          return shouldRetry;\n        }, false);\n      }\n\n      if (!shouldRetry) return reject(err);\n      var retryDelay = Math.pow(options.backoffBase, Math.pow(options.backoffExponent, options.$current - 1)); // Do some accounting\n\n      options.$current++;\n      debug('Retrying ' + options.name + ' (%s)', options.$current);\n\n      if (retryDelay) {\n        // Use backoff function to ease retry rate\n        debug('Delaying retry of ' + options.name + ' by %s', retryDelay);\n        if (options.report) options.report('Delaying retry of ' + options.name + ' by ' + retryDelay, options);\n        backoffTimeout = setTimeout(function () {\n          retryAsPromised(callback, options).then(resolve).catch(reject);\n        }, retryDelay);\n      } else {\n        retryAsPromised(callback, options).then(resolve).catch(reject);\n      }\n    });\n  });\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/retry-as-promised/index.js"],"names":["debug","require","error","Promise","module","exports","retryAsPromised","callback","options","Error","max","$current","timeout","undefined","match","backoffBase","backoffExponent","report","name","Array","isArray","Date","toLocaleTimeString","resolve","reject","backoffTimeout","setTimeout","clearTimeout","TimeoutError","current","then","tap","catch","err","toString","shouldRetry","length","reduce","message","RegExp","test","retryDelay","Math","pow"],"mappings":"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","sourcesContent":["var debug = require('debug')('retry-as-promised')\n  , error = require('debug')('retry-as-promised:error')\n  , Promise = require('bluebird');\n\nmodule.exports = function retryAsPromised(callback, options) {\n  if (!callback || !options) throw new Error('retry-as-promised must be passed a callback and a options set or a number');\n\n  if (typeof options === 'number') {\n    options = {max: options};\n  }\n\n  // Super cheap clone\n  options = {\n    $current:         options.$current || 1,\n    max:              options.max,\n    timeout:          options.timeout || undefined,\n    match:            options.match || [],\n    backoffBase:      options.backoffBase === undefined ? 100 : options.backoffBase,\n    backoffExponent:  options.backoffExponent || 1.1,\n    report:           options.report || null,\n    name:             options.name || callback.name || 'unknown'\n  };\n\n  // Massage match option into array so we can blindly treat it as such later\n  if (!Array.isArray(options.match)) options.match = [options.match];\n  \n  if(options.report) options.report('Trying ' + options.name + ' #' + options.$current + ' at ' + new Date().toLocaleTimeString(), options);\n\n  return new Promise(function (resolve, reject) {\n    var timeout, backoffTimeout;\n\n    if (options.timeout) {\n      timeout = setTimeout(function () {\n        if (backoffTimeout) clearTimeout(backoffTimeout);\n        reject(Promise.TimeoutError( options.name + ' timed out'));\n      }, options.timeout);\n    }\n\n    Promise.resolve(callback({ current: options.$current })).then(resolve).tap(function () {\n      if (timeout) clearTimeout(timeout);\n      if (backoffTimeout) clearTimeout(backoffTimeout);\n    }).catch(function (err) {\n      if (timeout) clearTimeout(timeout);\n      if (backoffTimeout) clearTimeout(backoffTimeout);\n\n      error(err && err.toString() || err);\n      if (options.report) options.report('Try ' + options.name + ' #' + options.$current + ' failed: ' + err.toString(), options, err);\n\n      // Should not retry if max has been reached\n      var shouldRetry = options.$current < options.max;\n\n      if (shouldRetry && options.match.length && err) {\n        // If match is defined we should fail if it is not met\n        shouldRetry = options.match.reduce(function (shouldRetry, match) {\n          if (shouldRetry) return shouldRetry;\n\n          if (match === err.toString() ||\n              match === err.message ||\n              (typeof match === \"function\" && err instanceof match) ||\n              (match instanceof RegExp && (match.test(err.message) || match.test(err.toString()) ))\n          ) {\n            shouldRetry = true;\n          }\n          return shouldRetry;\n        }, false);\n      }\n\n      if (!shouldRetry) return reject(err);\n\n      var retryDelay = Math.pow(options.backoffBase, Math.pow(options.backoffExponent, (options.$current - 1)));\n\n      // Do some accounting\n      options.$current++;\n      debug('Retrying '+ options.name + ' (%s)', options.$current);\n      if (retryDelay) {\n        // Use backoff function to ease retry rate\n        debug('Delaying retry of ' + options.name + ' by %s', retryDelay);\n        if(options.report) options.report('Delaying retry of ' + options.name + ' by ' + retryDelay, options);\n        backoffTimeout = setTimeout(function() {\n          retryAsPromised(callback, options).then(resolve).catch(reject);\n        }, retryDelay);\n      } else {\n        retryAsPromised(callback, options).then(resolve).catch(reject);\n      }\n\n    });\n  });\n};\n"]},"metadata":{},"sourceType":"script"}