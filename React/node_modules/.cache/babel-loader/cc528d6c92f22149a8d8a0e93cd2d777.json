{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n/* istanbul ignore next */\n\n\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown';\n/* istanbul ignore next */\n\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync';\nconst needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\\./) && !process.version.match(/v10\\.[6-9]/);\n/* istanbul ignore next */\n\nconst handleEISDIR = needEISDIRHandled ? (path, uid, gid, cb) => er => {\n  // Node prior to v10 had a very questionable implementation of\n  // fs.lchown, which would always try to call fs.open on a directory\n  // Fall back to fs.chown in those cases.\n  if (!er || er.code !== 'EISDIR') cb(er);else fs.chown(path, uid, gid, cb);\n} : (_, __, ___, cb) => cb;\n/* istanbul ignore next */\n\nconst handleEISDirSync = needEISDIRHandled ? (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'EISDIR') throw er;\n    fs.chownSync(path, uid, gid);\n  }\n} : (path, uid, gid) => fs[LCHOWNSYNC](path, uid, gid); // fs.readdir could only accept an options object as of node v6\n\nconst nodeVersion = process.version;\n\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb);\n\nlet readdirSync = (path, options) => fs.readdirSync(path, options);\n/* istanbul ignore next */\n\n\nif (/^v4\\./.test(nodeVersion)) readdir = (path, options, cb) => fs.readdir(path, cb);\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string') return fs.lstat(path.resolve(p, child), (er, stats) => {\n    if (er) return cb(er);\n    stats.name = child;\n    chownrKid(p, stats, uid, gid, cb);\n  });\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er) return cb(er);\n      const cpath = path.resolve(p, child.name);\n      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb));\n    });\n  } else {\n    const cpath = path.resolve(p, child.name);\n    fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb));\n  }\n};\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, {\n    withFileTypes: true\n  }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er && er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP') return cb(er);\n    if (er || !children.length) return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb));\n    let len = children.length;\n    let errState = null;\n\n    const then = er => {\n      if (errState) return;\n      if (er) return cb(errState = er);\n      if (--len === 0) return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb));\n    };\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then));\n  });\n};\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    const stats = fs.lstatSync(path.resolve(p, child));\n    stats.name = child;\n    child = stats;\n  }\n\n  if (child.isDirectory()) chownrSync(path.resolve(p, child.name), uid, gid);\n  handleEISDirSync(path.resolve(p, child.name), uid, gid);\n};\n\nconst chownrSync = (p, uid, gid) => {\n  let children;\n\n  try {\n    children = readdirSync(p, {\n      withFileTypes: true\n    });\n  } catch (er) {\n    if (er && er.code === 'ENOTDIR' && er.code !== 'ENOTSUP') return handleEISDirSync(p, uid, gid);\n    throw er;\n  }\n\n  if (children.length) children.forEach(child => chownrKidSync(p, child, uid, gid));\n  return handleEISDirSync(p, uid, gid);\n};\n\nmodule.exports = chownr;\nchownr.sync = chownrSync;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/chownr/chownr.js"],"names":["fs","require","path","LCHOWN","lchown","LCHOWNSYNC","lchownSync","needEISDIRHandled","process","version","match","handleEISDIR","uid","gid","cb","er","code","chown","_","__","___","handleEISDirSync","chownSync","nodeVersion","readdir","options","readdirSync","test","chownrKid","p","child","lstat","resolve","stats","name","isDirectory","chownr","cpath","withFileTypes","children","length","len","errState","then","forEach","chownrKidSync","lstatSync","chownrSync","module","exports","sync"],"mappings":"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","sourcesContent":["'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return fs[LCHOWNSYNC](path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      fs.chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => fs[LCHOWNSYNC](path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      if (er)\n        return cb(er)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb))\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, cb))\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er && er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n      return cb(er)\n    if (er || !children.length)\n      return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb))\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return fs[LCHOWN](p, uid, gid, handleEISDIR(p, uid, gid, cb))\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    const stats = fs.lstatSync(path.resolve(p, child))\n    stats.name = child\n    child = stats\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er && er.code === 'ENOTDIR' && er.code !== 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    throw er\n  }\n\n  if (children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n"]},"metadata":{},"sourceType":"script"}