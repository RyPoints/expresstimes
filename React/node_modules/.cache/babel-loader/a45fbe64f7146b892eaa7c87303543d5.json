{"ast":null,"code":"'use strict';\n\nconst EE = require('events');\n\nconst Yallist = require('yallist');\n\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst doIter = process.env._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');\nconst FLUSHCHUNK = Symbol('flushChunk');\n\nconst SD = require('string_decoder').StringDecoder;\n\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst RESUME = Symbol('resume');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode'); // Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\n\nlet B = Buffer;\n/* istanbul ignore next */\n\nif (!B.alloc) {\n  B = require('safe-buffer').Buffer;\n}\n\nmodule.exports = class MiniPass extends EE {\n  constructor(options) {\n    super();\n    this[FLOWING] = false;\n    this.pipes = new Yallist();\n    this.buffer = new Yallist();\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[CLOSED] = false;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n\n  get encoding() {\n    return this[ENCODING];\n  }\n\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this.buffer.length) this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk));\n    }\n\n    this[ENCODING] = enc;\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end');\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8'; // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n\n    if (typeof chunk === 'string' && !this[OBJECTMODE] && // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding);\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n    try {\n      return this.flowing ? (this.emit('data', chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);\n    } finally {\n      this.emit('readable');\n      if (cb) cb();\n    }\n  }\n\n  read(n) {\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;\n      if (this[OBJECTMODE]) n = null;\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([B.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);\n      }\n\n      return this[READ](n || null, this.buffer.head.value);\n    } finally {\n      this[MAYBE_EMIT_END]();\n    }\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this.buffer.head.value = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false;\n    if (this.flowing) this[MAYBE_EMIT_END]();\n  } // don't let the internal resume be overwritten\n\n\n  [RESUME]() {\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n\n  resume() {\n    return this[RESUME]();\n  }\n\n  pause() {\n    this[FLOWING] = false;\n  }\n\n  get flowing() {\n    return this[FLOWING];\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    return this.buffer.push(chunk);\n  }\n\n  [BUFFERSHIFT]() {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;\n    }\n\n    return this.buffer.shift();\n  }\n\n  [FLUSH]() {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n  }\n\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false;\n  }\n\n  pipe(dest, opts) {\n    if (dest === process.stdout || dest === process.stderr) (opts = opts || {}).end = false;\n    const p = {\n      dest: dest,\n      opts: opts,\n      ondrain: _ => this[RESUME]()\n    };\n    this.pipes.push(p);\n    dest.on('drain', p.ondrain);\n    this[RESUME]();\n    return dest;\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    try {\n      return super.on(ev, fn);\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (ev === 'end' && this[EMITTED_END]) {\n        super.emit('end');\n        this.removeAllListeners('end');\n      }\n    }\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTED_END] && this.buffer.length === 0 && this[EOF]) {\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n    }\n  }\n\n  emit(ev, data) {\n    if (ev === 'data') {\n      if (!data) return;\n      if (this.pipes.length) this.pipes.forEach(p => p.dest.write(data) || this.pause());\n    } else if (ev === 'end') {\n      if (this[EMITTED_END] === true) return;\n      this[EMITTED_END] = true;\n      this.readable = false;\n\n      if (this[DECODER]) {\n        data = this[DECODER].end();\n\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data));\n          super.emit('data', data);\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain);\n        if (!p.opts || p.opts.end !== false) p.dest.end();\n      });\n    } else if (ev === 'close') {\n      this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n      if (!this[EMITTED_END]) return;\n    }\n\n    const args = new Array(arguments.length);\n    args[0] = ev;\n    args[1] = data;\n\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args);\n    } finally {\n      if (ev !== 'end') this[MAYBE_EMIT_END]();else this.removeAllListeners('end');\n    }\n  } // const all = await stream.collect()\n\n\n  collect() {\n    return new Promise((resolve, reject) => {\n      const buf = [];\n      this.on('data', c => buf.push(c));\n      this.on('end', () => resolve(buf));\n      this.on('error', reject);\n    });\n  } // for await (let chunk of stream)\n\n\n  [ASYNCITERATOR]() {\n    const next = () => {\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return Promise.resolve({\n        done: true\n      });\n      let resolve = null;\n      let reject = null;\n\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        reject(er);\n      };\n\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        resolve({\n          done: true\n        });\n      };\n\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n\n    return {\n      next\n    };\n  } // for (let chunk of stream)\n\n\n  [ITERATOR]() {\n    const next = () => {\n      const value = this.read();\n      const done = value === null;\n      return {\n        value,\n        done\n      };\n    };\n\n    return {\n      next\n    };\n  }\n\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/chokidar/node_modules/fsevents/node_modules/minipass/index.js"],"names":["EE","require","Yallist","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","CLOSED","READ","FLUSH","doIter","process","env","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","FLUSHCHUNK","SD","StringDecoder","ENCODING","DECODER","FLOWING","RESUME","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","B","Buffer","alloc","module","exports","MiniPass","constructor","options","pipes","buffer","objectMode","encoding","writable","readable","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","cb","from","isBuffer","flowing","emit","read","n","Array","join","concat","head","value","slice","end","once","resume","pause","push","shift","pipe","dest","opts","stdout","stderr","p","ondrain","_","on","addListener","ev","fn","removeAllListeners","emittedEnd","data","forEach","removeListener","args","arguments","i","apply","collect","Promise","resolve","reject","buf","c","next","res","done","onerr","er","ondata","onend","rej"],"mappings":"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","sourcesContent":["'use strict'\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst doIter = process.env._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst SD = require('string_decoder').StringDecoder\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nlet B = Buffer\n/* istanbul ignore next */\nif (!B.alloc) {\n  B = require('safe-buffer').Buffer\n}\n\nmodule.exports = class MiniPass extends EE {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding)\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n    if (this.flowing)\n      this[MAYBE_EMIT_END]()\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (dest === process.stdout || dest === process.stderr)\n      (opts = opts || {}).end = false\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (ev === 'end' && this[EMITTED_END]) {\n        super.emit('end')\n        this.removeAllListeners('end')\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTED_END] && this.buffer.length === 0 && this[EOF]) {\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n    }\n  }\n\n  emit (ev, data) {\n    if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p => p.dest.write(data) || this.pause())\n    } else if (ev === 'end') {\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (!p.opts || p.opts.end !== false)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END])\n        return\n    }\n\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (ev !== 'end')\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners('end')\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    return new Promise((resolve, reject) => {\n      const buf = []\n      this.on('data', c => buf.push(c))\n      this.on('end', () => resolve(buf))\n      this.on('error', reject)\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}