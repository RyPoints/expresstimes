{"ast":null,"code":"'use strict';\n\nvar Promise = require('any-promise');\n\nvar util = require('util');\n\nvar format = util.format;\n\nfunction TimeoutError(message, err) {\n  Error.call(this);\n  Error.captureStackTrace(this, TimeoutError);\n  this.name = 'TimeoutError';\n  this.message = message;\n  this.previous = err;\n}\n\nutil.inherits(TimeoutError, Error);\n\nfunction matches(match, err) {\n  if (match === true) return true;\n\n  if (typeof match === 'function') {\n    try {\n      if (err instanceof match) return true;\n    } catch (_) {\n      return !!match(err);\n    }\n  }\n\n  if (match === err.toString()) return true;\n  if (match === err.message) return true;\n  return match instanceof RegExp && (match.test(err.message) || match.test(err.toString()));\n}\n\nmodule.exports = function retryAsPromised(callback, options) {\n  if (!callback || !options) {\n    throw new Error('retry-as-promised must be passed a callback and a options set or a number');\n  }\n\n  if (typeof options === 'number') {\n    options = {\n      max: options\n    };\n  } // Super cheap clone\n\n\n  options = {\n    $current: options.$current || 1,\n    max: options.max,\n    timeout: options.timeout || undefined,\n    match: options.match || [],\n    backoffBase: options.backoffBase === undefined ? 100 : options.backoffBase,\n    backoffExponent: options.backoffExponent || 1.1,\n    report: options.report || function () {},\n    name: options.name || callback.name || 'unknown'\n  };\n  if (!Array.isArray(options.match)) options.match = [options.match];\n  options.report('Trying ' + options.name + ' #' + options.$current + ' at ' + new Date().toLocaleTimeString(), options);\n  return new Promise(function (resolve, reject) {\n    var timeout, backoffTimeout, lastError;\n\n    if (options.timeout) {\n      timeout = setTimeout(function () {\n        if (backoffTimeout) clearTimeout(backoffTimeout);\n        reject(new TimeoutError(options.name + ' timed out', lastError));\n      }, options.timeout);\n    }\n\n    Promise.resolve(callback({\n      current: options.$current\n    })).then(resolve).then(function () {\n      if (timeout) clearTimeout(timeout);\n      if (backoffTimeout) clearTimeout(backoffTimeout);\n    }).catch(function (err) {\n      if (timeout) clearTimeout(timeout);\n      if (backoffTimeout) clearTimeout(backoffTimeout);\n      lastError = err;\n      options.report(err && err.toString() || err, options); // Should not retry if max has been reached\n\n      var shouldRetry = options.$current < options.max;\n      if (!shouldRetry) return reject(err);\n      shouldRetry = options.match.length === 0 || options.match.some(function (match) {\n        return matches(match, err);\n      });\n      if (!shouldRetry) return reject(err);\n      var retryDelay = Math.pow(options.backoffBase, Math.pow(options.backoffExponent, options.$current - 1)); // Do some accounting\n\n      options.$current++;\n      options.report(format('Retrying %s (%s)', options.name, options.$current), options);\n\n      if (retryDelay) {\n        // Use backoff function to ease retry rate\n        options.report(format('Delaying retry of %s by %s', options.name, retryDelay), options);\n        backoffTimeout = setTimeout(function () {\n          retryAsPromised(callback, options).then(resolve).catch(reject);\n        }, retryDelay);\n      } else {\n        retryAsPromised(callback, options).then(resolve).catch(reject);\n      }\n    });\n  });\n};\n\nmodule.exports.TimeoutError = TimeoutError;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/retry-as-promised/index.js"],"names":["Promise","require","util","format","TimeoutError","message","err","Error","call","captureStackTrace","name","previous","inherits","matches","match","_","toString","RegExp","test","module","exports","retryAsPromised","callback","options","max","$current","timeout","undefined","backoffBase","backoffExponent","report","Array","isArray","Date","toLocaleTimeString","resolve","reject","backoffTimeout","lastError","setTimeout","clearTimeout","current","then","catch","shouldRetry","length","some","retryDelay","Math","pow"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Promise = require('any-promise');\nvar util = require('util');\nvar format = util.format;\n\nfunction TimeoutError(message, err) {\n  Error.call(this);\n  Error.captureStackTrace(this, TimeoutError);\n  this.name = 'TimeoutError';\n  this.message = message;\n  this.previous = err;\n}\n\nutil.inherits(TimeoutError, Error);\n\nfunction matches(match, err) {\n  if (match === true) return true;\n  if (typeof match === 'function') {\n    try {\n      if (err instanceof match) return true;\n    } catch (_) {\n      return !!match(err);\n    }\n  }\n  if (match === err.toString()) return true;\n  if (match === err.message) return true;\n  return match instanceof RegExp\n    && (match.test(err.message) || match.test(err.toString()));\n}\n\nmodule.exports = function retryAsPromised(callback, options) {\n  if (!callback || !options) {\n    throw new Error(\n      'retry-as-promised must be passed a callback and a options set or a number'\n    );\n  }\n\n  if (typeof options === 'number') {\n    options = {\n      max: options\n    };\n  }\n\n  // Super cheap clone\n  options = {\n    $current: options.$current || 1,\n    max: options.max,\n    timeout: options.timeout || undefined,\n    match: options.match || [],\n    backoffBase: options.backoffBase === undefined ? 100 : options.backoffBase,\n    backoffExponent: options.backoffExponent || 1.1,\n    report: options.report || function () {},\n    name: options.name || callback.name || 'unknown'\n  };\n\n  if (!Array.isArray(options.match)) options.match = [options.match];\n  options.report('Trying ' + options.name + ' #' + options.$current + ' at ' + new Date().toLocaleTimeString(), options);\n\n  return new Promise(function(resolve, reject) {\n    var timeout, backoffTimeout, lastError;\n\n    if (options.timeout) {\n      timeout = setTimeout(function() {\n        if (backoffTimeout) clearTimeout(backoffTimeout);\n        reject(new TimeoutError(options.name + ' timed out', lastError));\n      }, options.timeout);\n    }\n\n    Promise.resolve(callback({ current: options.$current }))\n      .then(resolve)\n      .then(function() {\n        if (timeout) clearTimeout(timeout);\n        if (backoffTimeout) clearTimeout(backoffTimeout);\n      })\n      .catch(function(err) {\n        if (timeout) clearTimeout(timeout);\n        if (backoffTimeout) clearTimeout(backoffTimeout);\n\n        lastError = err;\n        options.report((err && err.toString()) || err, options);\n\n        // Should not retry if max has been reached\n        var shouldRetry = options.$current < options.max;\n        if (!shouldRetry) return reject(err);\n        shouldRetry = options.match.length === 0 || options.match.some(function (match) {\n          return matches(match, err)\n        });\n        if (!shouldRetry) return reject(err);\n\n        var retryDelay = Math.pow(\n          options.backoffBase,\n          Math.pow(options.backoffExponent, options.$current - 1)\n        );\n\n        // Do some accounting\n        options.$current++;\n        options.report(format('Retrying %s (%s)', options.name, options.$current), options);\n\n        if (retryDelay) {\n          // Use backoff function to ease retry rate\n          options.report(format('Delaying retry of %s by %s', options.name, retryDelay), options);\n          backoffTimeout = setTimeout(function() {\n            retryAsPromised(callback, options)\n              .then(resolve)\n              .catch(reject);\n          }, retryDelay);\n        } else {\n          retryAsPromised(callback, options)\n            .then(resolve)\n            .catch(reject);\n        }\n      });\n  });\n};\n\nmodule.exports.TimeoutError = TimeoutError;\n"]},"metadata":{},"sourceType":"script"}