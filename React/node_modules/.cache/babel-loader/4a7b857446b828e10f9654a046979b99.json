{"ast":null,"code":"'use strict';\n\nconst Command = require('./command.js');\n\nconst Packets = require('../packets/index.js');\n\nconst ClientConstants = require('../constants/client.js');\n\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nconst auth41 = require('../auth_41.js');\n\nfunction flagNames(flags) {\n  const res = [];\n\n  for (const c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n\n  return res;\n}\n\nclass ClientHandshake extends Command {\n  constructor(clientFlags) {\n    super();\n    this.handshake = null;\n    this.clientFlags = clientFlags;\n  }\n\n  start() {\n    return ClientHandshake.prototype.handshakeInit;\n  }\n\n  sendSSLRequest(connection) {\n    const sslRequest = new Packets.SSLRequest(this.clientFlags, connection.config.charsetNumber);\n    connection.writePacket(sslRequest.toPacket());\n  }\n\n  sendCredentials(connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Sending handshake packet: flags:%d=(%s)', this.clientFlags, flagNames(this.clientFlags).join(', '));\n    }\n\n    this.user = connection.config.user;\n    this.password = connection.config.password;\n    this.passwordSha1 = connection.config.passwordSha1;\n    this.database = connection.config.database;\n    this.autPluginName = this.handshake.autPluginName;\n    const handshakeResponse = new Packets.HandshakeResponse({\n      flags: this.clientFlags,\n      user: this.user,\n      database: this.database,\n      password: this.password,\n      passwordSha1: this.passwordSha1,\n      charsetNumber: connection.config.charsetNumber,\n      authPluginData1: this.handshake.authPluginData1,\n      authPluginData2: this.handshake.authPluginData2,\n      compress: connection.config.compress,\n      connectAttributes: connection.config.connectAttributes\n    });\n    connection.writePacket(handshakeResponse.toPacket());\n  }\n\n  calculateNativePasswordAuthToken(authPluginData) {\n    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n    const authPluginData1 = authPluginData.slice(0, 8);\n    const authPluginData2 = authPluginData.slice(8, 20);\n    let authToken;\n\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, authPluginData1, authPluginData2);\n    } else {\n      authToken = auth41.calculateToken(this.password, authPluginData1, authPluginData2);\n    }\n\n    return authToken;\n  }\n\n  handshakeInit(helloPacket, connection) {\n    this.on('error', e => {\n      connection._fatalError = e;\n      connection._protocolError = e;\n    });\n    this.handshake = Packets.Handshake.fromPacket(helloPacket);\n\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Server hello packet: capability flags:%d=(%s)', this.handshake.capabilityFlags, flagNames(this.handshake.capabilityFlags).join(', '));\n    }\n\n    connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n    connection.connectionId = this.handshake.connectionId;\n    const serverSSLSupport = this.handshake.capabilityFlags & ClientConstants.SSL; // use compression only if requested by client and supported by server\n\n    connection.config.compress = connection.config.compress && this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n    this.clientFlags = this.clientFlags | connection.config.compress;\n\n    if (connection.config.ssl) {\n      // client requires SSL but server does not support it\n      if (!serverSSLSupport) {\n        const err = new Error('Server does not support secure connnection');\n        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n        err.fatal = true;\n        this.emit('error', err);\n        return false;\n      } // send ssl upgrade request and immediately upgrade connection to secure\n\n\n      this.clientFlags |= ClientConstants.SSL;\n      this.sendSSLRequest(connection);\n      connection.startTLS(err => {\n        // after connection is secure\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          this.emit('error', err);\n          return;\n        } // rest of communication is encrypted\n\n\n        this.sendCredentials(connection);\n      });\n    } else {\n      this.sendCredentials(connection);\n    }\n\n    return ClientHandshake.prototype.handshakeResult;\n  }\n\n  handshakeResult(packet, connection) {\n    const marker = packet.peekByte();\n\n    if (marker === 0xfe || marker === 1) {\n      const authSwitch = require('./auth_switch');\n\n      try {\n        if (marker === 1) {\n          authSwitch.authSwitchRequestMoreData(packet, connection, this);\n        } else {\n          authSwitch.authSwitchRequest(packet, connection, this);\n        }\n\n        return ClientHandshake.prototype.handshakeResult;\n      } catch (err) {\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          connection.emit('error', err);\n        }\n\n        return null;\n      }\n    }\n\n    if (marker !== 0) {\n      const err = new Error('Unexpected packet during handshake phase');\n\n      if (this.onResult) {\n        this.onResult(err);\n      } else {\n        connection.emit('error', err);\n      }\n\n      return null;\n    } // this should be called from ClientHandshake command only\n    // and skipped when called from ChangeUser command\n\n\n    if (!connection.authorized) {\n      connection.authorized = true;\n\n      if (connection.config.compress) {\n        const enableCompression = require('../compressed_protocol.js').enableCompression;\n\n        enableCompression(connection);\n      }\n    }\n\n    if (this.onResult) {\n      this.onResult(null);\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports = ClientHandshake;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/mysql2/lib/commands/client_handshake.js"],"names":["Command","require","Packets","ClientConstants","CharsetToEncoding","auth41","flagNames","flags","res","c","push","replace","toLowerCase","ClientHandshake","constructor","clientFlags","handshake","start","prototype","handshakeInit","sendSSLRequest","connection","sslRequest","SSLRequest","config","charsetNumber","writePacket","toPacket","sendCredentials","debug","console","log","join","user","password","passwordSha1","database","autPluginName","handshakeResponse","HandshakeResponse","authPluginData1","authPluginData2","compress","connectAttributes","calculateNativePasswordAuthToken","authPluginData","slice","authToken","calculateTokenFromPasswordSha","calculateToken","helloPacket","on","e","_fatalError","_protocolError","Handshake","fromPacket","capabilityFlags","serverCapabilityFlags","serverEncoding","characterSet","connectionId","serverSSLSupport","SSL","COMPRESS","ssl","err","Error","code","fatal","emit","startTLS","handshakeResult","packet","marker","peekByte","authSwitch","authSwitchRequestMoreData","authSwitchRequest","onResult","authorized","enableCompression","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Command = require('./command.js');\nconst Packets = require('../packets/index.js');\nconst ClientConstants = require('../constants/client.js');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nconst auth41 = require('../auth_41.js');\n\nfunction flagNames(flags) {\n  const res = [];\n  for (const c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n  return res;\n}\n\nclass ClientHandshake extends Command {\n  constructor(clientFlags) {\n    super();\n    this.handshake = null;\n    this.clientFlags = clientFlags;\n  }\n\n  start() {\n    return ClientHandshake.prototype.handshakeInit;\n  }\n\n  sendSSLRequest(connection) {\n    const sslRequest = new Packets.SSLRequest(\n      this.clientFlags,\n      connection.config.charsetNumber\n    );\n    connection.writePacket(sslRequest.toPacket());\n  }\n\n  sendCredentials(connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        'Sending handshake packet: flags:%d=(%s)',\n        this.clientFlags,\n        flagNames(this.clientFlags).join(', ')\n      );\n    }\n    this.user = connection.config.user;\n    this.password = connection.config.password;\n    this.passwordSha1 = connection.config.passwordSha1;\n    this.database = connection.config.database;\n    this.autPluginName = this.handshake.autPluginName;\n    const handshakeResponse = new Packets.HandshakeResponse({\n      flags: this.clientFlags,\n      user: this.user,\n      database: this.database,\n      password: this.password,\n      passwordSha1: this.passwordSha1,\n      charsetNumber: connection.config.charsetNumber,\n      authPluginData1: this.handshake.authPluginData1,\n      authPluginData2: this.handshake.authPluginData2,\n      compress: connection.config.compress,\n      connectAttributes: connection.config.connectAttributes\n    });\n    connection.writePacket(handshakeResponse.toPacket());\n  }\n\n  calculateNativePasswordAuthToken(authPluginData) {\n    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n    const authPluginData1 = authPluginData.slice(0, 8);\n    const authPluginData2 = authPluginData.slice(8, 20);\n    let authToken;\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(\n        this.passwordSha1,\n        authPluginData1,\n        authPluginData2\n      );\n    } else {\n      authToken = auth41.calculateToken(\n        this.password,\n        authPluginData1,\n        authPluginData2\n      );\n    }\n    return authToken;\n  }\n\n  handshakeInit(helloPacket, connection) {\n    this.on('error', e => {\n      connection._fatalError = e;\n      connection._protocolError = e;\n    });\n    this.handshake = Packets.Handshake.fromPacket(helloPacket);\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        'Server hello packet: capability flags:%d=(%s)',\n        this.handshake.capabilityFlags,\n        flagNames(this.handshake.capabilityFlags).join(', ')\n      );\n    }\n    connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n    connection.connectionId = this.handshake.connectionId;\n    const serverSSLSupport =\n      this.handshake.capabilityFlags & ClientConstants.SSL;\n    // use compression only if requested by client and supported by server\n    connection.config.compress =\n      connection.config.compress &&\n      this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n    this.clientFlags = this.clientFlags | connection.config.compress;\n    if (connection.config.ssl) {\n      // client requires SSL but server does not support it\n      if (!serverSSLSupport) {\n        const err = new Error('Server does not support secure connnection');\n        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n        err.fatal = true;\n        this.emit('error', err);\n        return false;\n      }\n      // send ssl upgrade request and immediately upgrade connection to secure\n      this.clientFlags |= ClientConstants.SSL;\n      this.sendSSLRequest(connection);\n      connection.startTLS(err => {\n        // after connection is secure\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          this.emit('error', err);\n          return;\n        }\n        // rest of communication is encrypted\n        this.sendCredentials(connection);\n      });\n    } else {\n      this.sendCredentials(connection);\n    }\n    return ClientHandshake.prototype.handshakeResult;\n  }\n\n  handshakeResult(packet, connection) {\n    const marker = packet.peekByte();\n    if (marker === 0xfe || marker === 1) {\n      const authSwitch = require('./auth_switch');\n      try {\n        if (marker === 1) {\n          authSwitch.authSwitchRequestMoreData(packet, connection, this);\n        } else {\n          authSwitch.authSwitchRequest(packet, connection, this);\n        }\n        return ClientHandshake.prototype.handshakeResult;\n      } catch (err) {\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          connection.emit('error', err);\n        }\n        return null;\n      }\n    }\n    if (marker !== 0) {\n      const err = new Error('Unexpected packet during handshake phase');\n      if (this.onResult) {\n        this.onResult(err);\n      } else {\n        connection.emit('error', err);\n      }\n      return null;\n    }\n    // this should be called from ClientHandshake command only\n    // and skipped when called from ChangeUser command\n    if (!connection.authorized) {\n      connection.authorized = true;\n      if (connection.config.compress) {\n        const enableCompression = require('../compressed_protocol.js')\n          .enableCompression;\n        enableCompression(connection);\n      }\n    }\n    if (this.onResult) {\n      this.onResult(null);\n    }\n    return null;\n  }\n}\nmodule.exports = ClientHandshake;\n"]},"metadata":{},"sourceType":"script"}