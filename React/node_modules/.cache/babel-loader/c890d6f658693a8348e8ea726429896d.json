{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst SequelizeErrors = require('../../errors');\n\nconst Utils = require('../../utils');\n\nconst DataTypes = require('../../data-types').mysql;\n\nconst momentTz = require('moment-timezone');\n\nconst debug = Utils.getLogger().debugContext('connection:mysql');\nconst parserMap = new Map();\n/**\n * MySQL Connection Managger\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @extends AbstractConnectionManager\n * @return Class<ConnectionManager>\n * @private\n */\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 3306;\n\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath);\n      } else {\n        this.lib = require('mysql2');\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install mysql2 package manually');\n      }\n\n      throw err;\n    }\n\n    this.refreshTypeParser(DataTypes);\n  } // Update parsing when the user has added additional, custom types\n\n\n  _refreshTypeParser(dataType) {\n    for (const type of dataType.types.mysql) {\n      parserMap.set(type, dataType.parse);\n    }\n  }\n\n  _clearTypeParser() {\n    parserMap.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserMap.has(field.type)) {\n      return parserMap.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once conection is connected\n   *\n   * @return Promise<Connection>\n   * @private\n   */\n\n\n  connect(config) {\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    };\n\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    return new Utils.Promise((resolve, reject) => {\n      const connection = this.lib.createConnection(connectionConfig);\n\n      const errorHandler = e => {\n        // clean up connect event if there is error\n        connection.removeListener('connect', connectHandler);\n\n        if (config.pool.handleDisconnects) {\n          debug(`connection error ${e.code}`);\n\n          if (e.code === 'PROTOCOL_CONNECTION_LOST') {\n            this.pool.destroy(connection).catch(/Resource not currently part of this pool/, () => {});\n            return;\n          }\n        }\n\n        connection.removeListener('error', errorHandler);\n        reject(e);\n      };\n\n      const connectHandler = () => {\n        if (!config.pool.handleDisconnects) {\n          // clean up error event if connected\n          connection.removeListener('error', errorHandler);\n        }\n\n        resolve(connection);\n      };\n\n      connection.on('error', errorHandler);\n      connection.once('connect', connectHandler);\n    }).tap(() => {\n      debug('connection acquired');\n    }).then(connection => {\n      return new Utils.Promise((resolve, reject) => {\n        // set timezone for this connection\n        // but named timezone are not directly supported in mysql, so get its offset first\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n        connection.query(`SET time_zone = '${tzOffset}'`, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(connection);\n          }\n        });\n      });\n    }).catch(err => {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    });\n  }\n\n  disconnect(connection) {\n    // Dont disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Utils.Promise.resolve();\n    }\n\n    return new Utils.Promise((resolve, reject) => {\n      connection.end(err => {\n        if (err) {\n          reject(new SequelizeErrors.ConnectionError(err));\n        } else {\n          debug('connection disconnected');\n          resolve();\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection && connection._fatalError === null && connection._protocolError === null && !connection._closing && !connection.stream.destroyed;\n  }\n\n}\n\n_.extend(ConnectionManager.prototype, AbstractConnectionManager.prototype);\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/dialects/mysql/connection-manager.js"],"names":["_","require","AbstractConnectionManager","SequelizeErrors","Utils","DataTypes","mysql","momentTz","debug","getLogger","debugContext","parserMap","Map","ConnectionManager","constructor","dialect","sequelize","config","port","dialectModulePath","lib","err","code","Error","refreshTypeParser","_refreshTypeParser","dataType","type","types","set","parse","_clearTypeParser","clear","_typecast","field","next","has","get","options","connect","connectionConfig","host","user","username","flags","password","database","timezone","typeCast","bind","bigNumberStrings","supportBigNumbers","dialectOptions","key","Object","keys","Promise","resolve","reject","connection","createConnection","errorHandler","e","removeListener","connectHandler","pool","handleDisconnects","destroy","catch","on","once","tap","then","tzOffset","test","tz","format","query","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","disconnect","_closing","end","validate","_fatalError","_protocolError","stream","destroyed","extend","prototype","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types').mysql;\nconst momentTz = require('moment-timezone');\nconst debug = Utils.getLogger().debugContext('connection:mysql');\nconst parserMap = new Map();\n\n/**\n * MySQL Connection Managger\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @extends AbstractConnectionManager\n * @return Class<ConnectionManager>\n * @private\n */\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 3306;\n    try {\n      if (sequelize.config.dialectModulePath) {\n        this.lib = require(sequelize.config.dialectModulePath);\n      } else {\n        this.lib = require('mysql2');\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        throw new Error('Please install mysql2 package manually');\n      }\n      throw err;\n    }\n\n    this.refreshTypeParser(DataTypes);\n  }\n\n  // Update parsing when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    for (const type of dataType.types.mysql) {\n      parserMap.set(type, dataType.parse);\n    }\n  }\n\n  _clearTypeParser() {\n    parserMap.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserMap.has(field.type)) {\n      return parserMap.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once conection is connected\n   *\n   * @return Promise<Connection>\n   * @private\n   */\n  connect(config) {\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    };\n\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    return new Utils.Promise((resolve, reject) => {\n      const connection = this.lib.createConnection(connectionConfig);\n\n      const errorHandler = e => {\n        // clean up connect event if there is error\n        connection.removeListener('connect', connectHandler);\n\n        if (config.pool.handleDisconnects) {\n          debug(`connection error ${e.code}`);\n\n          if (e.code === 'PROTOCOL_CONNECTION_LOST') {\n            this.pool.destroy(connection)\n              .catch(/Resource not currently part of this pool/, () => {});\n            return;\n          }\n        }\n\n        connection.removeListener('error', errorHandler);\n        reject(e);\n      };\n\n      const connectHandler = () => {\n        if (!config.pool.handleDisconnects) {\n          // clean up error event if connected\n          connection.removeListener('error', errorHandler);\n        }\n        resolve(connection);\n      };\n\n      connection.on('error', errorHandler);\n      connection.once('connect', connectHandler);\n    })\n      .tap (() => { debug('connection acquired'); })\n      .then(connection => {\n        return new Utils.Promise((resolve, reject) => {\n        // set timezone for this connection\n        // but named timezone are not directly supported in mysql, so get its offset first\n          let tzOffset = this.sequelize.options.timezone;\n          tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n          connection.query(`SET time_zone = '${tzOffset}'`, err => {\n            if (err) { reject(err); } else { resolve(connection); }\n          });\n        });\n      })\n      .catch(err => {\n        switch (err.code) {\n          case 'ECONNREFUSED':\n            throw new SequelizeErrors.ConnectionRefusedError(err);\n          case 'ER_ACCESS_DENIED_ERROR':\n            throw new SequelizeErrors.AccessDeniedError(err);\n          case 'ENOTFOUND':\n            throw new SequelizeErrors.HostNotFoundError(err);\n          case 'EHOSTUNREACH':\n            throw new SequelizeErrors.HostNotReachableError(err);\n          case 'EINVAL':\n            throw new SequelizeErrors.InvalidConnectionError(err);\n          default:\n            throw new SequelizeErrors.ConnectionError(err);\n        }\n      });\n  }\n\n  disconnect(connection) {\n    // Dont disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Utils.Promise.resolve();\n    }\n\n    return new Utils.Promise((resolve, reject) => {\n      connection.end(err => {\n        if (err) {\n          reject(new SequelizeErrors.ConnectionError(err));\n        } else {\n          debug('connection disconnected');\n          resolve();\n        }\n      });\n    });\n  }\n\n  validate(connection) {\n    return connection && connection._fatalError === null && connection._protocolError === null && !connection._closing &&\n      !connection.stream.destroyed;\n  }\n}\n\n_.extend(ConnectionManager.prototype, AbstractConnectionManager.prototype);\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}