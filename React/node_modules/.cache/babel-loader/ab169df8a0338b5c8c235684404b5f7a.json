{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '';\n  } else if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  } else {\n    return JSON.stringify(bound);\n  }\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  } else if (bound === 'infinity') {\n    return Infinity;\n  } else if (bound === '-infinity') {\n    return -Infinity;\n  } else {\n    return parseType(bound);\n  }\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n  if (!_.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (data.hasOwnProperty('inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];else if (!data.inclusive) data.inclusive = [true, false];else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (value.hasOwnProperty('inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (value.hasOwnProperty('value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return (data.inclusive[0] ? '[' : '(') + lowerBound + ',' + upperBound + (data.inclusive[1] ? ']' : ')');\n}\n\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n\n  if (value === 'empty') {\n    const empty = [];\n    empty.inclusive = [];\n    return empty;\n  }\n\n  let result = value.substring(1, value.length - 1).split(',', 2);\n  if (result.length !== 2) return value;\n  result = result.map(value => parseRangeBound(value, parser));\n  result.inclusive = [value[0] === '[', value[value.length - 1] === ']'];\n  return result;\n}\n\nexports.parse = parse;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/dialects/postgres/range.js"],"names":["_","require","stringifyRangeBound","bound","Infinity","toString","toLowerCase","JSON","stringify","parseRangeBound","parseType","data","isArray","Error","length","hasOwnProperty","inclusive","each","value","index","isObject","lowerBound","upperBound","exports","parse","parser","empty","result","substring","split","map"],"mappings":"AAAA;;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AAEA,SAASC,mBAAT,CAA6BC,KAA7B,EAAoC;AAClC,MAAIA,KAAK,KAAK,IAAd,EAAoB;AAClB,WAAO,EAAP;AACD,GAFD,MAEO,IAAIA,KAAK,KAAKC,QAAV,IAAsBD,KAAK,KAAK,CAACC,QAArC,EAA+C;AACpD,WAAOD,KAAK,CAACE,QAAN,GAAiBC,WAAjB,EAAP;AACD,GAFM,MAEA;AACL,WAAOC,IAAI,CAACC,SAAL,CAAeL,KAAf,CAAP;AACD;AACF;;AAED,SAASM,eAAT,CAAyBN,KAAzB,EAAgCO,SAAhC,EAA2C;AACzC,MAAI,CAACP,KAAL,EAAY;AACV,WAAO,IAAP;AACD,GAFD,MAEO,IAAIA,KAAK,KAAK,UAAd,EAA0B;AAC/B,WAAOC,QAAP;AACD,GAFM,MAEA,IAAID,KAAK,KAAK,WAAd,EAA2B;AAChC,WAAO,CAACC,QAAR;AACD,GAFM,MAEA;AACL,WAAOM,SAAS,CAACP,KAAD,CAAhB;AACD;AACF;;AAED,SAASK,SAAT,CAAmBG,IAAnB,EAAyB;AACvB,MAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,IAAP;AAEnB,MAAI,CAACX,CAAC,CAACY,OAAF,CAAUD,IAAV,CAAL,EAAsB,MAAM,IAAIE,KAAJ,CAAU,wBAAV,CAAN;AACtB,MAAI,CAACF,IAAI,CAACG,MAAV,EAAkB,OAAO,OAAP;AAClB,MAAIH,IAAI,CAACG,MAAL,KAAgB,CAApB,EAAuB,MAAM,IAAID,KAAJ,CAAU,oEAAV,CAAN;;AAEvB,MAAIF,IAAI,CAACI,cAAL,CAAoB,WAApB,CAAJ,EAAsC;AACpC,QAAIJ,IAAI,CAACK,SAAL,KAAmB,KAAvB,EAA8BL,IAAI,CAACK,SAAL,GAAiB,CAAC,KAAD,EAAQ,KAAR,CAAjB,CAA9B,KACK,IAAI,CAACL,IAAI,CAACK,SAAV,EAAqBL,IAAI,CAACK,SAAL,GAAiB,CAAC,IAAD,EAAO,KAAP,CAAjB,CAArB,KACA,IAAIL,IAAI,CAACK,SAAL,KAAmB,IAAvB,EAA6BL,IAAI,CAACK,SAAL,GAAiB,CAAC,IAAD,EAAO,IAAP,CAAjB;AACnC,GAJD,MAIO;AACLL,IAAAA,IAAI,CAACK,SAAL,GAAiB,CAAC,IAAD,EAAO,KAAP,CAAjB;AACD;;AAEDhB,EAAAA,CAAC,CAACiB,IAAF,CAAON,IAAP,EAAa,CAACO,KAAD,EAAQC,KAAR,KAAkB;AAC7B,QAAInB,CAAC,CAACoB,QAAF,CAAWF,KAAX,CAAJ,EAAuB;AACrB,UAAIA,KAAK,CAACH,cAAN,CAAqB,WAArB,CAAJ,EAAuCJ,IAAI,CAACK,SAAL,CAAeG,KAAf,IAAwB,CAAC,CAACD,KAAK,CAACF,SAAhC;AACvC,UAAIE,KAAK,CAACH,cAAN,CAAqB,OAArB,CAAJ,EAAmCJ,IAAI,CAACQ,KAAD,CAAJ,GAAcD,KAAK,CAACA,KAApB;AACpC;AACF,GALD;;AAOA,QAAMG,UAAU,GAAGnB,mBAAmB,CAACS,IAAI,CAAC,CAAD,CAAL,CAAtC;AACA,QAAMW,UAAU,GAAGpB,mBAAmB,CAACS,IAAI,CAAC,CAAD,CAAL,CAAtC;AAEA,SAAO,CAACA,IAAI,CAACK,SAAL,CAAe,CAAf,IAAoB,GAApB,GAA0B,GAA3B,IAAkCK,UAAlC,GAA+C,GAA/C,GAAqDC,UAArD,IAAmEX,IAAI,CAACK,SAAL,CAAe,CAAf,IAAoB,GAApB,GAA0B,GAA7F,CAAP;AACD;;AACDO,OAAO,CAACf,SAAR,GAAoBA,SAApB;;AAEA,SAASgB,KAAT,CAAeN,KAAf,EAAsBO,MAAtB,EAA8B;AAC5B,MAAIP,KAAK,KAAK,IAAd,EAAoB,OAAO,IAAP;;AACpB,MAAIA,KAAK,KAAK,OAAd,EAAuB;AACrB,UAAMQ,KAAK,GAAG,EAAd;AACAA,IAAAA,KAAK,CAACV,SAAN,GAAkB,EAAlB;AACA,WAAOU,KAAP;AACD;;AAED,MAAIC,MAAM,GAAGT,KAAK,CACfU,SADU,CACA,CADA,EACGV,KAAK,CAACJ,MAAN,GAAe,CADlB,EAEVe,KAFU,CAEJ,GAFI,EAEC,CAFD,CAAb;AAIA,MAAIF,MAAM,CAACb,MAAP,KAAkB,CAAtB,EAAyB,OAAOI,KAAP;AAEzBS,EAAAA,MAAM,GAAGA,MAAM,CAACG,GAAP,CAAWZ,KAAK,IAAIT,eAAe,CAACS,KAAD,EAAQO,MAAR,CAAnC,CAAT;AAEAE,EAAAA,MAAM,CAACX,SAAP,GAAmB,CAACE,KAAK,CAAC,CAAD,CAAL,KAAa,GAAd,EAAmBA,KAAK,CAACA,KAAK,CAACJ,MAAN,GAAe,CAAhB,CAAL,KAA4B,GAA/C,CAAnB;AAEA,SAAOa,MAAP;AACD;;AACDJ,OAAO,CAACC,KAAR,GAAgBA,KAAhB","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  } else if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  } else {\n    return JSON.stringify(bound);\n  }\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  } else if (bound === 'infinity') {\n    return Infinity;\n  } else if (bound === '-infinity') {\n    return -Infinity;\n  } else {\n    return parseType(bound);\n  }\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!_.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (data.hasOwnProperty('inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (value.hasOwnProperty('inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (value.hasOwnProperty('value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return (data.inclusive[0] ? '[' : '(') + lowerBound + ',' + upperBound + (data.inclusive[1] ? ']' : ')');\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    const empty = [];\n    empty.inclusive = [];\n    return empty;\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map(value => parseRangeBound(value, parser));\n\n  result.inclusive = [value[0] === '[', value[value.length - 1] === ']'];\n\n  return result;\n}\nexports.parse = parse;\n"]},"metadata":{},"sourceType":"script"}