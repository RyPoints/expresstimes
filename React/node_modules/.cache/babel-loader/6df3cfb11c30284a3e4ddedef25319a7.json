{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst util = require('util');\n\nconst Op = require('../../operators');\n\nconst jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst foreignKeyFields = 'CONSTRAINT_NAME as constraint_name,' + 'CONSTRAINT_NAME as constraintName,' + 'CONSTRAINT_SCHEMA as constraintSchema,' + 'CONSTRAINT_SCHEMA as constraintCatalog,' + 'TABLE_NAME as tableName,' + 'TABLE_SCHEMA as tableSchema,' + 'TABLE_SCHEMA as tableCatalog,' + 'COLUMN_NAME as columnName,' + 'REFERENCED_TABLE_SCHEMA as referencedTableSchema,' + 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog,' + 'REFERENCED_TABLE_NAME as referencedTableName,' + 'REFERENCED_COLUMN_NAME as referencedColumnName';\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = Object.assign({}, this.OperatorMap, {\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n    const database = this.quoteIdentifier(databaseName);\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n    return `${`CREATE DATABASE IF NOT EXISTS ${database}${charset}${collate}`.trim()};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName).trim()};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const comment = options.comment && typeof options.comment === 'string' ? ` COMMENT ${this.escape(options.comment)}` : '';\n    const engine = options.engine;\n    const charset = options.charset ? ` DEFAULT CHARSET=${options.charset}` : '';\n    const collation = options.collate ? ` COLLATE ${options.collate}` : '';\n    const rowFormat = options.rowFormat ? ` ROW_FORMAT=${options.rowFormat}` : '';\n    const initialAutoIncrement = options.initialAutoIncrement ? ` AUTO_INCREMENT=${options.initialAutoIncrement}` : '';\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${table} (${attributesClause}) ENGINE=${engine}${comment}${charset}${collation}${initialAutoIncrement}${rowFormat};`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n\n    if (attrString.length) {\n      finalQuery += `CHANGE ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(' AND ');\n      }\n\n      if (smth.path) {\n        let str; // Allow specifying conditions using the sqlite json functions\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    } // null is stored as a string in mysql\n\n\n    if (value === null) {\n      return 'null';\n    }\n\n    return value;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return `${key}=VALUES(${key})`;\n    }).join(', ');\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return `SHOW INDEX FROM ${this.quoteTable(tableName)}${(options || {}).database ? ` FROM \\`${options.database}\\`` : ''}`;\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = ['SELECT CONSTRAINT_CATALOG AS constraintCatalog,', 'CONSTRAINT_NAME AS constraintName,', 'CONSTRAINT_SCHEMA AS constraintSchema,', 'CONSTRAINT_TYPE AS constraintType,', 'TABLE_NAME AS tableName,', 'TABLE_SCHEMA AS tableSchema', 'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS', `WHERE table_name='${tableName}'`].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    if (schemaName) {\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    } // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n\n\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}' AND REFERENCED_TABLE_NAME IS NOT NULL;`;\n  }\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE` + ` WHERE (REFERENCED_TABLE_NAME = ${quotedTableName}${table.schema ? ` AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}` : ''} AND REFERENCED_COLUMN_NAME = ${quotedColumnName})` + ` OR (TABLE_NAME = ${quotedTableName}${table.schema ? ` AND TABLE_SCHEMA = ${quotedSchemaName}` : ''} AND COLUMN_NAME = ${quotedColumnName} AND REFERENCED_TABLE_NAME IS NOT NULL)`;\n  }\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)}\n      DROP FOREIGN KEY ${this.quoteIdentifier(foreignKey)};`;\n  }\n\n} // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/dialects/mysql/query-generator.js"],"names":["_","require","Utils","AbstractQueryGenerator","util","Op","jsonFunctionRegex","jsonOperatorRegex","tokenCaptureRegex","foreignKeyFields","typeWithoutDefault","Set","MySQLQueryGenerator","constructor","options","OperatorMap","Object","assign","regexp","notRegexp","createDatabaseQuery","databaseName","charset","collate","database","quoteIdentifier","escape","trim","dropDatabaseQuery","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","engine","rowFormat","primaryKeys","foreignKeys","attrStr","attr","prototype","hasOwnProperty","call","dataType","match","includes","push","replace","table","quoteTable","attributesClause","join","comment","collation","initialAutoIncrement","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","describeTableQuery","schema","schemaDelimiter","addSchema","_schema","_schemaDelimiter","showTablesQuery","query","addColumnQuery","key","definition","attributeToSQL","context","foreignKey","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","attrName","finalQuery","renameColumnQuery","attrBefore","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","value","str","_checkValidJsonStatement","paths","toPath","column","shift","format","Cast","test","type","json","_toJSONValue","toString","upsertQuery","insertValues","updateValues","where","model","onDuplicate","keys","insertQuery","rawAttributes","truncateTableQuery","deleteQuery","limit","getWhereConditions","showIndexesQuery","showConstraintsQuery","constraintName","schemaName","sql","removeIndexQuery","indexNameOrAttributes","underscore","attribute","isPlainObject","attributeString","bind","template","allowNull","autoIncrement","has","_binary","defaultValueSchemable","defaultValue","unique","primaryKey","first","after","references","fkName","onDelete","toUpperCase","onUpdate","attributesToSQL","result","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","indexOf","operatorMatches","tokenMatches","capturedToken","Error","getForeignKeysQuery","getForeignKeyQuery","columnName","quotedSchemaName","wrapSingleQuote","quotedTableName","quotedColumnName","dropForeignKeyQuery","identifier","addTicks","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst foreignKeyFields = 'CONSTRAINT_NAME as constraint_name,'\n  + 'CONSTRAINT_NAME as constraintName,'\n  + 'CONSTRAINT_SCHEMA as constraintSchema,'\n  + 'CONSTRAINT_SCHEMA as constraintCatalog,'\n  + 'TABLE_NAME as tableName,'\n  + 'TABLE_SCHEMA as tableSchema,'\n  + 'TABLE_SCHEMA as tableCatalog,'\n  + 'COLUMN_NAME as columnName,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableSchema,'\n  + 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog,'\n  + 'REFERENCED_TABLE_NAME as referencedTableName,'\n  + 'REFERENCED_COLUMN_NAME as referencedColumnName';\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = Object.assign({}, this.OperatorMap, {\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      charset: null,\n      collate: null\n    }, options || {});\n\n    const database = this.quoteIdentifier(databaseName);\n    const charset = options.charset ? ` DEFAULT CHARACTER SET ${this.escape(options.charset)}` : '';\n    const collate = options.collate ? ` DEFAULT COLLATE ${this.escape(options.collate)}` : '';\n\n    return `${`CREATE DATABASE IF NOT EXISTS ${database}${charset}${collate}`.trim()};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName).trim()};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null\n    }, options || {});\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const comment = options.comment && typeof options.comment === 'string' ? ` COMMENT ${this.escape(options.comment)}` : '';\n    const engine = options.engine;\n    const charset = options.charset ? ` DEFAULT CHARSET=${options.charset}` : '';\n    const collation = options.collate ? ` COLLATE ${options.collate}` : '';\n    const rowFormat = options.rowFormat ? ` ROW_FORMAT=${options.rowFormat}` : '';\n    const initialAutoIncrement = options.initialAutoIncrement ? ` AUTO_INCREMENT=${options.initialAutoIncrement}` : '';\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${table} (${attributesClause}) ENGINE=${engine}${comment}${charset}${collation}${initialAutoIncrement}${rowFormat};`;\n  }\n\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key\n    });\n\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `CHANGE ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} CHANGE ${attrString.join(', ')};`;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    options.onDuplicate = 'UPDATE ';\n\n    options.onDuplicate += Object.keys(updateValues).map(key => {\n      key = this.quoteIdentifier(key);\n      return `${key}=VALUES(${key})`;\n    }).join(', ');\n\n    return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return `SHOW INDEX FROM ${this.quoteTable(tableName)}${(options || {}).database ? ` FROM \\`${options.database}\\`` : ''}`;\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    let sql = [\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`\n    ].join(' ');\n\n    if (constraintName) {\n      sql += ` AND constraint_name = '${constraintName}'`;\n    }\n\n    if (schemaName) {\n      sql += ` AND TABLE_SCHEMA = '${schemaName}'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)} ON ${this.quoteTable(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}' AND REFERENCED_TABLE_NAME IS NOT NULL;`;\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {Object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return `SELECT ${foreignKeyFields} FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE`\n      + ` WHERE (REFERENCED_TABLE_NAME = ${quotedTableName}${table.schema\n        ? ` AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`\n        : ''} AND REFERENCED_COLUMN_NAME = ${quotedColumnName})`\n      + ` OR (TABLE_NAME = ${quotedTableName}${table.schema ?\n        ` AND TABLE_SCHEMA = ${quotedSchemaName}` : ''} AND COLUMN_NAME = ${quotedColumnName} AND REFERENCED_TABLE_NAME IS NOT NULL)`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)}\n      DROP FOREIGN KEY ${this.quoteIdentifier(foreignKey)};`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}