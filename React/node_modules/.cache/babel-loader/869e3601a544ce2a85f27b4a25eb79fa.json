{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst DataTypes = require('../../data-types');\n\nconst TableHints = require('../../table-hints');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst randomBytes = require('crypto').randomBytes;\n\nconst semver = require('semver');\n\nconst Op = require('../../operators');\n/* istanbul ignore next */\n\n\nconst throwMethodUndefined = function (methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      collate: null\n    }, options || {});\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n    return ['IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')', 'BEGIN', 'CREATE DATABASE', this.quoteIdentifier(databaseName), `${collation};`, 'END;'].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return ['IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')', 'BEGIN', 'DROP DATABASE', this.quoteIdentifier(databaseName), ';', 'END;'].join(' ');\n  }\n\n  createSchema(schema) {\n    return ['IF NOT EXISTS (SELECT schema_name', 'FROM information_schema.schemata', 'WHERE schema_name =', wrapSingleQuote(schema), ')', 'BEGIN', \"EXEC sp_executesql N'CREATE SCHEMA\", this.quoteIdentifier(schema), \";'\", 'END;'].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return ['IF EXISTS (SELECT schema_name', 'FROM information_schema.schemata', 'WHERE schema_name =', quotedSchema, ')', 'BEGIN', 'DECLARE @id INT, @ms_sql NVARCHAR(2000);', 'DECLARE @cascade TABLE (', 'id INT NOT NULL IDENTITY PRIMARY KEY,', 'ms_sql NVARCHAR(2000) NOT NULL );', 'INSERT INTO @cascade ( ms_sql )', \"SELECT CASE WHEN o.type IN ('F','PK')\", \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\", \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\", 'FROM sys.objects o', 'JOIN sys.schemas s on o.schema_id = s.schema_id', 'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id', \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema, 'ORDER BY o.type ASC;', 'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;', 'WHILE @id IS NOT NULL', 'BEGIN', 'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY', 'BEGIN CATCH BREAK; THROW; END CATCH;', 'DELETE FROM @cascade WHERE id = @id;', 'SELECT @id = NULL, @ms_sql = NULL;', 'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;', 'END', \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\", 'END;'].join(' ');\n  }\n\n  showSchemasQuery() {\n    return ['SELECT \"name\" as \"schema_name\" FROM sys.schemas as s', 'WHERE \"s\".\"name\" NOT IN (', \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\", ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return ['DECLARE @ms_ver NVARCHAR(20);', \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\", \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const query = (table, attrs) => `IF OBJECT_ID('${table}', 'U') IS NULL CREATE TABLE ${table} (${attrs})`,\n          primaryKeys = [],\n          foreignKeys = {},\n          attrStr = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr); // remove comment related substring from dataType\n\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n\n          attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `${query(this.quoteTable(tableName), attributesClause)};${commentStr}`;\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = ['SELECT', \"c.COLUMN_NAME AS 'Name',\", \"c.DATA_TYPE AS 'Type',\", \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\", \"c.IS_NULLABLE as 'IsNull',\", \"COLUMN_DEFAULT AS 'Default',\", \"pk.CONSTRAINT_TYPE AS 'Constraint',\", \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\", \"prop.value AS 'Comment'\", 'FROM', 'INFORMATION_SCHEMA.TABLES t', 'INNER JOIN', 'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA', 'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ', 'cu.column_name, tc.constraint_type ', 'FROM information_schema.TABLE_CONSTRAINTS tc ', 'JOIN information_schema.KEY_COLUMN_USAGE  cu ', 'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ', 'and tc.constraint_name=cu.constraint_name ', 'and tc.constraint_type=\\'PRIMARY KEY\\') pk ', 'ON pk.table_schema=c.table_schema ', 'AND pk.table_name=c.table_name ', 'AND pk.column_name=c.column_name ', 'INNER JOIN sys.columns AS sc', \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\", 'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id', 'AND prop.minor_id = sc.column_id', \"AND prop.name = 'MS_Description'\", 'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  dropTableQuery(tableName) {\n    const qouteTbl = this.quoteTable(tableName);\n    return `IF OBJECT_ID('${qouteTbl}', 'U') IS NOT NULL DROP TABLE ${qouteTbl};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key); // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n\n      delete dataType['comment'];\n    }\n\n    const def = this.attributeToSQL(dataType, {\n      context: 'addColumn'\n    });\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${def};${commentStr}`;\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' + `@name = N'MS_Description', @value = ${this.escape(comment)}, ` + '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' + `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` + `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP COLUMN ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n          constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName); // remove comment related substring from dataType\n\n        definition = commentMatch[1];\n      }\n\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};${commentString}`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `EXEC sp_rename '${this.quoteTable(tableName)}.${attrBefore}', '${newName}', 'COLUMN';`;\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n    let needIdentityInsertWrapper = false,\n        outputFragment = '';\n\n    if (options.returning) {\n      outputFragment = ' OUTPUT INSERTED.*';\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      } // normal case\n\n\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement) return;\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${allAttributes.map(key => this.escape(attrValueHash[key])).join(',')})`);\n      });\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false; //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    } //Add unique indexes defined by indexes option to uniqueAttrs\n\n\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n\n    let joinCondition; //IDENTITY_INSERT Condition\n\n    identityAttrs.forEach(key => {\n      if (updateValues[key] && updateValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    }); //Filter NULL Clauses\n\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n\n      return valid;\n    });\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    } // Remove the IDENTITY_INSERT Column from update\n\n\n    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key)).map(key => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    }).join(', ');\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    let limit = '';\n\n    if (options.limit) {\n      limit = ` TOP(${this.escape(options.limit)})`;\n    }\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    return `DELETE${limit} FROM ${table}${whereClause}; SELECT @@ROWCOUNT AS AFFECTEDROWS;`;\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    } // handle self referential constraints\n\n\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, ' + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values; // enums are a special case\n\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ')}))`;\n      return template;\n    }\n\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    } // Blobs/texts cannot have a defaultValue\n\n\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n          existingConstraints = [];\n    let key, attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString()); // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n\n          attribute.onUpdate = '';\n        }\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n\n\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${'SELECT ' + 'constraint_name = OBJ.NAME, ' + 'constraintName = OBJ.NAME, '}${catalogName ? `constraintCatalog = '${catalogName}', ` : ''}constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` + 'tableName = TB.NAME, ' + `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${catalogName ? `tableCatalog = '${catalogName}', ` : ''}columnName = COL.NAME, ` + `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${catalogName ? `referencedCatalog = '${catalogName}', ` : ''}referencedTableName = RTB.NAME, ` + 'referencedColumnName = RCOL.NAME ' + 'FROM sys.foreign_key_columns FKC ' + 'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' + 'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' + 'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' + 'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' + 'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|Object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n\n\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)} WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix()} WHERE TB.NAME =${wrapSingleQuote(tableName)} AND COL.NAME =${wrapSingleQuote(attributeName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n\n    return sql;\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return ['SELECT K.TABLE_NAME AS tableName,', 'K.COLUMN_NAME AS columnName,', 'K.CONSTRAINT_NAME AS constraintName', 'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C', 'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K', 'ON C.TABLE_NAME = K.TABLE_NAME', 'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG', 'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA', 'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME', 'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'', `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`, `AND K.TABLE_NAME = ${tableName};`].join(' ');\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(foreignKey)}`;\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return 'SELECT name FROM sys.default_constraints ' + `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U') ` + `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}') ` + `AND object_id = OBJECT_ID('${quotedTable}', 'U'));`;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(constraintName)};`;\n  }\n\n  setIsolationLevelQuery() {}\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    let topFragment = '';\n    let mainFragment = `SELECT ${attributes.join(', ')} FROM ${tables}`; // Handle SQL Server 2008 with TOP instead of LIMIT\n\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      if (options.limit) {\n        topFragment = `TOP ${options.limit} `;\n      }\n\n      if (options.offset) {\n        const offset = options.offset || 0,\n              isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n        let orders = {\n          mainQueryOrder: []\n        };\n\n        if (options.order) {\n          orders = this.getQueryOrders(options, model, isSubQuery);\n        }\n\n        if (!orders.mainQueryOrder.length) {\n          orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n        }\n\n        const tmpTable = mainTableAs ? mainTableAs : 'OffsetTable';\n        const whereFragment = where ? ` WHERE ${where}` : '';\n        /*\n         * For earlier versions of SQL server, we need to nest several queries\n         * in order to emulate the OFFSET behavior.\n         *\n         * 1. The outermost query selects all items from the inner query block.\n         *    This is due to a limitation in SQL server with the use of computed\n         *    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n         * 2. The next query handles the LIMIT and OFFSET behavior by getting\n         *    the TOP N rows of the query where the row number is > OFFSET\n         * 3. The innermost query is the actual set we want information from\n         */\n\n        const fragment = `SELECT TOP 100 PERCENT ${attributes.join(', ')} FROM ` + `(SELECT ${topFragment}*` + ` FROM (SELECT ROW_NUMBER() OVER (ORDER BY ${orders.mainQueryOrder.join(', ')}) as row_num, * ` + ` FROM ${tables} AS ${tmpTable}${whereFragment})` + ` AS ${tmpTable} WHERE row_num > ${offset})` + ` AS ${tmpTable}`;\n        return fragment;\n      }\n\n      mainFragment = `SELECT ${topFragment}${attributes.join(', ')} FROM ${tables}`;\n    }\n\n    if (mainTableAs) {\n      mainFragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.tableHint && TableHints[options.tableHint]) {\n      mainFragment += ` WITH (${TableHints[options.tableHint]})`;\n    }\n\n    return mainFragment;\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!options.order || options.include && !orders.subQueryOrder.length) {\n        fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n        fragment += `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n} // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/sequelize/lib/dialects/mssql/query-generator.js"],"names":["_","require","Utils","DataTypes","TableHints","AbstractQueryGenerator","randomBytes","semver","Op","throwMethodUndefined","methodName","Error","MSSQLQueryGenerator","createDatabaseQuery","databaseName","options","Object","assign","collate","collation","escape","wrapSingleQuote","quoteIdentifier","join","dropDatabaseQuery","createSchema","schema","dropSchema","quotedSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","query","table","attrs","primaryKeys","foreignKeys","attrStr","commentStr","attr","prototype","hasOwnProperty","call","dataType","match","includes","commentMatch","commentText","replace","trim","commentTemplate","push","attributesClause","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","quoteTable","describeTableQuery","sql","renameTableQuery","before","after","showTablesQuery","dropTableQuery","qouteTbl","addColumnQuery","key","comment","isString","def","attributeToSQL","context","column","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","commentString","quotedAttrName","definition","finalQuery","renameColumnQuery","attrBefore","newName","keys","bulkInsertQuery","attrValueHashes","quotedTable","tuples","allAttributes","allQueries","needIdentityInsertWrapper","outputFragment","returning","emptyQuery","forEach","attrValueHash","firstAttr","autoIncrement","forOwn","value","quotedAttributes","tupleStr","commands","offset","batch","Math","floor","max","slice","min","generatedQuery","v","updateQuery","where","limit","updateArgs","upsertQuery","insertValues","updateValues","model","targetTableAlias","sourceTableAlias","primaryKeysAttrs","identityAttrs","uniqueAttrs","tableNameQuoted","rawAttributes","primaryKey","unique","index","_indexes","fieldName","name","attribute","updateKeys","insertKeys","insertKeysQuoted","insertValuesEscaped","sourceTableQuery","joinCondition","clauses","or","filter","clause","valid","getJoinSnippet","array","updateSnippet","insertSnippet","truncateTableQuery","deleteQuery","whereClause","getWhereConditions","showIndexesQuery","showConstraintsQuery","removeIndexQuery","indexNameOrAttributes","underscore","quoteIdentifiers","isPlainObject","type","references","Model","sequelize","log","onDelete","onUpdate","template","ENUM","values","toSql","toString","allowNull","defaultValueSchemable","defaultValue","_binary","toUpperCase","attributesToSQL","result","existingConstraints","createTrigger","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","_getForeignKeysQueryPrefix","catalogName","getForeignKeysQuery","getForeignKeyQuery","getPrimaryKeyConstraintQuery","dropForeignKeyQuery","foreignKey","getDefaultConstraintQuery","dropConstraintQuery","constraintName","setIsolationLevelQuery","generateTransactionId","startTransactionQuery","transaction","parent","commitTransactionQuery","rollbackTransactionQuery","selectFromTableFragment","tables","mainTableAs","topFragment","mainFragment","databaseVersion","lt","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","mainQueryOrder","order","getQueryOrders","primaryKeyField","tmpTable","whereFragment","fragment","tableHint","addLimitAndOffset","subQuery","undefined","include","subQueryOrder","tableAs","booleanValue","identifier","addTicks","removeTicks","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst TableHints = require('../../table-hints');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst semver = require('semver');\nconst Op = require('../../operators');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      collate: null\n    }, options || {});\n\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;'\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;'\n    ].join(' ');\n  }\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"\n    ].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const query = (table, attrs) => `IF OBJECT_ID('${table}', 'U') IS NULL CREATE TABLE ${table} (${attrs})`,\n      primaryKeys = [],\n      foreignKeys = {},\n      attrStr = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return `${query(this.quoteTable(tableName), attributesClause)};${commentStr}`;\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"prop.value AS 'Comment'\",\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.constraint_type ',\n      'FROM information_schema.TABLE_CONSTRAINTS tc ',\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.constraint_type=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'INNER JOIN sys.columns AS sc',\n      \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\",\n      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',\n      'AND prop.minor_id = sc.column_id',\n      \"AND prop.name = 'MS_Description'\",\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  dropTableQuery(tableName) {\n    const qouteTbl = this.quoteTable(tableName);\n    return `IF OBJECT_ID('${qouteTbl}', 'U') IS NOT NULL DROP TABLE ${qouteTbl};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType['comment'];\n    }\n\n    const def = this.attributeToSQL(dataType, {\n      context: 'addColumn'\n    });\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${def};${commentStr}`;\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' +\n        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +\n        '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' +\n        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +\n        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP COLUMN ${this.quoteIdentifier(attributeName)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n      constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};${commentString}`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `EXEC sp_rename '${this.quoteTable(tableName)}.${attrBefore}', '${newName}', 'COLUMN';`;\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n\n\n    let needIdentityInsertWrapper = false,\n      outputFragment = '';\n\n    if (options.returning) {\n      outputFragment = ' OUTPUT INSERTED.*';\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key])).join(',')\n        })`);\n      });\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //IDENTITY_INSERT Condition\n    identityAttrs.forEach(key => {\n      if (updateValues[key] && updateValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    });\n\n    //Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      }).join(', ');\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    let limit = '';\n\n    if (options.limit) {\n      limit = ` TOP(${this.escape(options.limit)})`;\n    }\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    return `DELETE${limit} FROM ${table}${whereClause}; SELECT @@ROWCOUNT AS AFFECTEDROWS;`;\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references) {\n\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ') }))`;\n      return template;\n    }\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${'SELECT ' +\n        'constraint_name = OBJ.NAME, ' +\n        'constraintName = OBJ.NAME, '}${\n      catalogName ? `constraintCatalog = '${catalogName}', ` : ''\n    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +\n        'tableName = TB.NAME, ' +\n        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${\n          catalogName ? `tableCatalog = '${catalogName}', ` : ''\n        }columnName = COL.NAME, ` +\n        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${\n          catalogName ? `referencedCatalog = '${catalogName}', ` : ''\n        }referencedTableName = RTB.NAME, ` +\n        'referencedColumnName = RCOL.NAME ' +\n      'FROM sys.foreign_key_columns FKC ' +\n        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +\n        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +\n        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +\n        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +\n        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|Object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix()\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)\n    } AND COL.NAME =${wrapSingleQuote(attributeName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n\n    return sql;\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName};`\n    ].join(' ');\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(foreignKey)}`;\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return 'SELECT name FROM sys.default_constraints ' +\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U') ` +\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}') ` +\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'));`;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(constraintName)};`;\n  }\n\n  setIsolationLevelQuery() {\n\n  }\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    let topFragment = '';\n    let mainFragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    // Handle SQL Server 2008 with TOP instead of LIMIT\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      if (options.limit) {\n        topFragment = `TOP ${options.limit} `;\n      }\n      if (options.offset) {\n        const offset = options.offset || 0,\n          isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n        let orders = { mainQueryOrder: [] };\n        if (options.order) {\n          orders = this.getQueryOrders(options, model, isSubQuery);\n        }\n\n        if (!orders.mainQueryOrder.length) {\n          orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n        }\n\n        const tmpTable = mainTableAs ? mainTableAs : 'OffsetTable';\n        const whereFragment = where ? ` WHERE ${where}` : '';\n\n        /*\n         * For earlier versions of SQL server, we need to nest several queries\n         * in order to emulate the OFFSET behavior.\n         *\n         * 1. The outermost query selects all items from the inner query block.\n         *    This is due to a limitation in SQL server with the use of computed\n         *    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n         * 2. The next query handles the LIMIT and OFFSET behavior by getting\n         *    the TOP N rows of the query where the row number is > OFFSET\n         * 3. The innermost query is the actual set we want information from\n         */\n        const fragment = `SELECT TOP 100 PERCENT ${attributes.join(', ')} FROM ` +\n                        `(SELECT ${topFragment}*` +\n                          ` FROM (SELECT ROW_NUMBER() OVER (ORDER BY ${orders.mainQueryOrder.join(', ')}) as row_num, * ` +\n                            ` FROM ${tables} AS ${tmpTable}${whereFragment})` +\n                          ` AS ${tmpTable} WHERE row_num > ${offset})` +\n                        ` AS ${tmpTable}`;\n        return fragment;\n      }\n      mainFragment = `SELECT ${topFragment}${attributes.join(', ')} FROM ${tables}`;\n    }\n\n    if (mainTableAs) {\n      mainFragment += ` AS ${mainTableAs}`;\n    }\n\n    if (options.tableHint && TableHints[options.tableHint]) {\n      mainFragment += ` WITH (${TableHints[options.tableHint]})`;\n    }\n\n    return mainFragment;\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!options.order || options.include && !orders.subQueryOrder.length) {\n        fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n        fragment += `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}