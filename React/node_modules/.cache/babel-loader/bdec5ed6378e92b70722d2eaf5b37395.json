{"ast":null,"code":"\"use strict\";\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\n\nclass DoublyLinkedListIterator {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  constructor(doublyLinkedList, reverse) {\n    this._list = doublyLinkedList; // NOTE: these key names are tied to the DoublyLinkedListIterator\n\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n\n  _start() {\n    this._cursor = this._list[this._startPosition];\n    this._started = true;\n  }\n\n  _advanceCursor() {\n    if (this._started === false) {\n      this._started = true;\n      this._cursor = this._list[this._startPosition];\n      return;\n    }\n\n    this._cursor = this._cursor[this._direction];\n  }\n\n  reset() {\n    this._done = false;\n    this._started = false;\n    this._cursor = null;\n  }\n\n  remove() {\n    if (this._started === false || this._done === true || this._isCursorDetached()) {\n      return false;\n    }\n\n    this._list.remove(this._cursor);\n  }\n\n  next() {\n    if (this._done === true) {\n      return {\n        done: true\n      };\n    }\n\n    this._advanceCursor(); // if there is no node at the cursor or the node at the cursor is no longer part of\n    // a doubly linked list then we are done/finished/kaput\n\n\n    if (this._cursor === null || this._isCursorDetached()) {\n      this._done = true;\n      return {\n        done: true\n      };\n    }\n\n    return {\n      value: this._cursor,\n      done: false\n    };\n  }\n  /**\n   * Is the node detached from a list?\n   * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n   * and adding it to another.\n   * TODO: We can make this smarter by checking the direction of travel and only checking\n   * the required next/prev/head/tail rather than all of them\n   * @return {Boolean}      [description]\n   */\n\n\n  _isCursorDetached() {\n    return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;\n  }\n\n}\n\nmodule.exports = DoublyLinkedListIterator;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/generic-pool/lib/DoublyLinkedListIterator.js"],"names":["DoublyLinkedListIterator","constructor","doublyLinkedList","reverse","_list","_direction","_startPosition","_started","_cursor","_done","_start","_advanceCursor","reset","remove","_isCursorDetached","next","done","value","prev","tail","head","module","exports"],"mappings":"AAAA;AAEA;;;;;;;;;;;;;;AAaA,MAAMA,wBAAN,CAA+B;AAC7B;;;;AAIAC,EAAAA,WAAW,CAACC,gBAAD,EAAmBC,OAAnB,EAA4B;AACrC,SAAKC,KAAL,GAAaF,gBAAb,CADqC,CAErC;;AACA,SAAKG,UAAL,GAAkBF,OAAO,KAAK,IAAZ,GAAmB,MAAnB,GAA4B,MAA9C;AACA,SAAKG,cAAL,GAAsBH,OAAO,KAAK,IAAZ,GAAmB,MAAnB,GAA4B,MAAlD;AACA,SAAKI,QAAL,GAAgB,KAAhB;AACA,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKC,KAAL,GAAa,KAAb;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACP,SAAKF,OAAL,GAAe,KAAKJ,KAAL,CAAW,KAAKE,cAAhB,CAAf;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACD;;AAEDI,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKJ,QAAL,KAAkB,KAAtB,EAA6B;AAC3B,WAAKA,QAAL,GAAgB,IAAhB;AACA,WAAKC,OAAL,GAAe,KAAKJ,KAAL,CAAW,KAAKE,cAAhB,CAAf;AACA;AACD;;AACD,SAAKE,OAAL,GAAe,KAAKA,OAAL,CAAa,KAAKH,UAAlB,CAAf;AACD;;AAEDO,EAAAA,KAAK,GAAG;AACN,SAAKH,KAAL,GAAa,KAAb;AACA,SAAKF,QAAL,GAAgB,KAAhB;AACA,SAAKC,OAAL,GAAe,IAAf;AACD;;AAEDK,EAAAA,MAAM,GAAG;AACP,QACE,KAAKN,QAAL,KAAkB,KAAlB,IACA,KAAKE,KAAL,KAAe,IADf,IAEA,KAAKK,iBAAL,EAHF,EAIE;AACA,aAAO,KAAP;AACD;;AACD,SAAKV,KAAL,CAAWS,MAAX,CAAkB,KAAKL,OAAvB;AACD;;AAEDO,EAAAA,IAAI,GAAG;AACL,QAAI,KAAKN,KAAL,KAAe,IAAnB,EAAyB;AACvB,aAAO;AAAEO,QAAAA,IAAI,EAAE;AAAR,OAAP;AACD;;AAED,SAAKL,cAAL,GALK,CAOL;AACA;;;AACA,QAAI,KAAKH,OAAL,KAAiB,IAAjB,IAAyB,KAAKM,iBAAL,EAA7B,EAAuD;AACrD,WAAKL,KAAL,GAAa,IAAb;AACA,aAAO;AAAEO,QAAAA,IAAI,EAAE;AAAR,OAAP;AACD;;AAED,WAAO;AACLC,MAAAA,KAAK,EAAE,KAAKT,OADP;AAELQ,MAAAA,IAAI,EAAE;AAFD,KAAP;AAID;AAED;;;;;;;;;;AAQAF,EAAAA,iBAAiB,GAAG;AAClB,WACE,KAAKN,OAAL,CAAaU,IAAb,KAAsB,IAAtB,IACA,KAAKV,OAAL,CAAaO,IAAb,KAAsB,IADtB,IAEA,KAAKX,KAAL,CAAWe,IAAX,KAAoB,KAAKX,OAFzB,IAGA,KAAKJ,KAAL,CAAWgB,IAAX,KAAoB,KAAKZ,OAJ3B;AAMD;;AAjF4B;;AAoF/Ba,MAAM,CAACC,OAAP,GAAiBtB,wBAAjB","sourcesContent":["\"use strict\";\n\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\nclass DoublyLinkedListIterator {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  constructor(doublyLinkedList, reverse) {\n    this._list = doublyLinkedList;\n    // NOTE: these key names are tied to the DoublyLinkedListIterator\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n\n  _start() {\n    this._cursor = this._list[this._startPosition];\n    this._started = true;\n  }\n\n  _advanceCursor() {\n    if (this._started === false) {\n      this._started = true;\n      this._cursor = this._list[this._startPosition];\n      return;\n    }\n    this._cursor = this._cursor[this._direction];\n  }\n\n  reset() {\n    this._done = false;\n    this._started = false;\n    this._cursor = null;\n  }\n\n  remove() {\n    if (\n      this._started === false ||\n      this._done === true ||\n      this._isCursorDetached()\n    ) {\n      return false;\n    }\n    this._list.remove(this._cursor);\n  }\n\n  next() {\n    if (this._done === true) {\n      return { done: true };\n    }\n\n    this._advanceCursor();\n\n    // if there is no node at the cursor or the node at the cursor is no longer part of\n    // a doubly linked list then we are done/finished/kaput\n    if (this._cursor === null || this._isCursorDetached()) {\n      this._done = true;\n      return { done: true };\n    }\n\n    return {\n      value: this._cursor,\n      done: false\n    };\n  }\n\n  /**\n   * Is the node detached from a list?\n   * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n   * and adding it to another.\n   * TODO: We can make this smarter by checking the direction of travel and only checking\n   * the required next/prev/head/tail rather than all of them\n   * @return {Boolean}      [description]\n   */\n  _isCursorDetached() {\n    return (\n      this._cursor.prev === null &&\n      this._cursor.next === null &&\n      this._list.tail !== this._cursor &&\n      this._list.head !== this._cursor\n    );\n  }\n}\n\nmodule.exports = DoublyLinkedListIterator;\n"]},"metadata":{},"sourceType":"script"}