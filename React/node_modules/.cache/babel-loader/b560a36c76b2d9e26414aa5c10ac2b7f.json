{"ast":null,"code":"var Libpq = require('libpq');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar assert = require('assert');\n\nvar types = require('pg-types');\n\nvar buildResult = require('./lib/build-result');\n\nvar CopyStream = require('./lib/copy-stream');\n\nvar Client = module.exports = function (config) {\n  if (!(this instanceof Client)) {\n    return new Client(config);\n  }\n\n  config = config || {};\n  EventEmitter.call(this);\n  this.pq = new Libpq();\n  this._reading = false;\n  this._read = this._read.bind(this); // allow custom type converstion to be passed in\n\n  this._types = config.types || types; // allow config to specify returning results\n  // as an array of values instead of a hash\n\n  this.arrayMode = config.arrayMode || false;\n  this._resultCount = 0;\n  this._rows = undefined;\n  this._results = undefined; // lazy start the reader if notifications are listened for\n  // this way if you only run sync queries you wont block\n  // the event loop artificially\n\n  this.on('newListener', event => {\n    if (event !== 'notification') return;\n\n    this._startReading();\n  });\n  this.on('result', this._onResult.bind(this));\n  this.on('readyForQuery', this._onReadyForQuery.bind(this));\n};\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype.connect = function (params, cb) {\n  this.pq.connect(params, cb);\n};\n\nClient.prototype.connectSync = function (params) {\n  this.pq.connectSync(params);\n};\n\nClient.prototype.query = function (text, values, cb) {\n  var queryFn;\n\n  if (typeof values === 'function') {\n    cb = values;\n\n    queryFn = function () {\n      return self.pq.sendQuery(text);\n    };\n  } else {\n    queryFn = function () {\n      return self.pq.sendQueryParams(text, values);\n    };\n  }\n\n  var self = this;\n\n  self._dispatchQuery(self.pq, queryFn, function (err) {\n    if (err) return cb(err);\n\n    self._awaitResult(cb);\n  });\n};\n\nClient.prototype.prepare = function (statementName, text, nParams, cb) {\n  var self = this;\n\n  var fn = function () {\n    return self.pq.sendPrepare(statementName, text, nParams);\n  };\n\n  self._dispatchQuery(self.pq, fn, function (err) {\n    if (err) return cb(err);\n\n    self._awaitResult(cb);\n  });\n};\n\nClient.prototype.execute = function (statementName, parameters, cb) {\n  var self = this;\n\n  var fn = function () {\n    return self.pq.sendQueryPrepared(statementName, parameters);\n  };\n\n  self._dispatchQuery(self.pq, fn, function (err, rows) {\n    if (err) return cb(err);\n\n    self._awaitResult(cb);\n  });\n};\n\nClient.prototype.getCopyStream = function () {\n  this.pq.setNonBlocking(true);\n\n  this._stopReading();\n\n  return new CopyStream(this.pq);\n}; // cancel a currently executing query\n\n\nClient.prototype.cancel = function (cb) {\n  assert(cb, 'Callback is required'); // result is either true or a string containing an error\n\n  var result = this.pq.cancel();\n  return setImmediate(function () {\n    cb(result === true ? undefined : new Error(result));\n  });\n};\n\nClient.prototype.querySync = function (text, values) {\n  if (values) {\n    this.pq.execParams(text, values);\n  } else {\n    this.pq.exec(text);\n  }\n\n  throwIfError(this.pq);\n  const result = buildResult(this.pq, this._types, this.arrayMode);\n  return result.rows;\n};\n\nClient.prototype.prepareSync = function (statementName, text, nParams) {\n  this.pq.prepare(statementName, text, nParams);\n  throwIfError(this.pq);\n};\n\nClient.prototype.executeSync = function (statementName, parameters) {\n  this.pq.execPrepared(statementName, parameters);\n  throwIfError(this.pq);\n  return buildResult(this.pq, this._types, this.arrayMode).rows;\n};\n\nClient.prototype.escapeLiteral = function (value) {\n  return this.pq.escapeLiteral(value);\n};\n\nClient.prototype.escapeIdentifier = function (value) {\n  return this.pq.escapeIdentifier(value);\n}; // export the version number so we can check it in node-postgres\n\n\nmodule.exports.version = require('./package.json').version;\n\nClient.prototype.end = function (cb) {\n  this._stopReading();\n\n  this.pq.finish();\n  if (cb) setImmediate(cb);\n};\n\nClient.prototype._readError = function (message) {\n  var err = new Error(message || this.pq.errorMessage());\n  this.emit('error', err);\n};\n\nClient.prototype._stopReading = function () {\n  if (!this._reading) return;\n  this._reading = false;\n  this.pq.stopReader();\n  this.pq.removeListener('readable', this._read);\n};\n\nClient.prototype._consumeQueryResults = function (pq) {\n  return buildResult(pq, this._types, this.arrayMode);\n};\n\nClient.prototype._emitResult = function (pq) {\n  var status = pq.resultStatus();\n\n  switch (status) {\n    case 'PGRES_FATAL_ERROR':\n      this._queryError = new Error(this.pq.resultErrorMessage());\n      break;\n\n    case 'PGRES_TUPLES_OK':\n    case 'PGRES_COMMAND_OK':\n    case 'PGRES_EMPTY_QUERY':\n      const result = this._consumeQueryResults(this.pq);\n\n      this.emit('result', result);\n      break;\n\n    case 'PGRES_COPY_OUT':\n    case 'PGRES_COPY_BOTH':\n      {\n        break;\n      }\n\n    default:\n      this._readError('unrecognized command status: ' + status);\n\n      break;\n  }\n\n  return status;\n}; // called when libpq is readable\n\n\nClient.prototype._read = function () {\n  var pq = this.pq; // read waiting data from the socket\n  // e.g. clear the pending 'select'\n\n  if (!pq.consumeInput()) {\n    // if consumeInput returns false\n    // than a read error has been encountered\n    return this._readError();\n  } // check if there is still outstanding data\n  // if so, wait for it all to come in\n\n\n  if (pq.isBusy()) {\n    return;\n  } // load our result object\n\n\n  while (pq.getResult()) {\n    const resultStatus = this._emitResult(this.pq); // if the command initiated copy mode we need to break out of the read loop\n    // so a substream can begin to read copy data\n\n\n    if (resultStatus === 'PGRES_COPY_BOTH' || resultStatus === 'PGRES_COPY_OUT') {\n      break;\n    } // if reading multiple results, sometimes the following results might cause\n    // a blocking read. in this scenario yield back off the reader until libpq is readable\n\n\n    if (pq.isBusy()) {\n      return;\n    }\n  }\n\n  this.emit('readyForQuery');\n  var notice = this.pq.notifies();\n\n  while (notice) {\n    this.emit('notification', notice);\n    notice = this.pq.notifies();\n  }\n}; // ensures the client is reading and\n// everything is set up for async io\n\n\nClient.prototype._startReading = function () {\n  if (this._reading) return;\n  this._reading = true;\n  this.pq.on('readable', this._read);\n  this.pq.startReader();\n};\n\nvar throwIfError = function (pq) {\n  var err = pq.resultErrorMessage() || pq.errorMessage();\n\n  if (err) {\n    throw new Error(err);\n  }\n};\n\nClient.prototype._awaitResult = function (cb) {\n  this._queryCallback = cb;\n  return this._startReading();\n}; // wait for the writable socket to drain\n\n\nClient.prototype._waitForDrain = function (pq, cb) {\n  var res = pq.flush(); // res of 0 is success\n\n  if (res === 0) return cb(); // res of -1 is failure\n\n  if (res === -1) return cb(pq.errorMessage()); // otherwise outgoing message didn't flush to socket\n  // wait for it to flush and try again\n\n  var self = this; // you cannot read & write on a socket at the same time\n\n  return pq.writable(function () {\n    self._waitForDrain(pq, cb);\n  });\n}; // send an async query to libpq and wait for it to\n// finish writing query text to the socket\n\n\nClient.prototype._dispatchQuery = function (pq, fn, cb) {\n  this._stopReading();\n\n  var success = pq.setNonBlocking(true);\n  if (!success) return cb(new Error('Unable to set non-blocking to true'));\n  var sent = fn();\n  if (!sent) return cb(new Error(pq.errorMessage() || 'Something went wrong dispatching the query'));\n\n  this._waitForDrain(pq, cb);\n};\n\nClient.prototype._onResult = function (result) {\n  if (this._resultCount === 0) {\n    this._results = result;\n    this._rows = result.rows;\n  } else if (this._resultCount === 1) {\n    this._results = [this._results, result];\n    this._rows = [this._rows, result.rows];\n  } else {\n    this._results.push(result);\n\n    this._rows.push(result.rows);\n  }\n\n  this._resultCount++;\n};\n\nClient.prototype._onReadyForQuery = function () {\n  // remove instance callback\n  const cb = this._queryCallback;\n  this._queryCallback = undefined; // remove instance query error\n\n  const err = this._queryError;\n  this._queryError = undefined; // remove instance rows\n\n  const rows = this._rows;\n  this._rows = undefined; // remove instance results\n\n  const results = this._results;\n  this._results = undefined;\n  this._resultCount = 0;\n\n  if (cb) {\n    cb(err, rows || [], results);\n  }\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp5/expresstimes/node_modules/pg-native/index.js"],"names":["Libpq","require","EventEmitter","util","assert","types","buildResult","CopyStream","Client","module","exports","config","call","pq","_reading","_read","bind","_types","arrayMode","_resultCount","_rows","undefined","_results","on","event","_startReading","_onResult","_onReadyForQuery","inherits","prototype","connect","params","cb","connectSync","query","text","values","queryFn","self","sendQuery","sendQueryParams","_dispatchQuery","err","_awaitResult","prepare","statementName","nParams","fn","sendPrepare","execute","parameters","sendQueryPrepared","rows","getCopyStream","setNonBlocking","_stopReading","cancel","result","setImmediate","Error","querySync","execParams","exec","throwIfError","prepareSync","executeSync","execPrepared","escapeLiteral","value","escapeIdentifier","version","end","finish","_readError","message","errorMessage","emit","stopReader","removeListener","_consumeQueryResults","_emitResult","status","resultStatus","_queryError","resultErrorMessage","consumeInput","isBusy","getResult","notice","notifies","startReader","_queryCallback","_waitForDrain","res","flush","writable","success","sent","push","results"],"mappings":"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","sourcesContent":["var Libpq = require('libpq')\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar assert = require('assert')\nvar types = require('pg-types')\nvar buildResult = require('./lib/build-result')\nvar CopyStream = require('./lib/copy-stream')\n\nvar Client = module.exports = function (config) {\n  if (!(this instanceof Client)) {\n    return new Client(config)\n  }\n\n  config = config || {}\n\n  EventEmitter.call(this)\n  this.pq = new Libpq()\n  this._reading = false\n  this._read = this._read.bind(this)\n\n  // allow custom type converstion to be passed in\n  this._types = config.types || types\n\n  // allow config to specify returning results\n  // as an array of values instead of a hash\n  this.arrayMode = config.arrayMode || false\n  this._resultCount = 0\n  this._rows = undefined\n  this._results = undefined\n\n  // lazy start the reader if notifications are listened for\n  // this way if you only run sync queries you wont block\n  // the event loop artificially\n  this.on('newListener', (event) => {\n    if (event !== 'notification') return\n    this._startReading()\n  })\n\n  this.on('result', this._onResult.bind(this))\n  this.on('readyForQuery', this._onReadyForQuery.bind(this))\n}\n\nutil.inherits(Client, EventEmitter)\n\nClient.prototype.connect = function (params, cb) {\n  this.pq.connect(params, cb)\n}\n\nClient.prototype.connectSync = function (params) {\n  this.pq.connectSync(params)\n}\n\nClient.prototype.query = function (text, values, cb) {\n  var queryFn\n\n  if (typeof values === 'function') {\n    cb = values\n    queryFn = function () { return self.pq.sendQuery(text) }\n  } else {\n    queryFn = function () { return self.pq.sendQueryParams(text, values) }\n  }\n\n  var self = this\n\n  self._dispatchQuery(self.pq, queryFn, function (err) {\n    if (err) return cb(err)\n\n    self._awaitResult(cb)\n  })\n}\n\nClient.prototype.prepare = function (statementName, text, nParams, cb) {\n  var self = this\n  var fn = function () {\n    return self.pq.sendPrepare(statementName, text, nParams)\n  }\n\n  self._dispatchQuery(self.pq, fn, function (err) {\n    if (err) return cb(err)\n    self._awaitResult(cb)\n  })\n}\n\nClient.prototype.execute = function (statementName, parameters, cb) {\n  var self = this\n\n  var fn = function () {\n    return self.pq.sendQueryPrepared(statementName, parameters)\n  }\n\n  self._dispatchQuery(self.pq, fn, function (err, rows) {\n    if (err) return cb(err)\n    self._awaitResult(cb)\n  })\n}\n\nClient.prototype.getCopyStream = function () {\n  this.pq.setNonBlocking(true)\n  this._stopReading()\n  return new CopyStream(this.pq)\n}\n\n// cancel a currently executing query\nClient.prototype.cancel = function (cb) {\n  assert(cb, 'Callback is required')\n  // result is either true or a string containing an error\n  var result = this.pq.cancel()\n  return setImmediate(function () {\n    cb(result === true ? undefined : new Error(result))\n  })\n}\n\nClient.prototype.querySync = function (text, values) {\n  if (values) {\n    this.pq.execParams(text, values)\n  } else {\n    this.pq.exec(text)\n  }\n\n  throwIfError(this.pq)\n  const result = buildResult(this.pq, this._types, this.arrayMode)\n  return result.rows\n}\n\nClient.prototype.prepareSync = function (statementName, text, nParams) {\n  this.pq.prepare(statementName, text, nParams)\n  throwIfError(this.pq)\n}\n\nClient.prototype.executeSync = function (statementName, parameters) {\n  this.pq.execPrepared(statementName, parameters)\n  throwIfError(this.pq)\n  return buildResult(this.pq, this._types, this.arrayMode).rows\n}\n\nClient.prototype.escapeLiteral = function (value) {\n  return this.pq.escapeLiteral(value)\n}\n\nClient.prototype.escapeIdentifier = function (value) {\n  return this.pq.escapeIdentifier(value)\n}\n\n// export the version number so we can check it in node-postgres\nmodule.exports.version = require('./package.json').version\n\nClient.prototype.end = function (cb) {\n  this._stopReading()\n  this.pq.finish()\n  if (cb) setImmediate(cb)\n}\n\nClient.prototype._readError = function (message) {\n  var err = new Error(message || this.pq.errorMessage())\n  this.emit('error', err)\n}\n\nClient.prototype._stopReading = function () {\n  if (!this._reading) return\n  this._reading = false\n  this.pq.stopReader()\n  this.pq.removeListener('readable', this._read)\n}\n\nClient.prototype._consumeQueryResults = function (pq) {\n  return buildResult(pq, this._types, this.arrayMode)\n}\n\nClient.prototype._emitResult = function (pq) {\n  var status = pq.resultStatus()\n  switch (status) {\n    case 'PGRES_FATAL_ERROR':\n      this._queryError = new Error(this.pq.resultErrorMessage())\n      break\n\n    case 'PGRES_TUPLES_OK':\n    case 'PGRES_COMMAND_OK':\n    case 'PGRES_EMPTY_QUERY':\n      const result = this._consumeQueryResults(this.pq)\n      this.emit('result', result)\n      break\n\n    case 'PGRES_COPY_OUT':\n    case 'PGRES_COPY_BOTH': {\n      break\n    }\n\n    default:\n      this._readError('unrecognized command status: ' + status)\n      break\n  }\n  return status\n}\n\n// called when libpq is readable\nClient.prototype._read = function () {\n  var pq = this.pq\n  // read waiting data from the socket\n  // e.g. clear the pending 'select'\n  if (!pq.consumeInput()) {\n    // if consumeInput returns false\n    // than a read error has been encountered\n    return this._readError()\n  }\n\n  // check if there is still outstanding data\n  // if so, wait for it all to come in\n  if (pq.isBusy()) {\n    return\n  }\n\n  // load our result object\n\n  while (pq.getResult()) {\n    const resultStatus = this._emitResult(this.pq)\n\n    // if the command initiated copy mode we need to break out of the read loop\n    // so a substream can begin to read copy data\n    if (resultStatus === 'PGRES_COPY_BOTH' || resultStatus === 'PGRES_COPY_OUT') {\n      break\n    }\n\n    // if reading multiple results, sometimes the following results might cause\n    // a blocking read. in this scenario yield back off the reader until libpq is readable\n    if (pq.isBusy()) {\n      return\n    }\n  }\n\n  this.emit('readyForQuery')\n\n  var notice = this.pq.notifies()\n  while (notice) {\n    this.emit('notification', notice)\n    notice = this.pq.notifies()\n  }\n}\n\n// ensures the client is reading and\n// everything is set up for async io\nClient.prototype._startReading = function () {\n  if (this._reading) return\n  this._reading = true\n  this.pq.on('readable', this._read)\n  this.pq.startReader()\n}\n\nvar throwIfError = function (pq) {\n  var err = pq.resultErrorMessage() || pq.errorMessage()\n  if (err) {\n    throw new Error(err)\n  }\n}\n\nClient.prototype._awaitResult = function (cb) {\n  this._queryCallback = cb\n  return this._startReading()\n}\n\n// wait for the writable socket to drain\nClient.prototype._waitForDrain = function (pq, cb) {\n  var res = pq.flush()\n  // res of 0 is success\n  if (res === 0) return cb()\n\n  // res of -1 is failure\n  if (res === -1) return cb(pq.errorMessage())\n\n  // otherwise outgoing message didn't flush to socket\n  // wait for it to flush and try again\n  var self = this\n  // you cannot read & write on a socket at the same time\n  return pq.writable(function () {\n    self._waitForDrain(pq, cb)\n  })\n}\n\n// send an async query to libpq and wait for it to\n// finish writing query text to the socket\nClient.prototype._dispatchQuery = function (pq, fn, cb) {\n  this._stopReading()\n  var success = pq.setNonBlocking(true)\n  if (!success) return cb(new Error('Unable to set non-blocking to true'))\n  var sent = fn()\n  if (!sent) return cb(new Error(pq.errorMessage() || 'Something went wrong dispatching the query'))\n  this._waitForDrain(pq, cb)\n}\n\nClient.prototype._onResult = function (result) {\n  if (this._resultCount === 0) {\n    this._results = result\n    this._rows = result.rows\n  } else if (this._resultCount === 1) {\n    this._results = [this._results, result]\n    this._rows = [this._rows, result.rows]\n  } else {\n    this._results.push(result)\n    this._rows.push(result.rows)\n  }\n  this._resultCount++\n}\n\nClient.prototype._onReadyForQuery = function () {\n  // remove instance callback\n  const cb = this._queryCallback\n  this._queryCallback = undefined\n\n  // remove instance query error\n  const err = this._queryError\n  this._queryError = undefined\n\n  // remove instance rows\n  const rows = this._rows\n  this._rows = undefined\n\n  // remove instance results\n  const results = this._results\n  this._results = undefined\n\n  this._resultCount = 0\n\n  if (cb) {\n    cb(err, rows || [], results)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}