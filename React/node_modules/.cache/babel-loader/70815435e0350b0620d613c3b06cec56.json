{"ast":null,"code":"\"use strict\";\n\nconst path = require(\"path\");\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\n\n\nconst looksLikeAbsolutePath = maybeAbsolutePath => {\n  if (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n    // this 'path' is actually a regexp generated by dynamic requires.\n    // Don't treat it as an absolute path.\n    return false;\n  }\n\n  return /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\n\n\nconst normalizePathSeparator = p => p.replace(/\\\\/g, \"/\");\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\n\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(/([|! ])/).map(str => looksLikeAbsolutePath(str) ? normalizePathSeparator(path.relative(context, str)) : str).join(\"\");\n};\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\n\n\nexports.makePathsRelative = (context, identifier, cache) => {\n  if (!cache) return _makePathsRelative(context, identifier);\n  const relativePaths = cache.relativePaths || (cache.relativePaths = new Map());\n  let cachedResult;\n  let contextCache = relativePaths.get(context);\n\n  if (contextCache === undefined) {\n    relativePaths.set(context, contextCache = new Map());\n  } else {\n    cachedResult = contextCache.get(identifier);\n  }\n\n  if (cachedResult !== undefined) {\n    return cachedResult;\n  } else {\n    const relativePath = _makePathsRelative(context, identifier);\n\n    contextCache.set(identifier, relativePath);\n    return relativePath;\n  }\n};\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\n\n\nexports.contextify = (context, request) => {\n  return request.split(\"!\").map(r => {\n    const splitPath = r.split(\"?\", 2);\n\n    if (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n      splitPath[0] = path.win32.relative(context, splitPath[0]);\n\n      if (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n        splitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n      }\n    }\n\n    if (/^\\//.test(splitPath[0])) {\n      splitPath[0] = path.posix.relative(context, splitPath[0]);\n    }\n\n    if (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n      splitPath[0] = \"./\" + splitPath[0];\n    }\n\n    return splitPath.join(\"?\");\n  }).join(\"!\");\n};","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/webpack/lib/util/identifier.js"],"names":["path","require","looksLikeAbsolutePath","maybeAbsolutePath","test","normalizePathSeparator","p","replace","_makePathsRelative","context","identifier","split","map","str","relative","join","exports","makePathsRelative","cache","relativePaths","Map","cachedResult","contextCache","get","undefined","set","relativePath","contextify","request","r","splitPath","win32","posix"],"mappings":"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","sourcesContent":["\"use strict\";\nconst path = require(\"path\");\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\nconst looksLikeAbsolutePath = maybeAbsolutePath => {\n\tif (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t// Don't treat it as an absolute path.\n\t\treturn false;\n\t}\n\treturn /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\nconst normalizePathSeparator = p => p.replace(/\\\\/g, \"/\");\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(/([|! ])/)\n\t\t.map(str =>\n\t\t\tlooksLikeAbsolutePath(str)\n\t\t\t\t? normalizePathSeparator(path.relative(context, str))\n\t\t\t\t: str\n\t\t)\n\t\t.join(\"\");\n};\n\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\nexports.makePathsRelative = (context, identifier, cache) => {\n\tif (!cache) return _makePathsRelative(context, identifier);\n\n\tconst relativePaths =\n\t\tcache.relativePaths || (cache.relativePaths = new Map());\n\n\tlet cachedResult;\n\tlet contextCache = relativePaths.get(context);\n\tif (contextCache === undefined) {\n\t\trelativePaths.set(context, (contextCache = new Map()));\n\t} else {\n\t\tcachedResult = contextCache.get(identifier);\n\t}\n\n\tif (cachedResult !== undefined) {\n\t\treturn cachedResult;\n\t} else {\n\t\tconst relativePath = _makePathsRelative(context, identifier);\n\t\tcontextCache.set(identifier, relativePath);\n\t\treturn relativePath;\n\t}\n};\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nexports.contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => {\n\t\t\tconst splitPath = r.split(\"?\", 2);\n\t\t\tif (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = path.win32.relative(context, splitPath[0]);\n\t\t\t\tif (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n\t\t\t\t\tsplitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (/^\\//.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = path.posix.relative(context, splitPath[0]);\n\t\t\t}\n\t\t\tif (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = \"./\" + splitPath[0];\n\t\t\t}\n\t\t\treturn splitPath.join(\"?\");\n\t\t})\n\t\t.join(\"!\");\n};\n"]},"metadata":{},"sourceType":"script"}