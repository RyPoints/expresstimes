{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\n\nvar Serializer =\n/** @class */\nfunction () {\n  function Serializer(modelMappers, isXML) {\n    if (modelMappers === void 0) {\n      modelMappers = {};\n    }\n\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n\n  Serializer.prototype.validateConstraints = function (mapper, value, objectName) {\n    var failValidation = function (constraintName, constraintValue) {\n      throw new Error(\"\\\"\" + objectName + \"\\\" with value \\\"\" + value + \"\\\" should satisfy the constraint \\\"\" + constraintName + \"\\\": \" + constraintValue + \".\");\n    };\n\n    if (mapper.constraints && value != undefined) {\n      var _a = mapper.constraints,\n          ExclusiveMaximum = _a.ExclusiveMaximum,\n          ExclusiveMinimum = _a.ExclusiveMinimum,\n          InclusiveMaximum = _a.InclusiveMaximum,\n          InclusiveMinimum = _a.InclusiveMinimum,\n          MaxItems = _a.MaxItems,\n          MaxLength = _a.MaxLength,\n          MinItems = _a.MinItems,\n          MinLength = _a.MinLength,\n          MultipleOf = _a.MultipleOf,\n          Pattern = _a.Pattern,\n          UniqueItems = _a.UniqueItems;\n\n      if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n\n      if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n\n      if (InclusiveMaximum != undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n\n      if (InclusiveMinimum != undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n\n      if (MaxItems != undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n\n      if (MaxLength != undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n\n      if (MinItems != undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n\n      if (MinLength != undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n\n      if (MultipleOf != undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n\n      if (Pattern && value.match(Pattern) === null) {\n        failValidation(\"Pattern\", Pattern);\n      }\n\n      if (UniqueItems && value.some(function (item, i, ar) {\n        return ar.indexOf(item) !== i;\n      })) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  };\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n   *\n   * @param {string} objectName Name of the serialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n   */\n\n\n  Serializer.prototype.serialize = function (mapper, object, objectName) {\n    var payload = {};\n    var mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Sequence$/ig) !== null) {\n      payload = [];\n    }\n\n    if (object == undefined && (mapper.defaultValue != undefined || mapper.isConstant)) {\n      object = mapper.defaultValue;\n    } // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n\n    var required = mapper.required,\n        nullable = mapper.nullable;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(objectName + \" cannot be undefined.\");\n    }\n\n    if (required && !nullable && object == undefined) {\n      throw new Error(objectName + \" cannot be null or undefined.\");\n    }\n\n    if (!required && nullable === false && object === null) {\n      throw new Error(objectName + \" cannot be null.\");\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n\n      if (mapperType.match(/^any$/ig) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/ig) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/ig) !== null) {\n        var enumMapper = mapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/ig) !== null) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/ig) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/ig) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/ig) !== null) {\n        payload = serializeSequenceType(this, mapper, object, objectName);\n      } else if (mapperType.match(/^Dictionary$/ig) !== null) {\n        payload = serializeDictionaryType(this, mapper, object, objectName);\n      } else if (mapperType.match(/^Composite$/ig) !== null) {\n        payload = serializeCompositeType(this, mapper, object, objectName);\n      }\n    }\n\n    return payload;\n  };\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param {object} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n   *\n   * @param {string} objectName Name of the deserialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n   */\n\n\n  Serializer.prototype.deserialize = function (mapper, responseBody, objectName) {\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n\n      return responseBody;\n    }\n\n    var payload;\n    var mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Composite$/ig) !== null) {\n      payload = deserializeCompositeType(this, mapper, responseBody, objectName);\n    } else {\n      if (this.isXML) {\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\") and body (\"_\") properties, then just reduce the responseBody value to\n         * the body (\"_\") property.\n         */\n        if (responseBody[\"$\"] != undefined && responseBody[\"_\"] != undefined) {\n          responseBody = responseBody[\"_\"];\n        }\n      }\n\n      if (mapperType.match(/^Number$/ig) !== null) {\n        payload = parseFloat(responseBody);\n\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/ig) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/ig) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/ig) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/ig) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/ig) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/ig) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/ig) !== null) {\n        payload = deserializeSequenceType(this, mapper, responseBody, objectName);\n      } else if (mapperType.match(/^Dictionary$/ig) !== null) {\n        payload = deserializeDictionaryType(this, mapper, responseBody, objectName);\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  };\n\n  return Serializer;\n}();\n\nexport { Serializer };\n\nfunction trimEnd(str, ch) {\n  var len = str.length;\n\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(\"Please provide an input of type Uint8Array for converting to Base64Url.\");\n  } // Uint8Array to Base64.\n\n\n  var str = base64.encodeByteArray(buffer); // Base64 to Base64Url.\n\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  } // Base64Url to Base64.\n\n\n  str = str.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\"); // Base64 to Uint8Array.\n\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop) {\n  var classes = [];\n  var partialclass = \"\";\n\n  if (prop) {\n    var subwords = prop.split(\".\");\n\n    for (var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {\n      var item = subwords_1[_i];\n\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n\n  return Math.floor(d.getTime() / 1000);\n}\n\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/ig) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type number.\");\n      }\n    } else if (typeName.match(/^String$/ig) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string.\");\n      }\n    } else if (typeName.match(/^Uuid$/ig) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string and a valid uuid.\");\n      }\n    } else if (typeName.match(/^Boolean$/ig) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type boolean.\");\n      }\n    } else if (typeName.match(/^Stream$/ig) !== null) {\n      var objectType = typeof value;\n\n      if (objectType !== \"string\" && objectType !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !(typeof Blob === \"function\" && value instanceof Blob)) {\n        throw new Error(objectName + \" must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.\");\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(\"Please provide a set of allowedValues to validate \" + objectName + \" as an Enum Type.\");\n  }\n\n  var isPresent = allowedValues.some(function (item) {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n\n    return item === value;\n  });\n\n  if (!isPresent) {\n    throw new Error(value + \" is not a valid value for \" + objectName + \". The valid values are: \" + JSON.stringify(allowedValues) + \".\");\n  }\n\n  return value;\n}\n\nfunction serializeByteArrayType(objectName, value) {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n\n    value = base64.encodeByteArray(value);\n  }\n\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName, value) {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n\n    value = bufferToBase64Url(value);\n  }\n\n  return value;\n}\n\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123 format.\");\n      }\n\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123/ISO8601 format \" + \"for it to be serialized in UnixTime/Epoch format.\");\n      }\n\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/ig) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(objectName + \" must be a string in ISO 8601 format. Instead was \\\"\" + value + \"\\\".\");\n      }\n\n      value = value;\n    }\n  }\n\n  return value;\n}\n\nfunction serializeSequenceType(serializer, mapper, object, objectName) {\n  if (!Array.isArray(object)) {\n    throw new Error(objectName + \" must be of type Array.\");\n  }\n\n  var elementType = mapper.type.element;\n\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n\n  var tempArray = [];\n\n  for (var i = 0; i < object.length; i++) {\n    tempArray[i] = serializer.serialize(elementType, object[i], objectName);\n  }\n\n  return tempArray;\n}\n\nfunction serializeDictionaryType(serializer, mapper, object, objectName) {\n  if (typeof object !== \"object\") {\n    throw new Error(objectName + \" must be of type object.\");\n  }\n\n  var valueType = mapper.type.value;\n\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n\n  var tempDictionary = {};\n\n  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {\n    var key = _a[_i];\n    tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + \".\" + key);\n  }\n\n  return tempDictionary;\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer the serializer containing the entire set of mappers\n * @param mapper the composite mapper to resolve\n */\n\n\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  var modelProps = mapper.type.modelProperties;\n\n  if (!modelProps) {\n    var className = mapper.type.className;\n\n    if (!className) {\n      throw new Error(\"Class name for model \\\"\" + objectName + \"\\\" is not provided in the mapper \\\"\" + JSON.stringify(mapper, undefined, 2) + \"\\\".\");\n    }\n\n    var modelMapper = serializer.modelMappers[className];\n\n    if (!modelMapper) {\n      throw new Error(\"mapper() cannot be null or undefined for model \\\"\" + className + \"\\\".\");\n    }\n\n    modelProps = modelMapper.type.modelProperties;\n\n    if (!modelProps) {\n      throw new Error(\"modelProperties cannot be null or undefined in the \" + (\"mapper \\\"\" + JSON.stringify(modelMapper) + \"\\\" of type \\\"\" + className + \"\\\" for object \\\"\" + objectName + \"\\\".\"));\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(serializer, mapper, object, objectName) {\n  var _a;\n\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    var payload = {};\n    var modelProps = resolveModelProperties(serializer, mapper, objectName);\n\n    for (var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {\n      var key = _b[_i];\n      var propertyMapper = modelProps[key];\n\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      var propName = void 0;\n      var parentObject = payload;\n\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        var paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n\n        for (var _c = 0, paths_1 = paths; _c < paths_1.length; _c++) {\n          var pathName = paths_1[_c];\n          var childObject = parentObject[pathName];\n\n          if (childObject == undefined && object[key] != undefined) {\n            parentObject[pathName] = {};\n          }\n\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        var propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        var toSerialize = object[key];\n        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {\n          toSerialize = mapper.serializedName;\n        }\n\n        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName);\n\n        if (serializedValue !== undefined && propName != undefined) {\n          if (propertyMapper.xmlIsAttribute) {\n            // $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject.$ = parentObject.$ || {};\n            parentObject.$[propName] = serializedValue;\n          } else if (propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = (_a = {}, _a[propertyMapper.xmlElementName] = serializedValue, _a);\n          } else {\n            parentObject[propName] = serializedValue;\n          }\n        }\n      }\n    }\n\n    var additionalPropertiesMapper = mapper.type.additionalProperties;\n\n    if (additionalPropertiesMapper) {\n      var propNames = Object.keys(modelProps);\n\n      var _loop_1 = function (clientPropName) {\n        var isAdditionalProperty = propNames.every(function (pn) {\n          return pn !== clientPropName;\n        });\n\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]');\n        }\n      };\n\n      for (var clientPropName in object) {\n        _loop_1(clientPropName);\n      }\n    }\n\n    return payload;\n  }\n\n  return object;\n}\n\nfunction isSpecialXmlProperty(propertyName) {\n  return [\"$\", \"_\"].includes(propertyName);\n}\n\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  var modelProps = resolveModelProperties(serializer, mapper, objectName);\n  var instance = {};\n  var handledPropertyNames = [];\n\n  for (var _i = 0, _a = Object.keys(modelProps); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var propertyMapper = modelProps[key];\n    var paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    var serializedName = propertyMapper.serializedName,\n        xmlName = propertyMapper.xmlName,\n        xmlElementName = propertyMapper.xmlElementName;\n    var propertyObjectName = objectName;\n\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n\n    if (headerCollectionPrefix) {\n      var dictionary = {};\n\n      for (var _b = 0, _c = Object.keys(responseBody); _b < _c.length; _b++) {\n        var headerKey = _c[_b];\n\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName);\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody.$) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody.$[xmlName], propertyObjectName);\n      } else {\n        var propertyName = xmlElementName || xmlName || serializedName;\n        var unwrappedProperty = responseBody[propertyName];\n\n        if (propertyMapper.xmlIsWrapped) {\n          unwrappedProperty = responseBody[xmlName];\n          unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName];\n          var isEmptyWrappedList = unwrappedProperty === undefined;\n\n          if (isEmptyWrappedList) {\n            unwrappedProperty = [];\n          }\n        }\n\n        instance[key] = serializer.deserialize(propertyMapper, unwrappedProperty, propertyObjectName);\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      var propertyInstance = void 0;\n      var res = responseBody; // traversing the object step by step.\n\n      for (var _d = 0, paths_2 = paths; _d < paths_2.length; _d++) {\n        var item = paths_2[_d];\n        if (!res) break;\n        res = res[item];\n      }\n\n      propertyInstance = res;\n      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n\n      if (polymorphicDiscriminator && propertyMapper.serializedName === polymorphicDiscriminator.serializedName && propertyInstance == undefined) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      var serializedValue = void 0; // paging\n\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n      } else if (propertyInstance !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  var additionalPropertiesMapper = mapper.type.additionalProperties;\n\n  if (additionalPropertiesMapper) {\n    var isAdditionalProperty = function (responsePropName) {\n      for (var clientPropName in modelProps) {\n        var paths = splitSerializeName(modelProps[clientPropName].serializedName);\n\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    for (var responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]');\n      }\n    }\n  } else if (responseBody) {\n    for (var _e = 0, _f = Object.keys(responseBody); _e < _f.length; _e++) {\n      var key = _f[_e];\n\n      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key)) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName) {\n  /*jshint validthis: true */\n  var value = mapper.type.value;\n\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n\n  if (responseBody) {\n    var tempDictionary = {};\n\n    for (var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {\n      var key = _a[_i];\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);\n    }\n\n    return tempDictionary;\n  }\n\n  return responseBody;\n}\n\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName) {\n  /*jshint validthis: true */\n  var element = mapper.type.element;\n\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    var tempArray = [];\n\n    for (var i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + \"[\" + i + \"]\");\n    }\n\n    return tempArray;\n  }\n\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n  if (polymorphicDiscriminator) {\n    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n\n    if (discriminatorName != undefined) {\n      var discriminatorValue = object[discriminatorName];\n\n      if (discriminatorValue != undefined) {\n        var typeName = mapper.type.uberParent || mapper.type.className;\n        var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + \".\" + discriminatorValue;\n        var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n} // TODO: why is this here?\n\n\nexport function serializeObject(toSerialize) {\n  if (toSerialize == undefined) return undefined;\n\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    var array = [];\n\n    for (var i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    var dictionary = {};\n\n    for (var property in toSerialize) {\n      dictionary[property] = serializeObject(toSerialize[property]);\n    }\n\n    return dictionary;\n  }\n\n  return toSerialize;\n}\n/**\n * Utility function to create a K:V from a list of strings\n */\n\nfunction strEnum(o) {\n  var result = {};\n\n  for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n    var key = o_1[_i];\n    result[key] = key;\n  }\n\n  return result;\n}\n\nexport var MapperType = strEnum([\"Base64Url\", \"Boolean\", \"ByteArray\", \"Composite\", \"Date\", \"DateTime\", \"DateTimeRfc1123\", \"Dictionary\", \"Enum\", \"Number\", \"Object\", \"Sequence\", \"String\", \"Stream\", \"TimeSpan\", \"UnixTime\"]);","map":{"version":3,"sources":["../../lib/serializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nvar Serializer = /** @class */ (function () {\n    function Serializer(modelMappers, isXML) {\n        if (modelMappers === void 0) { modelMappers = {}; }\n        this.modelMappers = modelMappers;\n        this.isXML = isXML;\n    }\n    Serializer.prototype.validateConstraints = function (mapper, value, objectName) {\n        var failValidation = function (constraintName, constraintValue) {\n            throw new Error(\"\\\"\" + objectName + \"\\\" with value \\\"\" + value + \"\\\" should satisfy the constraint \\\"\" + constraintName + \"\\\": \" + constraintValue + \".\");\n        };\n        if (mapper.constraints && (value != undefined)) {\n            var _a = mapper.constraints, ExclusiveMaximum = _a.ExclusiveMaximum, ExclusiveMinimum = _a.ExclusiveMinimum, InclusiveMaximum = _a.InclusiveMaximum, InclusiveMinimum = _a.InclusiveMinimum, MaxItems = _a.MaxItems, MaxLength = _a.MaxLength, MinItems = _a.MinItems, MinLength = _a.MinLength, MultipleOf = _a.MultipleOf, Pattern = _a.Pattern, UniqueItems = _a.UniqueItems;\n            if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {\n                failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n            }\n            if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {\n                failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n            }\n            if (InclusiveMaximum != undefined && value > InclusiveMaximum) {\n                failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n            }\n            if (InclusiveMinimum != undefined && value < InclusiveMinimum) {\n                failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n            }\n            if (MaxItems != undefined && value.length > MaxItems) {\n                failValidation(\"MaxItems\", MaxItems);\n            }\n            if (MaxLength != undefined && value.length > MaxLength) {\n                failValidation(\"MaxLength\", MaxLength);\n            }\n            if (MinItems != undefined && value.length < MinItems) {\n                failValidation(\"MinItems\", MinItems);\n            }\n            if (MinLength != undefined && value.length < MinLength) {\n                failValidation(\"MinLength\", MinLength);\n            }\n            if (MultipleOf != undefined && value % MultipleOf !== 0) {\n                failValidation(\"MultipleOf\", MultipleOf);\n            }\n            if (Pattern && value.match(Pattern) === null) {\n                failValidation(\"Pattern\", Pattern);\n            }\n            if (UniqueItems && value.some(function (item, i, ar) { return ar.indexOf(item) !== i; })) {\n                failValidation(\"UniqueItems\", UniqueItems);\n            }\n        }\n    };\n    /**\n     * Serialize the given object based on its metadata defined in the mapper\n     *\n     * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n     *\n     * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n     *\n     * @param {string} objectName Name of the serialized object\n     *\n     * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n     */\n    Serializer.prototype.serialize = function (mapper, object, objectName) {\n        var payload = {};\n        var mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Sequence$/ig) !== null) {\n            payload = [];\n        }\n        if (object == undefined && (mapper.defaultValue != undefined || mapper.isConstant)) {\n            object = mapper.defaultValue;\n        }\n        // This table of allowed values should help explain\n        // the mapper.required and mapper.nullable properties.\n        // X means \"neither undefined or null are allowed\".\n        //           || required\n        //           || true      | false\n        //  nullable || ==========================\n        //      true || null      | undefined/null\n        //     false || X         | undefined\n        // undefined || X         | undefined/null\n        var required = mapper.required, nullable = mapper.nullable;\n        if (required && nullable && object === undefined) {\n            throw new Error(objectName + \" cannot be undefined.\");\n        }\n        if (required && !nullable && object == undefined) {\n            throw new Error(objectName + \" cannot be null or undefined.\");\n        }\n        if (!required && nullable === false && object === null) {\n            throw new Error(objectName + \" cannot be null.\");\n        }\n        if (object == undefined) {\n            payload = object;\n        }\n        else {\n            // Validate Constraints if any\n            this.validateConstraints(mapper, object, objectName);\n            if (mapperType.match(/^any$/ig) !== null) {\n                payload = object;\n            }\n            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/ig) !== null) {\n                payload = serializeBasicTypes(mapperType, objectName, object);\n            }\n            else if (mapperType.match(/^Enum$/ig) !== null) {\n                var enumMapper = mapper;\n                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n            }\n            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/ig) !== null) {\n                payload = serializeDateTypes(mapperType, object, objectName);\n            }\n            else if (mapperType.match(/^ByteArray$/ig) !== null) {\n                payload = serializeByteArrayType(objectName, object);\n            }\n            else if (mapperType.match(/^Base64Url$/ig) !== null) {\n                payload = serializeBase64UrlType(objectName, object);\n            }\n            else if (mapperType.match(/^Sequence$/ig) !== null) {\n                payload = serializeSequenceType(this, mapper, object, objectName);\n            }\n            else if (mapperType.match(/^Dictionary$/ig) !== null) {\n                payload = serializeDictionaryType(this, mapper, object, objectName);\n            }\n            else if (mapperType.match(/^Composite$/ig) !== null) {\n                payload = serializeCompositeType(this, mapper, object, objectName);\n            }\n        }\n        return payload;\n    };\n    /**\n     * Deserialize the given object based on its metadata defined in the mapper\n     *\n     * @param {object} mapper The mapper which defines the metadata of the serializable object\n     *\n     * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n     *\n     * @param {string} objectName Name of the deserialized object\n     *\n     * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n     */\n    Serializer.prototype.deserialize = function (mapper, responseBody, objectName) {\n        if (responseBody == undefined) {\n            if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n                // between the list being empty versus being missing,\n                // so let's do the more user-friendly thing and return an empty list.\n                responseBody = [];\n            }\n            return responseBody;\n        }\n        var payload;\n        var mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Composite$/ig) !== null) {\n            payload = deserializeCompositeType(this, mapper, responseBody, objectName);\n        }\n        else {\n            if (this.isXML) {\n                /**\n                 * If the mapper specifies this as a non-composite type value but the responseBody contains\n                 * both header (\"$\") and body (\"_\") properties, then just reduce the responseBody value to\n                 * the body (\"_\") property.\n                 */\n                if (responseBody[\"$\"] != undefined && responseBody[\"_\"] != undefined) {\n                    responseBody = responseBody[\"_\"];\n                }\n            }\n            if (mapperType.match(/^Number$/ig) !== null) {\n                payload = parseFloat(responseBody);\n                if (isNaN(payload)) {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^Boolean$/ig) !== null) {\n                if (responseBody === \"true\") {\n                    payload = true;\n                }\n                else if (responseBody === \"false\") {\n                    payload = false;\n                }\n                else {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/ig) !== null) {\n                payload = responseBody;\n            }\n            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/ig) !== null) {\n                payload = new Date(responseBody);\n            }\n            else if (mapperType.match(/^UnixTime$/ig) !== null) {\n                payload = unixTimeToDate(responseBody);\n            }\n            else if (mapperType.match(/^ByteArray$/ig) !== null) {\n                payload = base64.decodeString(responseBody);\n            }\n            else if (mapperType.match(/^Base64Url$/ig) !== null) {\n                payload = base64UrlToByteArray(responseBody);\n            }\n            else if (mapperType.match(/^Sequence$/ig) !== null) {\n                payload = deserializeSequenceType(this, mapper, responseBody, objectName);\n            }\n            else if (mapperType.match(/^Dictionary$/ig) !== null) {\n                payload = deserializeDictionaryType(this, mapper, responseBody, objectName);\n            }\n        }\n        if (mapper.isConstant) {\n            payload = mapper.defaultValue;\n        }\n        return payload;\n    };\n    return Serializer;\n}());\nexport { Serializer };\nfunction trimEnd(str, ch) {\n    var len = str.length;\n    while ((len - 1) >= 0 && str[len - 1] === ch) {\n        --len;\n    }\n    return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n    if (!buffer) {\n        return undefined;\n    }\n    if (!(buffer instanceof Uint8Array)) {\n        throw new Error(\"Please provide an input of type Uint8Array for converting to Base64Url.\");\n    }\n    // Uint8Array to Base64.\n    var str = base64.encodeByteArray(buffer);\n    // Base64 to Base64Url.\n    return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n    if (!str) {\n        return undefined;\n    }\n    if (str && typeof str.valueOf() !== \"string\") {\n        throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n    }\n    // Base64Url to Base64.\n    str = str.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n    // Base64 to Uint8Array.\n    return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n    var classes = [];\n    var partialclass = \"\";\n    if (prop) {\n        var subwords = prop.split(\".\");\n        for (var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {\n            var item = subwords_1[_i];\n            if (item.charAt(item.length - 1) === \"\\\\\") {\n                partialclass += item.substr(0, item.length - 1) + \".\";\n            }\n            else {\n                partialclass += item;\n                classes.push(partialclass);\n                partialclass = \"\";\n            }\n        }\n    }\n    return classes;\n}\nfunction dateToUnixTime(d) {\n    if (!d) {\n        return undefined;\n    }\n    if (typeof d.valueOf() === \"string\") {\n        d = new Date(d);\n    }\n    return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n    if (!n) {\n        return undefined;\n    }\n    return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n    if (value !== null && value !== undefined) {\n        if (typeName.match(/^Number$/ig) !== null) {\n            if (typeof value !== \"number\") {\n                throw new Error(objectName + \" with value \" + value + \" must be of type number.\");\n            }\n        }\n        else if (typeName.match(/^String$/ig) !== null) {\n            if (typeof value.valueOf() !== \"string\") {\n                throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string.\");\n            }\n        }\n        else if (typeName.match(/^Uuid$/ig) !== null) {\n            if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n                throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string and a valid uuid.\");\n            }\n        }\n        else if (typeName.match(/^Boolean$/ig) !== null) {\n            if (typeof value !== \"boolean\") {\n                throw new Error(objectName + \" with value \" + value + \" must be of type boolean.\");\n            }\n        }\n        else if (typeName.match(/^Stream$/ig) !== null) {\n            var objectType = typeof value;\n            if (objectType !== \"string\" &&\n                objectType !== \"function\" &&\n                !(value instanceof ArrayBuffer) &&\n                !ArrayBuffer.isView(value) &&\n                !(typeof Blob === \"function\" && value instanceof Blob)) {\n                throw new Error(objectName + \" must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.\");\n            }\n        }\n    }\n    return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n    if (!allowedValues) {\n        throw new Error(\"Please provide a set of allowedValues to validate \" + objectName + \" as an Enum Type.\");\n    }\n    var isPresent = allowedValues.some(function (item) {\n        if (typeof item.valueOf() === \"string\") {\n            return item.toLowerCase() === value.toLowerCase();\n        }\n        return item === value;\n    });\n    if (!isPresent) {\n        throw new Error(value + \" is not a valid value for \" + objectName + \". The valid values are: \" + JSON.stringify(allowedValues) + \".\");\n    }\n    return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n    if (value != undefined) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(objectName + \" must be of type Uint8Array.\");\n        }\n        value = base64.encodeByteArray(value);\n    }\n    return value;\n}\nfunction serializeBase64UrlType(objectName, value) {\n    if (value != undefined) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(objectName + \" must be of type Uint8Array.\");\n        }\n        value = bufferToBase64Url(value);\n    }\n    return value;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n    if (value != undefined) {\n        if (typeName.match(/^Date$/ig) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n            }\n            value = (value instanceof Date) ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n        }\n        else if (typeName.match(/^DateTime$/ig) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n            }\n            value = (value instanceof Date) ? value.toISOString() : new Date(value).toISOString();\n        }\n        else if (typeName.match(/^DateTimeRfc1123$/ig) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123 format.\");\n            }\n            value = (value instanceof Date) ? value.toUTCString() : new Date(value).toUTCString();\n        }\n        else if (typeName.match(/^UnixTime$/ig) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123/ISO8601 format \" +\n                    \"for it to be serialized in UnixTime/Epoch format.\");\n            }\n            value = dateToUnixTime(value);\n        }\n        else if (typeName.match(/^TimeSpan$/ig) !== null) {\n            if (!utils.isDuration(value)) {\n                throw new Error(objectName + \" must be a string in ISO 8601 format. Instead was \\\"\" + value + \"\\\".\");\n            }\n            value = value;\n        }\n    }\n    return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName) {\n    if (!Array.isArray(object)) {\n        throw new Error(objectName + \" must be of type Array.\");\n    }\n    var elementType = mapper.type.element;\n    if (!elementType || typeof elementType !== \"object\") {\n        throw new Error(\"element\\\" metadata for an Array must be defined in the \" +\n            (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n    }\n    var tempArray = [];\n    for (var i = 0; i < object.length; i++) {\n        tempArray[i] = serializer.serialize(elementType, object[i], objectName);\n    }\n    return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName) {\n    if (typeof object !== \"object\") {\n        throw new Error(objectName + \" must be of type object.\");\n    }\n    var valueType = mapper.type.value;\n    if (!valueType || typeof valueType !== \"object\") {\n        throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" +\n            (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n    }\n    var tempDictionary = {};\n    for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {\n        var key = _a[_i];\n        tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + \".\" + key);\n    }\n    return tempDictionary;\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer the serializer containing the entire set of mappers\n * @param mapper the composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n    var modelProps = mapper.type.modelProperties;\n    if (!modelProps) {\n        var className = mapper.type.className;\n        if (!className) {\n            throw new Error(\"Class name for model \\\"\" + objectName + \"\\\" is not provided in the mapper \\\"\" + JSON.stringify(mapper, undefined, 2) + \"\\\".\");\n        }\n        var modelMapper = serializer.modelMappers[className];\n        if (!modelMapper) {\n            throw new Error(\"mapper() cannot be null or undefined for model \\\"\" + className + \"\\\".\");\n        }\n        modelProps = modelMapper.type.modelProperties;\n        if (!modelProps) {\n            throw new Error(\"modelProperties cannot be null or undefined in the \" +\n                (\"mapper \\\"\" + JSON.stringify(modelMapper) + \"\\\" of type \\\"\" + className + \"\\\" for object \\\"\" + objectName + \"\\\".\"));\n        }\n    }\n    return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName) {\n    var _a;\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n    }\n    if (object != undefined) {\n        var payload = {};\n        var modelProps = resolveModelProperties(serializer, mapper, objectName);\n        for (var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {\n            var key = _b[_i];\n            var propertyMapper = modelProps[key];\n            if (propertyMapper.readOnly) {\n                continue;\n            }\n            var propName = void 0;\n            var parentObject = payload;\n            if (serializer.isXML) {\n                if (propertyMapper.xmlIsWrapped) {\n                    propName = propertyMapper.xmlName;\n                }\n                else {\n                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n                }\n            }\n            else {\n                var paths = splitSerializeName(propertyMapper.serializedName);\n                propName = paths.pop();\n                for (var _c = 0, paths_1 = paths; _c < paths_1.length; _c++) {\n                    var pathName = paths_1[_c];\n                    var childObject = parentObject[pathName];\n                    if ((childObject == undefined) && (object[key] != undefined)) {\n                        parentObject[pathName] = {};\n                    }\n                    parentObject = parentObject[pathName];\n                }\n            }\n            if (parentObject != undefined) {\n                var propertyObjectName = propertyMapper.serializedName !== \"\"\n                    ? objectName + \".\" + propertyMapper.serializedName\n                    : objectName;\n                var toSerialize = object[key];\n                var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n                if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {\n                    toSerialize = mapper.serializedName;\n                }\n                var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName);\n                if (serializedValue !== undefined && propName != undefined) {\n                    if (propertyMapper.xmlIsAttribute) {\n                        // $ is the key attributes are kept under in xml2js.\n                        // This keeps things simple while preventing name collision\n                        // with names in user documents.\n                        parentObject.$ = parentObject.$ || {};\n                        parentObject.$[propName] = serializedValue;\n                    }\n                    else if (propertyMapper.xmlIsWrapped) {\n                        parentObject[propName] = (_a = {}, _a[propertyMapper.xmlElementName] = serializedValue, _a);\n                    }\n                    else {\n                        parentObject[propName] = serializedValue;\n                    }\n                }\n            }\n        }\n        var additionalPropertiesMapper = mapper.type.additionalProperties;\n        if (additionalPropertiesMapper) {\n            var propNames = Object.keys(modelProps);\n            var _loop_1 = function (clientPropName) {\n                var isAdditionalProperty = propNames.every(function (pn) { return pn !== clientPropName; });\n                if (isAdditionalProperty) {\n                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]');\n                }\n            };\n            for (var clientPropName in object) {\n                _loop_1(clientPropName);\n            }\n        }\n        return payload;\n    }\n    return object;\n}\nfunction isSpecialXmlProperty(propertyName) {\n    return [\"$\", \"_\"].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName) {\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n    }\n    var modelProps = resolveModelProperties(serializer, mapper, objectName);\n    var instance = {};\n    var handledPropertyNames = [];\n    for (var _i = 0, _a = Object.keys(modelProps); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var propertyMapper = modelProps[key];\n        var paths = splitSerializeName(modelProps[key].serializedName);\n        handledPropertyNames.push(paths[0]);\n        var serializedName = propertyMapper.serializedName, xmlName = propertyMapper.xmlName, xmlElementName = propertyMapper.xmlElementName;\n        var propertyObjectName = objectName;\n        if (serializedName !== \"\" && serializedName !== undefined) {\n            propertyObjectName = objectName + \".\" + serializedName;\n        }\n        var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n            var dictionary = {};\n            for (var _b = 0, _c = Object.keys(responseBody); _b < _c.length; _b++) {\n                var headerKey = _c[_b];\n                if (headerKey.startsWith(headerCollectionPrefix)) {\n                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName);\n                }\n                handledPropertyNames.push(headerKey);\n            }\n            instance[key] = dictionary;\n        }\n        else if (serializer.isXML) {\n            if (propertyMapper.xmlIsAttribute && responseBody.$) {\n                instance[key] = serializer.deserialize(propertyMapper, responseBody.$[xmlName], propertyObjectName);\n            }\n            else {\n                var propertyName = xmlElementName || xmlName || serializedName;\n                var unwrappedProperty = responseBody[propertyName];\n                if (propertyMapper.xmlIsWrapped) {\n                    unwrappedProperty = responseBody[xmlName];\n                    unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName];\n                    var isEmptyWrappedList = unwrappedProperty === undefined;\n                    if (isEmptyWrappedList) {\n                        unwrappedProperty = [];\n                    }\n                }\n                instance[key] = serializer.deserialize(propertyMapper, unwrappedProperty, propertyObjectName);\n            }\n        }\n        else {\n            // deserialize the property if it is present in the provided responseBody instance\n            var propertyInstance = void 0;\n            var res = responseBody;\n            // traversing the object step by step.\n            for (var _d = 0, paths_2 = paths; _d < paths_2.length; _d++) {\n                var item = paths_2[_d];\n                if (!res)\n                    break;\n                res = res[item];\n            }\n            propertyInstance = res;\n            var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n            if (polymorphicDiscriminator && propertyMapper.serializedName === polymorphicDiscriminator.serializedName && propertyInstance == undefined) {\n                propertyInstance = mapper.serializedName;\n            }\n            var serializedValue = void 0;\n            // paging\n            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n                propertyInstance = responseBody[key];\n                instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n            }\n            else if (propertyInstance !== undefined) {\n                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n                instance[key] = serializedValue;\n            }\n        }\n    }\n    var additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n        var isAdditionalProperty = function (responsePropName) {\n            for (var clientPropName in modelProps) {\n                var paths = splitSerializeName(modelProps[clientPropName].serializedName);\n                if (paths[0] === responsePropName) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        for (var responsePropName in responseBody) {\n            if (isAdditionalProperty(responsePropName)) {\n                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]');\n            }\n        }\n    }\n    else if (responseBody) {\n        for (var _e = 0, _f = Object.keys(responseBody); _e < _f.length; _e++) {\n            var key = _f[_e];\n            if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key)) {\n                instance[key] = responseBody[key];\n            }\n        }\n    }\n    return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName) {\n    /*jshint validthis: true */\n    var value = mapper.type.value;\n    if (!value || typeof value !== \"object\") {\n        throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" +\n            (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n    }\n    if (responseBody) {\n        var tempDictionary = {};\n        for (var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {\n            var key = _a[_i];\n            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);\n        }\n        return tempDictionary;\n    }\n    return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName) {\n    /*jshint validthis: true */\n    var element = mapper.type.element;\n    if (!element || typeof element !== \"object\") {\n        throw new Error(\"element\\\" metadata for an Array must be defined in the \" +\n            (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n    }\n    if (responseBody) {\n        if (!Array.isArray(responseBody)) {\n            // xml2js will interpret a single element array as just the element, so force it to be an array\n            responseBody = [responseBody];\n        }\n        var tempArray = [];\n        for (var i = 0; i < responseBody.length; i++) {\n            tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + \"[\" + i + \"]\");\n        }\n        return tempArray;\n    }\n    return responseBody;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n    var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n    if (polymorphicDiscriminator) {\n        var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n        if (discriminatorName != undefined) {\n            var discriminatorValue = object[discriminatorName];\n            if (discriminatorValue != undefined) {\n                var typeName = mapper.type.uberParent || mapper.type.className;\n                var indexDiscriminator = discriminatorValue === typeName\n                    ? discriminatorValue\n                    : typeName + \".\" + discriminatorValue;\n                var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n                if (polymorphicMapper) {\n                    mapper = polymorphicMapper;\n                }\n            }\n        }\n    }\n    return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n    return mapper.type.polymorphicDiscriminator\n        || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent)\n        || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n    return (typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator);\n}\n// TODO: why is this here?\nexport function serializeObject(toSerialize) {\n    if (toSerialize == undefined)\n        return undefined;\n    if (toSerialize instanceof Uint8Array) {\n        toSerialize = base64.encodeByteArray(toSerialize);\n        return toSerialize;\n    }\n    else if (toSerialize instanceof Date) {\n        return toSerialize.toISOString();\n    }\n    else if (Array.isArray(toSerialize)) {\n        var array = [];\n        for (var i = 0; i < toSerialize.length; i++) {\n            array.push(serializeObject(toSerialize[i]));\n        }\n        return array;\n    }\n    else if (typeof toSerialize === \"object\") {\n        var dictionary = {};\n        for (var property in toSerialize) {\n            dictionary[property] = serializeObject(toSerialize[property]);\n        }\n        return dictionary;\n    }\n    return toSerialize;\n}\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum(o) {\n    var result = {};\n    for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n        var key = o_1[_i];\n        result[key] = key;\n    }\n    return result;\n}\nexport var MapperType = strEnum([\n    \"Base64Url\",\n    \"Boolean\",\n    \"ByteArray\",\n    \"Composite\",\n    \"Date\",\n    \"DateTime\",\n    \"DateTimeRfc1123\",\n    \"Dictionary\",\n    \"Enum\",\n    \"Number\",\n    \"Object\",\n    \"Sequence\",\n    \"String\",\n    \"Stream\",\n    \"TimeSpan\",\n    \"UnixTime\"\n]);\n//# sourceMappingURL=serializer.js.map"]},"metadata":{},"sourceType":"module"}