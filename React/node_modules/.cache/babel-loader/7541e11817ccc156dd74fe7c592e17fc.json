{"ast":null,"code":"'use strict';\n\nconst Utils = require('./../utils');\n\nconst Helpers = require('./helpers');\n\nconst _ = require('lodash');\n\nconst Association = require('./base');\n\nconst BelongsTo = require('./belongs-to');\n\nconst HasMany = require('./has-many');\n\nconst HasOne = require('./has-one');\n\nconst AssociationError = require('../errors').AssociationError;\n\nconst Op = require('../operators');\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(function (project) {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(function (projects) {\n   *   let p1 = projects[0]\n   *   p1.UserProjects.started // Is this project started yet?\n   * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\n\n\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError('belongsToMany must be given a through option, either a string or a model');\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = _.assign({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    /*\n    * Default/generated foreign/other keys\n    */\n\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      if (!this.options.foreignKey) {\n        this.foreignKeyDefault = true;\n      }\n\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelizeIf([Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored), this.source.primaryKeyAttribute].join('_'), !this.source.options.underscored);\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelizeIf([Utils.underscoredIf(this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular, this.target.options.underscored), this.target.primaryKeyAttribute].join('_'), !this.target.options.underscored);\n    }\n    /*\n    * Find paired association (if exists)\n    */\n\n\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, _.extend(this.options, {\n          tableName: this.through.model,\n          indexes: [],\n          //we don't want indexes here (as referenced in #2416)\n          paranoid: false,\n          // A paranoid join table does not make sense\n          validate: {} // Don't propagate model-level validations\n\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    this.options = Object.assign(this.options, _.pick(this.through.model.options, ['timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid']));\n\n    if (this.paired) {\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n        }\n\n        this.paired.otherKey = this.foreignKey;\n        this.paired.foreignIdentifier = this.foreignKey;\n        delete this.paired.foreignIdentifierField;\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n    this.associationAccessor = this.as; // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n\n    const plural = Utils.uppercaseFirst(this.options.name.plural);\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n    this.accessors = {\n      get: 'get' + plural,\n      set: 'set' + plural,\n      addMultiple: 'add' + plural,\n      add: 'add' + singular,\n      create: 'create' + singular,\n      remove: 'remove' + singular,\n      removeMultiple: 'remove' + plural,\n      hasSingle: 'has' + singular,\n      hasAll: 'has' + plural,\n      count: 'count' + plural\n    };\n  } // the id is in the target table\n  // or in an extra table which connects two tables\n\n\n  injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey; // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        } else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.source.primaryKeyAttribute];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = sourceKey.field || this.source.primaryKeyAttribute;\n    const targetKey = this.target.rawAttributes[this.target.primaryKeyAttribute];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = targetKey.field || this.target.primaryKeyAttribute;\n\n    const sourceAttribute = _.defaults({}, this.foreignKeyAttribute, {\n      type: sourceKeyType\n    });\n\n    const targetAttribute = _.defaults({}, this.otherKeyAttribute, {\n      type: targetKeyType\n    });\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      }; // For the source attribute the passed option is the priority\n\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      }; // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    this.through.model.rawAttributes[this.foreignKey] = _.extend(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    this.through.model.rawAttributes[this.otherKey] = _.extend(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.through.model.refreshAttributes();\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      as: this.through.model.name\n    });\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findAll}  for a full explanation of options\n   * @return {Promise<Array<Model>>}\n   */\n\n\n  get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n    const association = this;\n    const through = association.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (association.scope) {\n      scopeWhere = _.clone(association.scope);\n    }\n\n    options.where = {\n      [Op.and]: [scopeWhere, options.where]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[association.foreignKey] = instance.get(association.source.primaryKeyAttribute);\n\n      if (through.scope) {\n        _.assign(throughWhere, through.scope);\n      } //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n\n\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: association.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        where: throughWhere\n      });\n    }\n\n    let model = association.target;\n\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @return {Promise<Integer>}\n   */\n\n\n  count(instance, options) {\n    const association = this;\n    const model = association.target;\n    const sequelize = model.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [[sequelize.fn('COUNT', sequelize.col([association.target.name, model.primaryKeyField].join('.'))), 'count']];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n    return association.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model[]|Model|string[]|String|number[]|Number} [instance(s)] Can be an array of instances or their primary keys\n   * @param {Object} [options] Options passed to getAssociations\n   * @return {Promise<boolean>}\n   */\n\n\n  has(sourceInstance, instances, options) {\n    const association = this;\n    const where = {};\n\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = _.assign({\n      raw: true\n    }, options, {\n      scope: false\n    });\n    where[Op.or] = instances.map(instance => {\n      if (instance instanceof association.target) {\n        return instance.where();\n      } else {\n        const where = {};\n        where[association.target.primaryKeyAttribute] = instance;\n        return where;\n      }\n    });\n    options.where = {\n      [Op.and]: [where, options.where]\n    };\n    return association.get(sourceInstance, options).then(associatedObjects => associatedObjects.length === instances.length);\n  }\n  /**\n   * Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Array<Model|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {Object} [options.validate] Run validation for the join model\n   * @param {Object} [options.through] Additional attributes for the join table.\n   * @return {Promise}\n   */\n\n\n  set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n    const association = this;\n    const sourceKey = association.source.primaryKeyAttribute;\n    const targetKey = association.target.primaryKeyAttribute;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    let where = {};\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = association.toInstanceArray(newAssociatedObjects);\n    }\n\n    where[identifier] = sourceInstance.get(sourceKey);\n    where = Object.assign(where, association.through.scope);\n    return association.through.model.findAll(_.defaults({\n      where,\n      raw: true\n    }, options)).then(currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      let defaultAttributes = options.through || {}; // Don't try to insert the transaction as an attribute in the through table\n\n      defaultAttributes = _.omit(defaultAttributes, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging']);\n      const unassociatedObjects = newAssociatedObjects.filter(obj => !_.find(currentRows, currentRow => currentRow[foreignIdentifier] === obj.get(targetKey)));\n\n      for (const currentRow of currentRows) {\n        const newObj = _.find(newAssociatedObjects, obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[association.through.model.name]; // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n          if (throughAttributes instanceof association.through.model) {\n            throughAttributes = {};\n          }\n\n          const where = {};\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          where[identifier] = sourceInstance.get(sourceKey);\n          where[foreignIdentifier] = newObj.get(targetKey);\n\n          if (Object.keys(attributes).length) {\n            promises.push(association.through.model.update(attributes, _.extend(options, {\n              where\n            })));\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        let where = {};\n        where[identifier] = sourceInstance.get(sourceKey);\n        where[foreignIdentifier] = obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]);\n        where = Object.assign(where, association.through.scope);\n        promises.push(association.through.model.destroy(_.defaults({\n          where\n        }, options)));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          let attributes = {};\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          attributes = _.defaults(attributes, unassociatedObject[association.through.model.name], defaultAttributes);\n\n          _.assign(attributes, association.through.scope);\n\n          attributes = Object.assign(attributes, association.through.scope);\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({\n          validate: true\n        }, options)));\n      }\n\n      return Utils.Promise.all(promises);\n    });\n  }\n  /**\n   * Associate one ore several rows with `this`.\n   *\n   * @param {Model[]|Model|string[]|string|number[]|Number} [newAssociation(s)] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {Object} [options.validate] Run validation for the join model.\n   * @param {Object} [options.through] Additional attributes for the join table.\n   * @return {Promise}\n   */\n\n\n  add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Utils.Promise.resolve();\n    options = _.clone(options) || {};\n    const association = this;\n    const sourceKey = association.source.primaryKeyAttribute;\n    const targetKey = association.target.primaryKeyAttribute;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n\n    const defaultAttributes = _.omit(options.through || {}, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging']);\n\n    newInstances = association.toInstanceArray(newInstances);\n    const where = {};\n    where[identifier] = sourceInstance.get(sourceKey);\n    where[foreignIdentifier] = newInstances.map(newInstance => newInstance.get(targetKey));\n\n    _.assign(where, association.through.scope);\n\n    return association.through.model.findAll(_.defaults({\n      where,\n      raw: true\n    }, options)).then(currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n\n      for (const obj of newInstances) {\n        const existingAssociation = _.find(currentRows, current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (_.some(Object.keys(attributes), attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          _.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({\n          validate: true\n        }, options)));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n\n        const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n        const where = {}; // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        where[identifier] = sourceInstance.get(sourceKey);\n        where[foreignIdentifier] = assoc.get(targetKey);\n        promises.push(association.through.model.update(attributes, _.extend(options, {\n          where\n        })));\n      }\n\n      return Utils.Promise.all(promises);\n    });\n  }\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model|String|Number} [oldAssociated] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {Object} [options] Options passed to `through.destroy`\n   * @return {Promise}\n   */\n\n\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n    options = options || {};\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n    const where = {};\n    where[association.identifier] = sourceInstance.get(association.source.primaryKeyAttribute);\n    where[association.foreignIdentifier] = oldAssociatedObjects.map(newInstance => newInstance.get(association.target.primaryKeyAttribute));\n    return association.through.model.destroy(_.defaults({\n      where\n    }, options));\n  }\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to create and add\n   * @param {Object} [options.through] Additional attributes for the join table\n   * @return {Promise}\n   */\n\n\n  create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      _.assign(values, association.scope);\n\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    } // Create the related model instance\n\n\n    return association.target.create(values, options).then(newAssociatedObject => sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject));\n  }\n\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/sequelize/lib/associations/belongs-to-many.js"],"names":["Utils","require","Helpers","_","Association","BelongsTo","HasMany","HasOne","AssociationError","Op","BelongsToMany","constructor","source","target","options","through","undefined","model","associationType","targetAssociation","sequelize","assign","isMultiAssociation","doubleLinked","as","isSelfAssociation","isAliased","isPlainObject","name","plural","singular","singularize","combinedTableName","combineTableNames","tableName","isObject","foreignKey","foreignKeyAttribute","fieldName","foreignKeyDefault","camelizeIf","underscoredIf","underscored","primaryKeyAttribute","join","otherKey","otherKeyAttribute","otherKeyDefault","each","associations","association","paired","isDefined","define","extend","indexes","paranoid","validate","Object","pick","rawAttributes","foreignIdentifier","foreignIdentifierField","throughModel","combinedName","associationAccessor","uppercaseFirst","accessors","get","set","addMultiple","add","create","remove","removeMultiple","hasSingle","hasAll","count","injectAttributes","identifier","attribute","attributeName","primaryKey","_autoGenerated","primaryKeyDeleted","sourceKey","sourceKeyType","type","sourceKeyField","field","targetKey","targetKeyType","targetKeyField","sourceAttribute","defaults","targetAttribute","unique","uniqueKey","constraints","references","getTableName","key","onDelete","onUpdate","identifierField","refreshAttributes","toSource","manyFromSource","oneFromSource","toTarget","manyFromTarget","oneFromTarget","checkNamingCollision","mixin","obj","methods","aliases","mixinMethods","instance","cloneDeep","scopeWhere","throughWhere","scope","clone","where","and","include","push","attributes","joinTableAttributes","required","hasOwnProperty","unscoped","schema","schemaDelimiter","findAll","fn","col","primaryKeyField","raw","plain","then","result","parseInt","has","sourceInstance","instances","Array","isArray","or","map","associatedObjects","length","newAssociatedObjects","toInstanceArray","currentRows","obsoleteAssociations","promises","defaultAttributes","omit","unassociatedObjects","filter","find","currentRow","newObj","throughAttributes","keys","update","obsoleteAssociation","destroy","bulk","unassociatedObject","bulkCreate","Promise","all","newInstances","resolve","newInstance","changedAssociations","existingAssociation","current","some","assoc","oldAssociatedObjects","values","fields","concat","newAssociatedObject","return","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\nconst Op = require('../operators');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(function (project) {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(function (projects) {\n   *   let p1 = projects[0]\n   *   p1.UserProjects.started // Is this project started yet?\n   * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError('belongsToMany must be given a through option, either a string or a model');\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = _.assign({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      if (!this.options.foreignKey) {\n        this.foreignKeyDefault = true;\n      }\n\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelizeIf(\n        [\n          Utils.underscoredIf(this.source.options.name.singular, this.source.options.underscored),\n          this.source.primaryKeyAttribute\n        ].join('_'),\n        !this.source.options.underscored\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelizeIf(\n        [\n          Utils.underscoredIf(\n            this.isSelfAssociation ?\n              Utils.singularize(this.as) :\n              this.target.options.name.singular,\n            this.target.options.underscored\n          ),\n          this.target.primaryKeyAttribute\n        ].join('_'),\n        !this.target.options.underscored\n      );\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, _.extend(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: false,  // A paranoid join table does not make sense\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    this.options = Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n        }\n        this.paired.otherKey = this.foreignKey;\n        this.paired.foreignIdentifier = this.foreignKey;\n        delete this.paired.foreignIdentifierField;\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = Utils.uppercaseFirst(this.options.name.plural);\n    const singular = Utils.uppercaseFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: 'get' + plural,\n      set: 'set' + plural,\n      addMultiple: 'add' + plural,\n      add: 'add' + singular,\n      create: 'create' + singular,\n      remove: 'remove' + singular,\n      removeMultiple: 'remove' + plural,\n      hasSingle: 'has' + singular,\n      hasAll: 'has' + plural,\n      count: 'count' + plural\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  injectAttributes() {\n\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.source.primaryKeyAttribute];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = sourceKey.field || this.source.primaryKeyAttribute;\n    const targetKey = this.target.rawAttributes[this.target.primaryKeyAttribute];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = targetKey.field || this.target.primaryKeyAttribute;\n    const sourceAttribute = _.defaults({}, this.foreignKeyAttribute, { type: sourceKeyType });\n    const targetAttribute = _.defaults({}, this.otherKeyAttribute, { type: targetKeyType });\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    this.through.model.rawAttributes[this.foreignKey] = _.extend(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    this.through.model.rawAttributes[this.otherKey] = _.extend(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.through.model.refreshAttributes();\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {String} [options.schema] Apply a schema on the related model\n   * @see {@link Model.findAll}  for a full explanation of options\n   * @return {Promise<Array<Model>>}\n   */\n  get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const association = this;\n    const through = association.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (association.scope) {\n      scopeWhere = _.clone(association.scope);\n    }\n\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[association.foreignKey] = instance.get(association.source.primaryKeyAttribute);\n\n      if (through.scope) {\n        _.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: association.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        where: throughWhere\n      });\n    }\n\n    let model = association.target;\n    if (options.hasOwnProperty('scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (options.hasOwnProperty('schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Object} [options]\n   * @param {Object} [options.where] An optional where clause to limit the associated models\n   * @param {String|Boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @return {Promise<Integer>}\n   */\n  count(instance, options) {\n    const association = this;\n    const model = association.target;\n    const sequelize = model.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([association.target.name, model.primaryKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    return association.get(instance, options).then(result => parseInt(result.count, 10));\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model[]|Model|string[]|String|number[]|Number} [instance(s)] Can be an array of instances or their primary keys\n   * @param {Object} [options] Options passed to getAssociations\n   * @return {Promise<boolean>}\n   */\n  has(sourceInstance, instances, options) {\n    const association = this;\n    const where = {};\n\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = _.assign({\n      raw: true\n    }, options, {\n      scope: false\n    });\n\n    where[Op.or] = instances.map(instance => {\n      if (instance instanceof association.target) {\n        return instance.where();\n      } else {\n        const where = {};\n        where[association.target.primaryKeyAttribute] = instance;\n        return where;\n      }\n    });\n\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n\n    return association.get(sourceInstance, options).then(associatedObjects => associatedObjects.length === instances.length);\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Array<Model|String|Number>} [newAssociations] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {Object} [options.validate] Run validation for the join model\n   * @param {Object} [options.through] Additional attributes for the join table.\n   * @return {Promise}\n   */\n  set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const association = this;\n    const sourceKey = association.source.primaryKeyAttribute;\n    const targetKey = association.target.primaryKeyAttribute;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    let where = {};\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = association.toInstanceArray(newAssociatedObjects);\n    }\n\n    where[identifier] = sourceInstance.get(sourceKey);\n    where = Object.assign(where, association.through.scope);\n\n    return association.through.model.findAll(_.defaults({where, raw: true}, options)).then(currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      let defaultAttributes = options.through || {};\n\n      // Don't try to insert the transaction as an attribute in the through table\n      defaultAttributes = _.omit(defaultAttributes, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging']);\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !_.find(currentRows, currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = _.find(newAssociatedObjects, obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[association.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof association.through.model) {\n            throughAttributes = {};\n          }\n\n          const where = {};\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          where[identifier] = sourceInstance.get(sourceKey);\n          where[foreignIdentifier] = newObj.get(targetKey);\n\n          if (Object.keys(attributes).length) {\n            promises.push(association.through.model.update(attributes, _.extend(options, {where})));\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        let where = {};\n        where[identifier] = sourceInstance.get(sourceKey);\n        where[foreignIdentifier] = obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]);\n        where = Object.assign(where, association.through.scope);\n        promises.push(association.through.model.destroy(_.defaults({where}, options)));\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          let attributes = {};\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          attributes = _.defaults(attributes, unassociatedObject[association.through.model.name], defaultAttributes);\n\n          _.assign(attributes, association.through.scope);\n          attributes = Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({ validate: true }, options)));\n      }\n\n      return Utils.Promise.all(promises);\n    });\n  }\n\n  /**\n   * Associate one ore several rows with `this`.\n   *\n   * @param {Model[]|Model|string[]|string|number[]|Number} [newAssociation(s)] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {Object} [options.validate] Run validation for the join model.\n   * @param {Object} [options.through] Additional attributes for the join table.\n   * @return {Promise}\n   */\n  add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Utils.Promise.resolve();\n\n    options = _.clone(options) || {};\n\n    const association = this;\n    const sourceKey = association.source.primaryKeyAttribute;\n    const targetKey = association.target.primaryKeyAttribute;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = _.omit(options.through || {}, ['transaction', 'hooks', 'individualHooks', 'ignoreDuplicates', 'validate', 'fields', 'logging']);\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {};\n    where[identifier] = sourceInstance.get(sourceKey);\n    where[foreignIdentifier] = newInstances.map(newInstance => newInstance.get(targetKey));\n\n    _.assign(where, association.through.scope);\n\n    return association.through.model.findAll(_.defaults({where, raw: true}, options)).then(currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = _.find(currentRows, current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          if (_.some(Object.keys(attributes), attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          _.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, _.assign({ validate: true }, options)));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = _.defaults({}, throughAttributes, defaultAttributes);\n        const where = {};\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        where[identifier] = sourceInstance.get(sourceKey);\n        where[foreignIdentifier] = assoc.get(targetKey);\n\n        promises.push(association.through.model.update(attributes, _.extend(options, {where})));\n      }\n\n      return Utils.Promise.all(promises);\n    });\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model|String|Number} [oldAssociated] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {Object} [options] Options passed to `through.destroy`\n   * @return {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {};\n    where[association.identifier] = sourceInstance.get(association.source.primaryKeyAttribute);\n    where[association.foreignIdentifier] = oldAssociatedObjects.map(newInstance => newInstance.get(association.target.primaryKeyAttribute));\n\n    return association.through.model.destroy(_.defaults({where}, options));\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Object} [values]\n   * @param {Object} [options] Options passed to create and add\n   * @param {Object} [options.through] Additional attributes for the join table\n   * @return {Promise}\n   */\n  create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      _.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    return association.target.create(values, options).then(newAssociatedObject =>\n      sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject)\n    );\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n"]},"metadata":{},"sourceType":"script"}