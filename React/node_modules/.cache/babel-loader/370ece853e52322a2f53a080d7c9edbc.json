{"ast":null,"code":"//////////////////////////////////////////\n// Defines mappings between content-type\n// and the appropriate parsers.\n//////////////////////////////////////////\nvar Transform = require('stream').Transform;\n\nvar sax = require('sax');\n\nfunction parseXML(str, cb) {\n  var obj,\n      current,\n      parser = sax.parser(true, {\n    trim: true,\n    lowercase: true\n  });\n  parser.onerror = parser.onend = done;\n\n  function done(err) {\n    parser.onerror = parser.onend = function () {};\n\n    cb(err, obj);\n  }\n\n  function newElement(name, attributes) {\n    return {\n      name: name || '',\n      value: '',\n      attributes: attributes || {},\n      children: []\n    };\n  }\n\n  parser.ontext = function (t) {\n    if (current) current.value += t;\n  };\n\n  parser.onopentag = function (node) {\n    var element = newElement(node.name, node.attributes);\n\n    if (current) {\n      element.parent = current;\n      current.children.push(element);\n    } else {\n      // root object\n      obj = element;\n    }\n\n    current = element;\n  };\n\n  parser.onclosetag = function () {\n    if (typeof current.parent !== 'undefined') {\n      var just_closed = current;\n      current = current.parent;\n      delete just_closed.parent;\n    }\n  };\n\n  parser.write(str).close();\n}\n\nfunction parserFactory(name, fn) {\n  function parser() {\n    var chunks = [],\n        stream = new Transform({\n      objectMode: true\n    }); // Buffer all our data\n\n    stream._transform = function (chunk, encoding, done) {\n      chunks.push(chunk);\n      done();\n    }; // And call the parser when all is there.\n\n\n    stream._flush = function (done) {\n      var self = this,\n          data = Buffer.concat(chunks);\n\n      try {\n        fn(data, function (err, result) {\n          if (err) throw err;\n          self.push(result);\n        });\n      } catch (err) {\n        self.push(data); // just pass the original data\n      } finally {\n        done();\n      }\n    };\n\n    return stream;\n  }\n\n  return {\n    fn: parser,\n    name: name\n  };\n}\n\nvar parsers = {};\n\nfunction buildParser(name, types, fn) {\n  var parser = parserFactory(name, fn);\n  types.forEach(function (type) {\n    parsers[type] = parser;\n  });\n}\n\nbuildParser('json', ['application/json', 'text/javascript'], function (buffer, cb) {\n  var err, data;\n\n  try {\n    data = JSON.parse(buffer);\n  } catch (e) {\n    err = e;\n  }\n\n  cb(err, data);\n});\nbuildParser('xml', ['text/xml', 'application/xml', 'application/rdf+xml', 'application/rss+xml', 'application/atom+xml'], function (buffer, cb) {\n  parseXML(buffer.toString(), function (err, obj) {\n    cb(err, obj);\n  });\n});\nmodule.exports = parsers;\nmodule.exports.use = buildParser;","map":{"version":3,"sources":["/Users/ryandavis/Development/reactapp/expresstimes/node_modules/chokidar/node_modules/fsevents/node_modules/needle/lib/parsers.js"],"names":["Transform","require","sax","parseXML","str","cb","obj","current","parser","trim","lowercase","onerror","onend","done","err","newElement","name","attributes","value","children","ontext","t","onopentag","node","element","parent","push","onclosetag","just_closed","write","close","parserFactory","fn","chunks","stream","objectMode","_transform","chunk","encoding","_flush","self","data","Buffer","concat","result","parsers","buildParser","types","forEach","type","buffer","JSON","parse","e","toString","module","exports","use"],"mappings":"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","sourcesContent":["//////////////////////////////////////////\n// Defines mappings between content-type\n// and the appropriate parsers.\n//////////////////////////////////////////\n\nvar Transform = require('stream').Transform;\nvar sax = require('sax');\n\nfunction parseXML(str, cb) {\n  var obj, current, parser = sax.parser(true, { trim: true, lowercase: true })\n  parser.onerror = parser.onend = done;\n\n  function done(err) {\n    parser.onerror = parser.onend = function() { }\n    cb(err, obj)\n  }\n\n  function newElement(name, attributes) {\n    return {\n      name: name || '',\n      value: '',\n      attributes: attributes || {},\n      children: []\n    }\n  }\n\n  parser.ontext = function(t) {\n    if (current) current.value += t\n  }\n\n  parser.onopentag = function(node) {\n    var element = newElement(node.name, node.attributes)\n    if (current) {\n      element.parent = current\n      current.children.push(element)\n    } else { // root object\n      obj = element\n    }\n\n    current = element\n  };\n\n  parser.onclosetag = function() {\n    if (typeof current.parent !== 'undefined') {\n      var just_closed = current\n      current = current.parent\n      delete just_closed.parent\n    }\n  }\n\n  parser.write(str).close()\n}\n\nfunction parserFactory(name, fn) {\n\n  function parser() {\n    var chunks = [],\n        stream = new Transform({ objectMode: true });\n\n    // Buffer all our data\n    stream._transform = function(chunk, encoding, done) {\n      chunks.push(chunk);\n      done();\n    }\n\n    // And call the parser when all is there.\n    stream._flush = function(done) {\n      var self = this,\n          data = Buffer.concat(chunks);\n\n      try {\n        fn(data, function(err, result) {\n          if (err) throw err;\n          self.push(result);\n        });\n      } catch (err) {\n        self.push(data); // just pass the original data\n      } finally {\n        done();\n      }\n    }\n\n    return stream;\n  }\n\n  return { fn: parser, name: name };\n}\n\nvar parsers = {}\n\nfunction buildParser(name, types, fn) {\n  var parser = parserFactory(name, fn);\n  types.forEach(function(type) {\n    parsers[type] = parser;\n  })\n}\n\nbuildParser('json', [\n  'application/json',\n  'text/javascript'\n], function(buffer, cb) {\n  var err, data;\n  try { data = JSON.parse(buffer); } catch (e) { err = e; }\n  cb(err, data);\n});\n\nbuildParser('xml', [\n  'text/xml',\n  'application/xml',\n  'application/rdf+xml',\n  'application/rss+xml',\n  'application/atom+xml'\n], function(buffer, cb) {\n  parseXML(buffer.toString(), function(err, obj) {\n    cb(err, obj)\n  })\n});\n\nmodule.exports = parsers;\nmodule.exports.use = buildParser;"]},"metadata":{},"sourceType":"script"}